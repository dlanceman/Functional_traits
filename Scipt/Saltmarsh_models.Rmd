---
title: "Saltmarsh mixed modelling"
author: "Dana Lanceman"
date: "2023-10-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R script tests different types of modelling that can be applied to our saltmarsh functional traits dataset.

# 1. Set up


```{r Load packages}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")
#install.packages("ggeffects")
#install.packages("emmeans")
#install.packages("robustlmm")
#install.packages("mvabund")
#install.packages("plyr")
#install.packages("ecostats")
#install.packages("viridis")
#install.packages("betareg")
#install.packages("ggpubr")
#install.packages("countreg", repos="http://R-Forge.R-project.org", type = "binary")
#install.packages("statmod")
#install.packages("lmerTest")
#install.packages("sjPlot")
#install.packages("DHARMa")

library(plyr)
library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(glmmTMB)
library(bbmle)
library(GLMMadaptive)
library(ggeffects)
library(emmeans)
library(robustlmm)
library(mvabund)
require(tweedie)
require(statmod)
library(ecostats)
library(viridis)
library(betareg)
library(ggpubr)
library(countreg)
library(lmerTest)
library(sjPlot)
library(DHARMa)
```


```{r Get data}
# set working directory
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

# input saltmarsh data
salt <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Saltmarsh") %>% 
  arrange(Date, Time) %>% 
  mutate(Quadrat_area = Quad_length_cm^2, # add a column for quadrat area to use as an offset
    total_stems = round(Stems * 10000/Quad_length_cm^2), # add column for total stem count per 1m2 for each species to standardise stem counts for plots. Round makes it an integer.
         Buds = case_when(  # reassign Buds as a numeric variable
           Buds == "Yes" ~ 1,
           Buds == "No" ~ 0,
           Buds == "Unknown" ~ NA,
           Buds == "NA" ~ NA
         ),
         Flowers = case_when(  # reassign Flowers as a numeric variable
           Flowers == "Yes" ~ 1,
           Flowers == "No" ~ 0,
           Flowers == "Unknown" ~ NA,
           Flowers == "NA" ~ NA
         ),
        Seeds = case_when( # standardise Seeds wording
          Seeds == "Yes" ~ "Yes",
          Seeds == "Seeds" ~ "Yes",
          Seeds == "No" ~ "No",
          Seeds == "Lots" ~ "Lots",
          Seeds == "Some" ~ "Some",
          Seeds == "some" ~ "Some",
          Seeds == "Few" ~ "Few",
          Seeds == "Very few" ~ "Very few",
          Seeds == "NA" ~ NA,
          Seeds == "Unknown" ~ NA
          ),
         rest_status = case_when(
           Site == "AE" ~ as.numeric("1"),
           Site == "HS" ~ as.numeric("1"),
           Site == "TA" ~ as.numeric("1"),
           Site == "TB" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           .default = as.numeric("0"), # add a column for restoration status where 1 = restored and 0 = natural
         ),
         rest_year = case_when(
           Site == "AE" ~ as.numeric("2017"),
           Site == "HS" ~ as.numeric("2011"),
           Site == "TA" ~ as.numeric("2007"),
           Site == "TB" ~ as.numeric("2012"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "AE" ~ as.numeric("6"),
           Site == "HS" ~ as.numeric("12"),
           Site == "TA" ~ as.numeric("16"),
           Site == "TB" ~ as.numeric("11"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9") #,
           #Site == "AI" ~ as.numeric("NA"), # figure out how best to include natural sites in model when they don't have a restoration age
           #Site == "SI" ~ as.numeric("NA"),
           #Site == "VSR" ~ as.numeric("NA"),
           #Site == "MWS" ~ as.numeric("NA"),
         ))  # add a column for years since restoration
# double check with Will years for each

# Create a column for the Dominant Species in each quadrat
salt <- salt %>%
  group_by(Combo) %>% 
  mutate(
    MaxSpeciesCover = max(`Sp_cover_%`),
    DomSpecies = ifelse(100 - `Total_cover_%` > MaxSpeciesCover, "unvegetated", 
                        paste(unique(Species[`Sp_cover_%` == MaxSpeciesCover]), collapse = ", "))) %>% # Calculate the species with maximum cover for each Quadrat, and list multiple if it's a tie
  ungroup() %>%
  dplyr::select(-MaxSpeciesCover) # Remove MaxSpeciesCover colummn


# For quadrats that have ended up listing two species as jointly dominant, manually edit these to include whichever of these species is "bulkier" as dominant
# i.e. Juncus > Triglochin, Sarcocornia > GSG, Juncus > Sporobolus

salt <- salt %>% mutate(
  DomSpecies = case_when(
    DomSpecies == "Juncus_kraussii, Sporobolus" ~ "Juncus_kraussii",
    DomSpecies == "Juncus_kraussii, Triglochin" ~ "Juncus_kraussii",
    DomSpecies == "GSG, Sarcocornia" ~ "Sarcocornia",
    .default = DomSpecies
  )
)

# create a column for proportion cover of each species (species cover/overall cover)
salt <- salt %>% mutate(sp_prop = `Sp_cover_%`/`Total_cover_%`)

# reassign Quadrat as an explictly nested variable within Site
salt$Quadrat <- as.character(salt$Quadrat)
salt$Quadrat.f <- factor(interaction(salt$Site, salt$Quadrat, sep = ":"))
salt$Quadrat.f <- as.character(salt$Quadrat.f)


# load saltmarsh community composition data
salt_comm_comp <- read_excel("Data/salt_comm_comp.xlsx", sheet = "alldata")
```


```{r Create species-specific dataframes}
spor <- salt %>%
  filter(Species == "Sporobolus")

sarc <- salt %>%
  filter(Species == "Sarcocornia")

trig <- salt %>%
  filter(Species == "Triglochin")

pneu <- salt %>%
  filter(Species == "Pneumatophores")

```


Outlier removal - these were checked in the Saltmarsh_fn_traits script.

```{r Remove unrealistic outliers}
salt[443,20] <- NA # remove triglochin measurement with unrealistic stem diameter >4mm
salt[c(738:744), 20] <- NA # remove triglochin measurements with unrealistic stem diameter >4mm
salt[802,19] <- NA # remove triglochin measurement with unrealistic stem height 556mm
salt[1271,19] <- NA # remove triglochin measurement with unrealistic stem height 860mm
salt[112,20] <- NA # remove pneumatophore measurement with unrealistic diameter 1mm
salt[c(862,917),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm

trig[121,19] <- NA # this value had stem height of 556mm
trig[240,19] <- NA # this value had stem height of 860mm
trig[c(98:104),20] <- NA # these had stem diameters > 4mm
trig[78,20] <- NA # stem diameter was > 4mm
pneu[40,20] <- NA # this had stem diameter of 1mm
spor[c(283,313),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm
```


Data transformations - need to check whether these are required for these models. If so, need to check across-species assumptions.
```{r Data transformations}
# overall saltmarsh
salt$ln.canopy.ht <- log(salt$Canopy_ht_cm)

# sporobolus
spor$ln.stem.ht <- log(spor$Stem_ht_mm)
spor$sq.stem.ht <- sqrt(spor$Stem_ht_mm)
spor$ln.stem.dia <- log(spor$Stem_dia_mm + 0.01)
spor$sq.stem.dia <- sqrt(spor$Stem_dia_mm)
spor$sq.stem.dens <- sqrt(spor$total_stems)

# sarcocornia
sarc$sq.stem.dia <- sqrt(sarc$Stem_dia_mm)
sarc$sq.stem.dens <- sqrt(sarc$total_stems)

# triglochin
trig$ln.sp.cover <- log(trig$`Sp_cover_%` + 0.01)
trig$sq.stem.dia <- sqrt(trig$Stem_dia_mm)
trig$ln.stem.dens <- log(trig$total_stems)

# pneumatophores
pneu$sq.sp.cover <- sqrt(pneu$`Sp_cover_%`)
pneu$sq.stem.dens <- sqrt(pneu$total_stems)
```

Check distribution of explanatory variables
```{r Check distribution of explanatory variables}
hist(salt$YSR)
hist(log(salt$YSR))
```


Can be useful to rescale explanatory variables so they have a constant mean of 0 and standard deviation of 1.
Delete this unless any models don't converge or to compare variable importance.
```{r Rescale/standardise explanatory variables}
#salt$Elevation <- scale(salt$Elevation, center = TRUE, scale = TRUE)
#spor$Elevation <- scale(spor$Elevation, center = TRUE, scale = TRUE)
#sarc$Elevation <- scale(sarc$Elevation, center = TRUE, scale = TRUE)
#trig$Elevation <- scale(trig$Elevation, center = TRUE, scale = TRUE)
#pneu$Elevation <- scale(pneu$Elevation, center = TRUE, scale = TRUE)

```


Duplicate deletion - for community-level variables, there are several rows for each quadrat that are all identical. We need to remove these duplicate rows

```{r Duplicate deletion - community-level variables}
salt_comm <- salt %>% distinct(Combo, .keep_all = TRUE) 
salt_comm <- salt_comm[,-c(11:20,22,26,27,34)] # remove irrelevant rows
# turn total cover into a proportion between 0 and 1 instead of between 0 and 100
salt_comm <- salt_comm %>% mutate(total_cover_prop = `Total_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.

spor_comm <- spor %>% distinct(Combo, .keep_all = TRUE) 
spor_comm <- spor_comm[,-c(19,20,34:37)] # remove irrelevant rows

sarc_comm <- sarc %>% distinct(Combo, .keep_all = TRUE) 
sarc_comm <- sarc_comm[,-c(19,20,34)] # remove irrelevant rows

trig_comm <- trig %>% distinct(Combo, .keep_all = TRUE) 
trig_comm <- trig_comm[,-c(19,20,35)] # remove irrelevant rows

pneu_comm <- pneu %>% distinct(Combo, .keep_all = TRUE) 
pneu_comm <- pneu_comm[,-c(19,20)] # remove irrelevant rows
  
```

```{r New variables}
# turn species cover into a proportion between 0 and 1 instead of between 0 and 100
spor_comm <- spor_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.
sarc_comm <- sarc_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
trig_comm <- trig_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)

# make a simplified DomSpecies variable where rare DomSpecies are grouped together in class "other"
salt_comm <- salt_comm %>% mutate(DomSpeciesSimp = case_when(
  DomSpecies == "Sporobolus" ~ "Sporobolus",
  DomSpecies == "Sarcocornia" ~ "Sarcocornia",
  DomSpecies == "Bolboschoenus" ~ "Bolboschoenus",
  DomSpecies == "Phragmites" ~ "Phragmites",
  DomSpecies == "unvegetated" ~ "Other",
  DomSpecies == "Juncus_kraussii" ~ "Other",
  DomSpecies == "Aster" ~ "Other",
  DomSpecies == "Triglochin" ~ "Other",
  DomSpecies == "Suaeda" ~ "Other",
  DomSpecies == "Juncus_sp1" ~ "Other",
  DomSpecies == "Juncus_sp2" ~ "Other"
))

salt <- salt %>% mutate(DomSpeciesSimp = case_when(
  DomSpecies == "Sporobolus" ~ "Sporobolus",
  DomSpecies == "Sarcocornia" ~ "Sarcocornia",
  DomSpecies == "Bolboschoenus" ~ "Bolboschoenus",
  DomSpecies == "Phragmites" ~ "Phragmites",
  DomSpecies == "unvegetated" ~ "Other",
  DomSpecies == "Juncus_kraussii" ~ "Other",
  DomSpecies == "Aster" ~ "Other",
  DomSpecies == "Triglochin" ~ "Other",
  DomSpecies == "Suaeda" ~ "Other",
  DomSpecies == "Juncus_sp1" ~ "Other",
  DomSpecies == "Juncus_sp2" ~ "Other"
))


# try even simpler with DomSpeciesSuperSimp - only Sporobolus, Sarcocornia or Other
salt_comm <- salt_comm %>% mutate(DomSpeciesSuperSimp = case_when(
  DomSpeciesSimp == "Sporobolus" ~ "Sporobolus",
  DomSpeciesSimp == "Sarcocornia" ~ "Sarcocornia",
  DomSpeciesSimp == "Bolboschoenus" ~ "Other",
  DomSpeciesSimp == "Phragmites" ~ "Other",
  DomSpeciesSimp == "Other" ~ "Other"
))

salt <- salt %>% mutate(DomSpeciesSuperSimp = case_when(
  DomSpeciesSimp == "Sporobolus" ~ "Sporobolus",
  DomSpeciesSimp == "Sarcocornia" ~ "Sarcocornia",
  DomSpeciesSimp == "Bolboschoenus" ~ "Other",
  DomSpeciesSimp == "Phragmites" ~ "Other",
  DomSpeciesSimp == "Other" ~ "Other"
))

```


Create datasets for just restored data and just natural data
```{r Subsetting dataframes}
salt_H <- salt %>% subset(Estuary == "Hunter")
spor_H <- spor %>% subset(Estuary == "Hunter")
sarc_H <- sarc %>% subset(Estuary == "Hunter")
trig_H <- trig %>% subset(Estuary == "Hunter")
pneu_H <- pneu %>% subset(Estuary == "Hunter")

salt_H_rest <- salt_H %>% subset(rest_status == 1)
spor_H_rest <- spor_H %>% subset(rest_status == 1)
sarc_H_rest <- sarc_H %>% subset(rest_status == 1)
trig_H_rest <- trig_H %>% subset(rest_status == 1)
pneu_H_rest <- pneu_H %>% subset(rest_status == 1)

salt_H_nat <- salt_H %>% subset(rest_status == 0)
spor_H_nat <- spor_H %>% subset(rest_status == 0)
sarc_H_nat <- sarc_H %>% subset(rest_status == 0)
trig_H_nat <- trig_H %>% subset(rest_status == 0)
pneu_H_nat <- pneu_H %>% subset(rest_status == 0)

salt_comm_rest <- salt_comm %>% subset(salt_comm$rest_status == 1)
salt_comm_nat <- salt_comm %>% subset(salt_comm$rest_status == 0)
salt_comm_rest_H <- salt_comm_rest %>% subset(salt_comm_rest$Estuary == "Hunter")
salt_comm_nat_H <- salt_comm_nat %>% subset(salt_comm_nat$Estuary == "Hunter")
salt_comm_H <- salt_comm %>% subset(salt_comm$Estuary == "Hunter")

spor_comm_H <- spor_comm %>% subset(Estuary == "Hunter")
sarc_comm_H <- sarc_comm %>% subset(Estuary == "Hunter")
trig_comm_H <- trig_comm %>% subset(Estuary == "Hunter")
pneu_comm_H <- pneu_comm %>% subset(Estuary == "Hunter")

# Hunter only, restored only 
spor_comm_H_res <- spor_comm_H %>% subset(rest_status == "1")
sarc_comm_H_res <- sarc_comm_H %>% subset(rest_status == "1")
trig_comm_H_res <- trig_comm_H %>% subset(rest_status == "1")
pneu_comm_H_res <- pneu_comm_H %>% subset(rest_status == "1")

# Hunter only, natural only 
spor_comm_H_nat <- spor_comm_H %>% subset(rest_status == "0")
sarc_comm_H_nat <- sarc_comm_H %>% subset(rest_status == "0")
trig_comm_H_nat <- trig_comm_H %>% subset(rest_status == "0")
pneu_comm_H_nat <- pneu_comm_H %>% subset(rest_status == "0")

# community composition
salt_comm_comp_H <- salt_comm_comp %>% subset(Estuary == "Hunter")
salt_comm_comp_H_res <- salt_comm_comp_H %>% subset(rest_status == "1")
salt_comm_comp_H_nat <- salt_comm_comp_H %>% subset(rest_status == "0")
```

Before running models, we need to make sure none of our dependent variables are strongly correlated. If so, we cannot include all variables in analysis.

Our dependent variables of interest are:
- 	Community composition (multivariate) (can't really test for relationships here as it's a matrix)
-   Total cover (univariate)
-   Stem density
-   Stem diameter
-   Stem height
-   Reproduction (presence/absence) (can't really test for relationships here as they're binary variables?)

Exclude variables if their correlation coefficient is >0.8 (is this correct? and what can I cite for this?)

```{r Test for correlations between dependent variables}
# correlation matrix of correlation coefficients
cor(salt[,c(9,10,19,20,27)], use = "pairwise.complete.obs") # all correlation coefficients are >0.8, therefore retain all variables

# plot correlations between variables
# plot a bunch of correlation plots at once
salt_numeric <- salt[,c(9,10,19,20,27)]
plot(salt_numeric)
```


# A. Hunter only

# 2. Simple trial models - community level

First, let's create univariate models for our community-level variables (tallest canopy height, total cover and burrows).


# 2a Tallest canopy height

Tallest canopy height
- Canopy height ~ YSR + DomSpecies + Elevation + (1|Site)

First assumption: linear relationship between predictors and response variable

```{r Tallest canopy height - check assumptions - linear relationship }
# numeric predictors are YSR and elevation
plot(salt_comm_rest_H$Canopy_ht_cm ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$Canopy_ht_cm ~ salt_comm_rest_H$Elevation) # possibly non-linear
```


```{r Tallest canopy height - model}
# try a model with polynomial variables
M1 <- lmer(Canopy_ht_cm ~ poly(YSR,2) + DomSpecies + poly(Elevation,2) + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M1)

# estimate > st error for 2nd order polynomial YSR & 1st order polynomial
# 1st order elevation is significant here, but 2nd order isn't, so remove it

M2 <- lmer(Canopy_ht_cm ~ poly(YSR,2) + DomSpecies + Elevation + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M2)

# try a model with polynomial variables and log transform
M3 <- lmer(ln.canopy.ht ~ poly(YSR,2) + DomSpecies + poly(Elevation,2) + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M3)

# remove non-significant factors - polynomial elevation

M4 <- lmer(ln.canopy.ht ~ poly(YSR,2) + DomSpecies + Elevation + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M4)
```

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Tallest canopy height - check residuals assumptions}
# try M1 
# check for collinearity between predictors
check_collinearity(M1) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M1) # roughly equal variances
qqnorm(resid(M1)) 
qqline(resid(M1)) # not great (high values diverge)

# try M2
# check for collinearity between predictors
check_collinearity(M2) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M2) # roughly equal variances 
qqnorm(resid(M2)) 
qqline(resid(M2)) # not great - similar to before

# try M3 
# check for collinearity between predictors
check_collinearity(M3) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M3) # roughly equal variances 
qqnorm(resid(M3)) 
qqline(resid(M3)) # high and low values diverge but somewhat better than non-transformed

# use log transformed rather than non-transformed
# confirm if this is good enough

# try M4
# check for collinearity between predictors
check_collinearity(M4) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M4) # good
qqnorm(resid(M4)) 
qqline(resid(M4)) # same as M3
```

```{r Tallest canopy height - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = ln.canopy.ht)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(span = 10) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
    labs(y = "Canopy height (cm)", x = "Years since restoration") +
      theme_classic()

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M4, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
  labs(y = "Tallest stem height (cm)", x = "Years since restoration") +
  theme_classic()

# natural sites boxplot
ggplot(salt_comm_nat_H, aes(x = Site, y = ln.canopy.ht)) +
  geom_boxplot() +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht)))   +
  geom_point() +
    labs(y = "Canopy height (cm)") +
  theme_classic()

# Elevation
ggplot(salt_comm_rest_H, aes(x = Elevation, y = ln.canopy.ht)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = lm) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
    labs(y = "Canopy height (cm)", x = "Elevation (standardised)") +
      theme_classic() 
# ideally back-transform the elevation axis

# Dominant species
salt_comm_rest_H %>% 
  subset(DomSpecies %in% c("Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin")) %>% 
  ggplot(., aes(x = DomSpecies, y = ln.canopy.ht)) +
  geom_boxplot() +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht)))   +
  geom_point() +
    labs(y = "Canopy height (cm)") +
  theme_classic()
# aster, juncus, suaeda and unvegetated only have one value each so should be excluded from the plot and (maybe) model.
```


# 2b - Total cover 

Total cover
- Total cover ~ YSR + DomSpecies + Elevation 
- beta distribution (proportional data with 2 categories - cover and non cover)
- not a mixed model

```{r Total cover - Plot relationships between variables}
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$Elevation) # possibly non-linear
```

```{r Total cover - model}
# use glm with tweedie distrubution as tweedie is similar to beta distrubtion
M <- glm(total_cover_prop ~ poly(YSR,2) * DomSpecies * poly(Elevation,2), data = salt_comm_rest_H, family = tweedie(var.power=1.5, link = 0), na.action = na.exclude)
plot(M) # does not look good. regardless of var.power value. or whether YSR and elevation are included as polynomial or linear variables. or whether interactions are included or not.

# try with DomSpeciesSuperSimp and not interacting
M1 <- glm(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, family = tweedie(var.power=1.5, link = 0), na.action = na.exclude)
plot(M1)
# still not good

# try beta regression
M2 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) * DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
# error here - because of DomSpecies interaction

# beta regression with DomSpecies non-interacting
M3 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M3) # crazy large cooks distance for 7, 42 and 60. This is because these plots have unusual DomSpecies. Need to discuss.

# beta regression without DomSpecies
M4 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M4) # plots generally look good, except some relatively large cook's distance values (point 7 and 69) - not sure why 69 is large as it has the same total cover as other values. 7 has extremely low total cover but it's realistic.
summary(M4)

# check whether exclusion of influential points changes parameter estimates
M5 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H[-c(7,69),], link = "logit", na.action = na.exclude)
plot(M5) 
summary(M5)
# not massive differences in parameter estimates. Therefore hopefully OK to retain more influential values and use M4



# try DomSpeciesSimp instead that clumps rare DomSpecies into "Other"
# DomSpecies interaction is still not ok

# beta regression with DomSpecies non-interacting
M8 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M8) # now point 41 has very high cook's distnace and 7 and 69 are still high...

# try DomSpeciesSuperSimp
M9 <- betareg(total_cover_prop ~ poly(cbind(YSR,Elevation),2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M9) # still large cook's distance at 7, 41 and 69 but a bit better than before
summary(M9)
# after adjusting p-values by multiplying by 2, it's pretty similar to M4 - no significance, except in DomSpeciesSuperSimpSporobolus - more sporobolus means more cover. (highly significant)

# residuals plots comprehensive
plot(M9, which = 1:6,
  caption = c("Residuals vs indices of obs.", "Cook's distance plot",
    "Generalized leverage vs predicted values", "Residuals vs linear predictor", 
    "Half-normal plot of residuals", "Predicted vs observed values"),
    sub.caption = paste(deparse(M9$call), collapse = "\n"), main = "", 
    ask = prod(par("mfcol")) < length(which) && dev.interactive(), type = "sweighted2", nsim = 100, level = 0.9)

# check whether similar results are obtained when extreme cook's distance values are removed
M10 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSuperSimp, data = salt_comm_rest_H[-c(7,41,69),], link = "logit", na.action = na.exclude)
plot(M10) # cook's distance plot looks much better
summary(M10) # there are some differences from M9. but the influential values are realistic so should be retained..



M11 <- lm(total_cover_prop ~ poly(cbind(YSR,Elevation),2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, na.action = na.exclude)
plot(M11)

plot(salt_comm_rest_H$total_cover_prop)
hist(log(1-salt_comm_rest_H$total_cover_prop))

# use M12 - too many 1's for a beta regression + cbind the two poly variables so we're not modelling interactions between their polynomial terms
M12 <- lm(log(1-salt_comm_rest_H$total_cover_prop) ~ poly(cbind(YSR,Elevation),2) +  DomSpeciesSuperSimp, data = salt_comm_rest_H, na.action = na.exclude)
plot(M12) # plots look good enough - the data are ~1 inflated so that's going to show up regardless but the spread looks way better now.
summary(M12)

# visually interpret the results
# first calculate quantile values for elevation
quantile(salt_comm_rest_H$Elevation)
# insert quantile 1 and quantile 3 values as Elevation values to use
emmip(M12, Elevation~YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,9,11,12,19,30,33), Elevation = c(0.143, 0.469), CIs = TRUE))
# can see the trend, but would need to back-transform to understand what total cover values these correlate to.
# also there are no CIs
# note, back-transforming would reverse these trends
# so total cover increases with increasing elevation, is higher at middle YSR, is lowest for higher YSR, and is higher for sporobolus


# try adding sp_prop
M13 <- lm(log(1-salt_comm_rest_H$total_cover_prop) ~ poly(cbind(YSR,Elevation),2) +  DomSpeciesSuperSimp + sp_prop, data = salt_comm_rest_H, na.action = na.exclude)
plot(M13) # plots are a little worse than M12. need to come up with a good reason to include sp_prop or not based on theory 
summary(M13)
```

Other assumptions (??)

```{r Total cover - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = total_cover_prop)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 10) +
    labs(y = "Total cover (proportion)", x = "Years since restoration") +
      theme_classic()
# all look very similar

# plot restoring sites  - violin plot
ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (proportion)") +
  xlim(0,35) + 
  ylim(0,1)
# print at 1500 x 789

# plot restoring sites  - box plot
S_Cov_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (proportion)") +
  xlim(0,35) + 
  ylim(0,1)
S_Cov_rest
# print at 1500 x 789
# export at 2200 x 800 for preso, 1500 x 800 for paper

# plot natural sites - violin plot
ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,1)
# print at 700 x 789

# plot natural sites - box plot
S_Cov_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,1)
S_Cov_nat
# print at 700 x 789

# plot natural and restored together
ggarrange(S_Cov_rest,S_Cov_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# Elevation
ggplot(salt_comm_rest_H, aes(x = Elevation, y = total_cover_prop)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = lm) +
    labs(y = "Total cover (proportion)", x = "Elevation (standardised)") +
      theme_classic() 
# looks very similar
# ideally back-transform the elevation axis
```

```{r Total cover - summary stats}
# summary for all sites
summary(salt_comm$total_cover_prop, mean)
# summary by estuary
tapply(salt_comm$total_cover_prop, salt_comm$Estuary, mean)
# summary by site
tapply(salt_comm$total_cover_prop, salt_comm$Site, mean)
```


#2c - burrows

```{r Burrows - Exploration and data prep}
# plot relationships between variables
ggplot(data = salt_comm_rest_H, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)


plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$YSR) # relatively linear
plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$Elevation) # relatively linear


# remove NA data
salt_comm_rest_H_burrows <- salt_comm_rest_H %>% subset(!is.na(Burrows_0.5x0.5))

```

```{r Zero-inflation testing and model approach}
# test for zero-inflation

100*sum(salt_comm_rest_H_burrows$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm_rest_H_burrows)
# 58% of our data are zeroes

# check if this number of zeroes can be predicted under a poisson model
M1 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + DomSpecies + Elevation,
          family = 'poisson',
          data = salt_comm_rest_H_burrows)
plot(M1) # plot doesn't look good

# check if this number of zeroes can be predicted under a negative binomial model

M2 <- glm.nb(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          data = salt_comm_rest_H_burrows)
plot(M2) # plot doesn't look good

M3 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          family = 'nbinom2',
          data = salt_comm_rest_H_burrows)
plot(M3) # plot doesn't look good

# try zero inflated poisson with the package pscl
M4 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "poisson", na.action = na.exclude)
# DomSpecies is not working as an interaction so just including as a separate predictor
rootogram(M4, main = "ZIP", ylim = c(-5, 15), max = 50)
qqrplot(M4, main = "ZIP")


# also try zero-inflated negative binomial model
M5 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M5, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M5, main = "ZINB")
summary(M5)
# not computing standard errors...


# try hurdle negative binomial model
M6 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)

rootogram(M6, main = "HNB", ylim = c(-5, 15), max = 50) # smooth curve indicates good fit
qqrplot(M6, main = "HNB")


# zero-inflated negative binomial model (M5) looks like the best fit.
#  https://rpubs.com/kaz_yos/pscl-2 seems to think this sort of model is best when both structural zeroes (must be zero) and sampling zeroes (could have been other numbers) are present - not sure if this is the case for my data or if it matters?
# I think this would be the case for my model - there would be structural zeroes where the quadrat simply had no crab holes so it would be impossible to find burrows, but there might also be sampling zeroes where there was a crab burrow but it was missed? / or structural zeroes where the site has no crab burrows and sampling zeroes where the particular quadrat happens to have no crab burrows even though they do exist elsewhere on site


# try without DomSpecies to see if that's what's causing the problem (no SEs)
M7 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation , data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M7, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M7, main = "ZINB")

summary(M7) # standard errors are produced, therefore looks like DomSpecies is causing the issue. Probably because some values of DomSpecies only have one occurrence. Should we group these into an "other vege" or something?

# interpreting model with coefficients
expCoef <- exp(coef((M7)))
expCoef <- matrix(expCoef, ncol = 2)

rownames(expCoef) <- c("(intercept)","poly(YSR,2)1","poly(YSR,2)2","Elevation","poly(YSR,2)1:Elev", "poly(YSR,2)2:Elev")
colnames(expCoef) <- c("Count_model","Zero_inflation_model")
expCoef

# trying to interpret the count model. 
# - the baseline number of crabs is 0.68.
# - one unit increase in the first "arm" of YSR polynomial corresponds to 282523 x more crabs (???)
# - one unit increase in the second "arm" of YSR polynomial corresponds to 5.2 x more crabs (non significant)
# - one unit increase in elevation corresponds to 0.2 less crabs
# - there is a positive interaction between the first "arm" of YSR and elevation
# - there is a negative interaction between the second "arm" of YSR and elevation



# try a version of M5 with DomSpeciesSimp instead

M8 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSimp, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
summary(M8) # still comes up with error

# Try DomSpeciesSuperSimp
M9 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M9, main = "ZINB", ylim = c(-5, 15), max = 50) # looks fine
qqrplot(M9, main = "ZINB") # looks fine
summary(M9) # now no error.
plot(predict(M9), residuals(M9))

# try negative binomial in glmmTMB - might be ok without zero inflation
M10 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp, data = salt_comm_rest_H_burrows, family = "nbinom2")

# try zero inflated negative binomial model in glmmTMB
M11 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp, data = salt_comm_rest_H_burrows, family = "nbinom2", ziformula =~1)
# in this plot we expect to see an increasing variance trend as it's a negative binomial distribution and hasn't been altered to fit a flat distribution.
plot(predict(M11), residuals(M11), ylim = c(-50,50))

# plot residuals vs predicted values with adjustments for easier interpretation - should see a relatively flat, even spread of residuals with no clear trend
resid <- residuals(simulateResiduals(M10), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M10))
resid <- residuals(simulateResiduals(M11), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M11))
# M11 is flatter but they're both ok looking, use anova to test for differences between the two models

anova(M10,M11)
# significance here means the zero inflated part of the model does explain more of the variation, so therefore we should use the zero inflated model - M11

summary(M11)


# try with sp_prop
M12 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp + sp_prop, data = salt_comm_rest_H_burrows, family = "nbinom2", ziformula =~1)
# in this plot we expect to see an increasing variance trend as it's a negative binomial distribution and hasn't been altered to fit a flat distribution.
plot(predict(M12), residuals(M12), ylim = c(-50,50))
resid <- residuals(simulateResiduals(M12), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M12)) # this one should be flat - looks good
summary(M12)
```

```{r Burrows - plot}
# create plots while holding interacting variable (elevation) at fixed levels
# first calculate quantile values for elevation
quantile(salt_comm_rest_H$Elevation)
# histogram of elevation
hist(salt_comm_rest_H$Elevation)
# insert quantile 1 and quantile 3 values as Elevation values to use
emmip(M11, Elevation~YSR, at = list(YSR = c(6,9,11,12,19,30,33), Elevation = c(0.143, 0.469), CIs = TRUE))
# what do we do about negative values (impossible?)
# results are counterintuitive - and different to the predict code below - show for low elevations that there would be more burrows at low YSR? and mostly negative values for high elevations?
emmip(M11, Elevation~YSR, at = list(YSR = c(6,9,11,12,19,30,33), Elevation = c(0,0.2,0.4,0.6,0.8), CIs = TRUE))







# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = Burrows_0.5x0.5)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(span = 10)  +
    labs(y = "Burrows", x = "Years since restoration") +
      theme_classic()

# natural only
ggplot(salt_comm_nat_H, aes(x = Site, y = Burrows_0.5x0.5)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Burrows") +
  theme_classic()

salt_comm_rest_H$Burrows_ln <- log(salt_comm_rest_H$Burrows_0.5x0.5 + 0.001)

# boxplots - restored sites
S_Bur_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=Burrows_0.5x0.5, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of burrows") +
  xlim(0,35)  + ylim(0,62)
S_Bur_rest

# boxplots - natural sites
S_Bur_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=Burrows_0.5x0.5, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,62)
S_Bur_nat

# plot natural and restored together
ggarrange(S_Bur_rest,S_Bur_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# predict effects of YSR when controlling for the other factors
# this plot needs work - not sure what the y axis is??
predict_YSR <- ggemmeans(M11, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T) +
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Burrows", x = "Years since restoration") +
  theme_classic() 
```


```{r Also need to test restoration status}
M4 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status + Elevation + DomSpecies + (1|Site),
          family = 'nbinom2',
          data = salt_comm_H)

summary(M4)

# check dispersion issues for this model
E2 <- resid(M4, type = "pearson")
N  <- nrow(salt_comm_rest_H)
p  <- length(coef(M4))   
sum(E2^2) / (N - p)

# 1.62 = overdispersed but not too bad?
```

# 2d. Overall stem diameters and heights

```{r Overall stem diameters}
# to work out how the community looks in terms of stem diameters, we need to weight each species' diameters by their proportion. 
# for this, we'll need to create a wider dataset that has a row for every species' stem diameter and corresponding species proportion in that quadrat.
# this can be based on the average diameter of each species for each quadrat, so we'd end up with one row per quadrat.

# first, subset the salt dataset for only diameter-related data

salt_dia <- salt[,c(5:7,11,12,20,24,25,28,30:33,35,36)]

# then, widen based on both Stem_dia_mm and sp_prop. Calculate the mean stem diameter during this process (mean sp_prop will be identical to each sp_prop as this value is the same for each quadrat)

salt_dia_wider <- pivot_wider(salt_dia, id_cols = c(Estuary, Site, Quadrat, Quadrat.f, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = c(Species), values_from = c(Stem_dia_mm, sp_prop), values_fn = mean)

# then, calculate the average stem diameter for each quadrat
salt_dia_wider <-
  salt_dia_wider %>% 
  #rowwise will make sure the sum operation will occur on each row
  rowwise() %>% 
  mutate(Stem_dia_average = sum(Stem_dia_mm_Alternanthera*sp_prop_Alternanthera, 
    Stem_dia_mm_Aster*sp_prop_Aster,
    Stem_dia_mm_Ambrosia*sp_prop_Ambrosia,
    Stem_dia_mm_Bolboschoenus*sp_prop_Bolboschoenus,
    Stem_dia_mm_Cotula*sp_prop_Cotula,
    Stem_dia_mm_Grass_B * sp_prop_Grass_B,
    Stem_dia_mm_Grass_C * sp_prop_Grass_C,
    Stem_dia_mm_Grass_sp_1 * sp_prop_Grass_sp_1,
    Stem_dia_mm_Grass_sp_2 * sp_prop_Grass_sp_2,
    Stem_dia_mm_GSG * sp_prop_GSG,
    Stem_dia_mm_Juncus_acutus * sp_prop_Juncus_acutus,
    Stem_dia_mm_Juncus_kraussii * sp_prop_Juncus_kraussii,
    Stem_dia_mm_Juncus_sp1 * sp_prop_Juncus_sp1,
    Stem_dia_mm_Juncus_sp2 * sp_prop_Juncus_sp2,
    Stem_dia_mm_Lobelia * sp_prop_Lobelia,
    Stem_dia_mm_Mangrove_saplings_river * sp_prop_Mangrove_saplings_river,
    Stem_dia_mm_Mangrove_seedling * sp_prop_Mangrove_seedling,
    Stem_dia_mm_Pasture_grass * sp_prop_Pasture_grass,
    Stem_dia_mm_Phragmites * sp_prop_Phragmites,
    Stem_dia_mm_Pneumatophores * sp_prop_Pneumatophores,
    Stem_dia_mm_Sarcocornia * sp_prop_Sarcocornia,
    Stem_dia_mm_Sporobolus * sp_prop_Sporobolus,
    Stem_dia_mm_Suaeda * sp_prop_Suaeda,
    Stem_dia_mm_Triglochin * sp_prop_Triglochin,
    Stem_dia_mm_Watsonia * sp_prop_Watsonia, 
    na.rm=TRUE))

boxplot(salt_dia_wider$Stem_dia_average ~ salt_dia_wider$YSR)
boxplot(salt_dia_wider$Stem_dia_average ~ salt_dia_wider$Site) # weighted averages across site
boxplot(salt$Stem_dia_mm ~ salt$Site) # compare to incorrect averages across site


# try modelling?

M1 <- lm(Stem_dia_average ~ YSR * Elevation * DomSpeciesSimp, data = salt_dia_wider)
plot(M1) # not good

M2 <- lm(log(Stem_dia_average) ~ YSR * Elevation * DomSpeciesSimp, data = salt_dia_wider)
plot(M2) # pretty good
summary(M2) # no significant differences
```

```{r Overall stem heights}
# similar approach for stem heights!

# first, subset the salt dataset for only height-related data

salt_ht <- salt[,c(5:7,11,12,19,24,25,28,30:33,35,36)]

# then, widen based on both Stem_dia_mm and sp_prop. Calculate the mean stem diameter during this process (mean sp_prop will be identical to each sp_prop as this value is the same for each quadrat)

salt_ht_wider <- pivot_wider(salt_ht, id_cols = c(Estuary, Site, Quadrat, Quadrat.f, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = c(Species), values_from = c(Stem_ht_mm, sp_prop), values_fn = mean)

# then, calculate the average stem diameter for each quadrat
salt_ht_wider <-
  salt_ht_wider %>% 
  #rowwise will make sure the sum operation will occur on each row
  rowwise() %>% 
  mutate(Stem_ht_average = sum(Stem_ht_mm_Alternanthera*sp_prop_Alternanthera, 
    Stem_ht_mm_Aster*sp_prop_Aster,
    Stem_ht_mm_Ambrosia*sp_prop_Ambrosia,
    Stem_ht_mm_Bolboschoenus*sp_prop_Bolboschoenus,
    Stem_ht_mm_Cotula*sp_prop_Cotula,
    Stem_ht_mm_Grass_B * sp_prop_Grass_B,
    Stem_ht_mm_Grass_C * sp_prop_Grass_C,
    Stem_ht_mm_Grass_sp_1 * sp_prop_Grass_sp_1,
    Stem_ht_mm_Grass_sp_2 * sp_prop_Grass_sp_2,
    Stem_ht_mm_GSG * sp_prop_GSG,
    Stem_ht_mm_Juncus_acutus * sp_prop_Juncus_acutus,
    Stem_ht_mm_Juncus_kraussii * sp_prop_Juncus_kraussii,
    Stem_ht_mm_Juncus_sp1 * sp_prop_Juncus_sp1,
    Stem_ht_mm_Juncus_sp2 * sp_prop_Juncus_sp2,
    Stem_ht_mm_Lobelia * sp_prop_Lobelia,
    Stem_ht_mm_Mangrove_saplings_river * sp_prop_Mangrove_saplings_river,
    Stem_ht_mm_Mangrove_seedling * sp_prop_Mangrove_seedling,
    Stem_ht_mm_Pasture_grass * sp_prop_Pasture_grass,
    Stem_ht_mm_Phragmites * sp_prop_Phragmites,
    Stem_ht_mm_Pneumatophores * sp_prop_Pneumatophores,
    Stem_ht_mm_Sarcocornia * sp_prop_Sarcocornia,
    Stem_ht_mm_Sporobolus * sp_prop_Sporobolus,
    Stem_ht_mm_Suaeda * sp_prop_Suaeda,
    Stem_ht_mm_Triglochin * sp_prop_Triglochin,
    Stem_ht_mm_Watsonia * sp_prop_Watsonia, 
    na.rm=TRUE))

boxplot(salt_ht_wider$Stem_ht_average ~ salt_ht_wider$YSR)
boxplot(salt_ht_wider$Stem_ht_average ~ salt_ht_wider$Site) # weighted averages across site
boxplot(salt$Stem_ht_mm ~ salt$Site) # compare to incorrect averages across site

M1 <- lm(Stem_ht_average ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M1) # not good

M2 <- lm(log(Stem_ht_average) ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M2) # not great

M3 <- lm(sqrt(Stem_ht_average) ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M3) # not great

# none are probably good enough but test M2 for interest
summary(M2) # lots of potential significance
```


# 3. Simple trial models - species level

# 3a - Sporobolus

Sporobolus stem density, height and diameter

Explanatory variables:
- restoration status (binary) OR YSR (continuous), depending on the model
- Elevation (continuous)
- Site (random, nested in restoration status)
- Quadrat (for stem height and diameter, unless we average them) (random, nested in Site in restoration status)
- Dominant species (categorical)
- species proportional cover (continuous)


```{r Sporobolus continuous depedent variables - check correlations}
plot(spor_H$total_stems ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$Stem_ht_mm ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$total_stems ~ spor_H$Stem_ht_mm) # not correlated

# therefore can model all three variables, as none are correlated
```

Should we only include Dominant Species of interest?

# 3ai. Sporobolus stem height

```{r Sporobolus stem height - initial assumptions}
hist(spor_H$Stem_ht_mm)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_ht_mm ~ spor_H$sp_prop) # potentially slightly non-linear, and clearly species proportion is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.
ggplot(spor_H, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 1) 

plot(spor_H$Stem_ht_mm ~ spor_H$Elevation) # looks non-linear
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.5)
# therefore try including these variables as non-linear predictor variables. Maybe a quadratic and cubic function respectively?

plot(spor_H$Stem_ht_mm ~ spor_H$YSR) # not sure
ggplot(spor_H, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.8) # maybe non-linear
```


```{r Sporobolus stem height - restoration status - Model building}
# create model
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_ht)

# 3rd order polynomial elevation was non-significant, so include as a 2nd order polynomial
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M_spor_H_stem_ht)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_ht) # VIF ~ 6 (moderate collinearity) 
# species proportions and dominance are correlated here - drop one.

# drop DomSpecies predictor variable as it has the highest VIF
M <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,2) + poly(sp_prop, 2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # VIF are all <5 (low collinearity)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # not great



# try using log-transformed stem height data given that assumptions are not ok
M <- lmer(ln.stem.ht ~ rest_status + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# drop elevation 2 and 3 - only 1 is significant
M <- lmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # some VIF are >5 (moderate collinearity)

# drop species proportion as it has the highest VIF
M <- lmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

check_collinearity(M) # all VIF are <5 (low collinearity)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # not good


# try square-root transformed?
M <- lmer(sq.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # good
qqnorm(resid(M)) 
qqline(resid(M)) # still not very good. could be due to 1-inflation. try a different model type?


# try robust lmer
M2 <- rlmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)

# residuals plots
plot(M2) # 
qqnorm(resid(M2)) 
qqline(resid(M2))
# still not good. Looks similar to plots made with normal lmer rather than rlmer.
```


```{r Sporobolus stem height - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  #geom_smooth(span = 1)
  stat_smooth(method="lm", se=TRUE, fill=NA,
                formula=y ~ poly(x, 2, raw=TRUE))

boxplot(spor_H$Stem_ht_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_ht_mm ~ spor_H$DomSpecies)
```




```{r Sporobolus stem height - YSR - Model building}
# create model
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ poly(YSR,2) + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M_spor_H_stem_ht)

# drop elevation poly 3 and YSR poly 2
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # some VIF are >5 (moderate collinearity)

# drop DomSpecies, which has the highest VIF
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# now sp prop poly 2 is non-significant, drop it
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # looks good
qqnorm(resid(M)) 
qqline(resid(M)) # mostly ok but high values diverge.. need to decide if OK

# try log-transformed data
M <- lmer(ln.stem.ht ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # not great- high and low values diverge

# try sqrt-transformed data
M <- lmer(sq.stem.ht ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # similar to log-transformed

# try robust lmer
M <- rlmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # worse than original
```


```{r Sporobolus stem height - YSR - plot}
# best model - need to see if any model is good enough though
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

ggplot(spor_H_rest, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Sporobolus stem height", x = "Years since restoration") +
  theme_classic()

# plot predicted values of Elevation with ggeffects ggemmeans
predict_YSR <- ggemmeans(M, terms = c("Elevation [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Sporobolus stem height", x = "Elevation") +
  theme_classic()
# need to de-standardise elevation scale

ggplot(spor_H_rest, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)
```



# 3aii. Stem diameter

```{r Sporobolus stem diameter - initial assumptions}
hist(spor_H$Stem_dia_mm)
hist(spor_H$sp_prop)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_dia_mm ~ spor_H$sp_prop) # linearity is fine, but clearly sp. proportions is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.

plot(spor_H$Stem_dia_mm ~ spor_H$Elevation) # looks fine

plot(spor_H$Stem_dia_mm ~ spor_H$YSR) # fine
```


```{r Sporobolus stem diameter - restoration status - Model building}
# create model
M <- lmer(Stem_dia_mm ~ rest_status + Elevation + DomSpecies + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# sp prop is clearly non-significant, drop it first
M <- lmer(Stem_dia_mm ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M) # all VIF < 5 (low collinearity)

# residuals plots
plot(M) # not equal variances / a couple outliers
qqnorm(resid(M)) 
qqline(resid(M)) # not good - high values diverge


# try using log-transformed stem diameter data given that assumptions are not ok
M <- lmer(ln.stem.dia ~ rest_status + Elevation + DomSpecies+ (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # still not good - probably best option though


# try square-root transformed?
M <- lmer(sq.stem.dia ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # good
qqnorm(resid(M)) 
qqline(resid(M)) # still not very good. could be due to inflation. try a different model type?
```


```{r Sporobolus stem diameter - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_dia_mm)) +
  geom_point() +
  stat_smooth(method="lm")

boxplot(spor_H$Stem_dia_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_dia_mm ~ spor_H$DomSpecies)

boxplot(spor_H$Stem_dia_mm ~ spor_H$Site)
```




```{r Sporobolus stem diameter - YSR - Model building}
# create model
M1 <- lmer(Stem_dia_mm ~ YSR + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M1)

# check for collinearity between predictors
check_collinearity(M1) # some VIF are >5 (moderate collinearity)

# sp_prop has slightly higher VIF, drop sp_prop
M2 <- lmer(Stem_dia_mm ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M2)

# residuals plots
plot(M2) # roughly equal variances
qqnorm(resid(M2)) 
qqline(resid(M2)) # mostly ok but high values diverge.. not great

# try log-transformed data
M3 <- lmer(ln.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M3)

# residuals plots
plot(M3) # roughly equal variances 
qqnorm(resid(M3)) 
qqline(resid(M3)) # terrible

# try sqrt-transformed data
M4 <- lmer(sq.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M4)

# residuals plots
plot(M4) # roughly equal variances
qqnorm(resid(M4)) 
qqline(resid(M4)) # not great, ok..
```


```{r Sporobolus stem diameter - YSR - plot}
# best model? but not good...
M4 <- lmer(sq.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M4)

ggplot(spor_H_rest, aes(x = YSR, y = sq.stem.dia)) +
  geom_point() +
  geom_smooth(method = lm)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M4, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$ln.stem.dia)^2)), labels = pretty((spor_H_rest$ln.stem.dia)^2)) +
  labs(y = "Sporobolus stem diameter (mm)", x = "Years since restoration") +
  theme_classic()

# plot natural stem diameters
ggplot(spor_H_nat, aes(x = Site, y = ln.stem.dia)) +
  geom_boxplot() +
  geom_jitter(width=0.1) +
    scale_y_continuous(breaks = log(pretty(exp(spor_H_nat$ln.stem.dia))), labels = pretty(exp(spor_H_nat$ln.stem.dia))) +
    labs(y = "Sporobolus stem diameter (mm)", x = "Site") +
  theme_classic() 

# elevation
ggplot(spor_H_rest, aes(x = Elevation, y = ln.stem.dia)) +
  geom_point() +
  geom_smooth(span = 1)

# dominant species
ggplot(spor_H_rest, aes(x = DomSpecies, y = ln.stem.dia)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Log stem diameter") +
  theme_classic()

# need to back-transform and label these properly
```


# 3aiii. Sporobolus stem density 
- Stem density ~ YSR + Elevation + DomSpecies + SpeciesProportion + (1|Site)
- stem density is a positive integer value so should be able to conform to a roughly normal distribution

First assumption: linear relationship between predictors and response variable

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Sporoblus stem density - initial assumptions}
# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_comm_H$total_stems ~ spor_comm_H$sp_prop) # potentially non-linear
ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 1) +
  geom_smooth(method = lm) # polynomial is a better fit, try that first

plot(spor_comm_H$total_stems ~ spor_comm_H$Elevation) # not obviously non-linear

plot(spor_comm_H$total_stems ~ spor_comm_H$YSR) # looks potentially non-linear
ggplot(spor_comm_H, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 2) +
  geom_smooth(method = lm) # non-linear is a better fit
```


```{r Sporoblus stem density - restoration status - model}
# create model
M_spor_H_stem_dens <- lmer(total_stems ~ rest_status + Elevation + DomSpecies + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_dens)

# looks like elevation and species proportion influence Sporobolus stem density, but not restoration status (exploratory plots looked like restoration status did have an influence, but older sites were similar to natural sites, so wouldn't necessarily show up in this binary model)

# create a simplified model with only the significant factors
M_spor_H_stem_dens <- lmer(total_stems ~ Elevation + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
summary(M_spor_H_stem_dens)
# elevation is no longer significant?


# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_dens) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M_spor_H_stem_dens) # equal variances assumption is not ok
qqnorm(resid(M_spor_H_stem_dens)) 
qqline(resid(M_spor_H_stem_dens)) # not great but not terrible


# try with sq stem density
M_spor_H_stem_dens <- lmer(sq.stem.dens ~ Elevation + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
summary(M_spor_H_stem_dens)
# elevation is no longer significant?


# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_dens) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M_spor_H_stem_dens) # not good
qqnorm(resid(M_spor_H_stem_dens)) 
qqline(resid(M_spor_H_stem_dens)) # great


# remove sp_prop from model? as it's logically correlated with stem density
M_spor_H_stem_dens <- lmer(total_stems ~ rest_status + Elevation + DomSpecies + (1|Site), data = spor_comm_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_dens)

# only DomSpecies sporobolus is significant - which again makes sense as there will be more stems when it's dominant
# not really happy with any of these models..
```


```{r Sporoblus stem density - restoration status - plot}
# plot
ggplot(spor_comm_H, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$total_stems ~ spor_comm_H$rest_status)
```


```{r Sporoblus stem density - YSR - model}
M <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + poly(sp_prop,2) + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M)

# everything except DomSpecies is significant. But sp_prop should probably be excluded.

M2 <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M2)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M2) # all VIF are <5 (low collinearity)

# residuals plots
plot(M2) # not equal variances
qqnorm(resid(M2)) 
qqline(resid(M2)) # normality is great!

# try sqrt transform
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

plot(M3) # good
qqnorm(resid(M3)) 
qqline(resid(M3)) # a couple diverging values, but good enough
```


```{r Sporoblus stem density - YSR - plot}
# final model
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

# plot - YSR
ggplot(spor_comm_H_res, aes(x = YSR, y = sq.stem.dens)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
      theme_classic() +
  xlim(0,35)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M3, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T, add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
  labs(y = "Sporobolus stems per square metre", x = "Years since restoration") +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

# plot restoring sites  - box plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 1.5) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789
# export at 2200 x 800

# plot natural sites - box plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

ggplot(spor_comm_H_res, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)
```


# 3aiv - Sporobolus quantitative variables (multivariate)


Need to standardise these variables (centred on 0 with SD of 1) in order to model them together?

Need to account for the fact that stem density is measured at a quadrat level and stem height and diameter are measured at stem level.

```{r Sporobolus stem height diameter and density - Multivariate model}

```



# 3av - Sporobolus % species cover

Sporobolus % species cover
- Total cover ~ rest_status*YSR + Elevation + (1|Estuary) + (1|Site)
- beta distribution (proportional data with 2 categories - cover and non cover)

```{r Sporobolus species cover - model}
# when YSR has NA values, this model comes up with an error
M <- glmmTMB(sp_cover_prop ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)

# excluding restoration status (and therefore natural sites) from the model removes the error
M <- glmmTMB(sp_cover_prop ~ YSR + Elevation + Estuary + (1|YSR), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)
```


```{r sporobolus % cover univariate}
ggplot(spor_comm_H, aes(x = YSR, y = `Sp_cover_%`)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$`Sp_cover_%` ~ spor_comm_H$rest_status)
```


Other assumptions (??)


```{r Sporobolus species cover - plot}
ggplot(spor_comm_H, aes(x = YSR, y = sp_cover_prop)) +   
      geom_point(alpha = 0.5) +
    geom_smooth() + # meaningless
      theme_classic()
# older sites have consistently higher cover, compared with more varied cover at younger sites

spor_comm_H %>% subset(rest_status == "0") %>% 
  ggplot(., aes(x = Site, y=sp_cover_prop)) +
  geom_boxplot() +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sp_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus species cover (proportion)") +
  xlim(0,35) +
  ylim(0,1)
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sp_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,1)
# print at 700 x 789
```


# 3avi - Sporobous buds and flowers

Sporobolus buds and flowers - binary response variables

```{r Sporobolus buds and flowers - visualise distributions}
hist(spor_comm$Buds) # all zeroes - nothing to model
hist(spor_comm$Flowers) # almost all zeroes (only 5 quadrats with flowers) - not enough data to model
```

# 3avii - Sporobolus seeding

Sporobolus seeding - ordinal categorical response variable

```{r Sporobolus seeding - Data manipulation}
# make seeds into an ordinal variable
spor_comm$Seeds <- factor(spor_comm$Seeds, order = TRUE, levels = c("No", "Very few", "Few", "Some", "Lots"))
```

We can use the GLMMadaptive package to create a mixed model with an ordinal response variable.

Need to explore data to decide which family is most appropriate.

```{r Sporobolus seeding - model}
m_spor_seeds <- mixed_model(fixed = Seeds ~ YSR + Elevation + Estuary, random = ~ 1 | Site, 
                  data = spor_comm, family = binomial())
summary(m_spor_seeds)
```






# 3b - Sarcocornia



Sarcocornia reproduction

```{r Sarcocornia reproduction - Visualise distributions}
hist(sarc_comm$Buds) # no buds
hist(sarc_comm$Flowers) # there are occurrences of both flowers and no flowers

# make seeds a binary variable
sarc_comm <- sarc_comm %>% mutate(
  Seeds = case_when(
    Seeds == "Yes" ~ 1,
    Seeds == "No" ~ 0,
    Seeds == "Unknown" ~ NA,
    Seeds == "NA" ~ NA  
  )
)
hist(sarc_comm$Seeds) # there are occurrences of both seeds and no seeds

# are Flower and Seed presence correlated?
# see if there is a more formal way of testing this
sarc_comm$Seeds[sarc_comm$Flowers == 1] # there are 25 cases when Flowers are present. Seeds are present in 15 of these and no seeds in 8 of these.
sarc_comm$Seeds[sarc_comm$Flowers == 0] # there are 11 cases when Flowers are not present. Seeds are present in 5 of these and not present in 4 of these.
# therefore it seems like they aren't well correlated and can both be analysed
```

Need to decide whether we want to include these in a multivariate model together or have two separate models.

```{r Sarcocornia flowers - model}
m_sarc_flow <- glmmTMB(Flowers ~ YSR + Elevation + (1|Site), 
                  data = sarc_comm, family = binomial(), na.action = na.exclude)
# can't include estuary in the model as this species was only surveyed at Hunter
summary(m_sarc_flow)
```


```{r Sarcocornia seeds - model}
m_sarc_seeds <- glmmTMB(Seeds ~ YSR + Elevation + (1|Site), 
                  data = sarc_comm, family = binomial(), na.action = na.exclude)
# can't include estuary in the model as this species was only surveyed at Hunter
summary(m_sarc_seeds)
```




# 3c - Triglochin

Triglochin reproduction

```{r Triglochin reproduction - Visualise distributions}
hist(trig_comm$Buds) # there are occurrences of buds and no buds
hist(trig_comm$Flowers) # there are occurrences of both flowers and no flowers, but only about 2 occurrences of no flowers, which is not enough to analyse

# make seeds a binary variable
trig_comm <- trig_comm %>% mutate(
  Seeds = case_when(
    Seeds == "Yes" ~ 1,
    Seeds == "No" ~ 0,
    Seeds == "Unknown" ~ NA,
    Seeds == "NA" ~ NA  
  )
)
hist(trig_comm$Seeds) # there are occurrences of both seeds and no seeds

# are Bud and Seed presence correlated?
# see if there is a more formal way of testing this
trig_comm$Buds[trig_comm$Seeds == 1] # there are 12 cases when seeds are present. Buds are present in 7 of these and not present in 5 of these
trig_comm$Buds[trig_comm$Seeds == 0] # there are 21 cases when seeds are not present. Buds are present in 3 of these and not present in 18 of these.
trig_comm$Seeds[trig_comm$Buds == 1] # there are 10 cases when Buds are present. Seeds are present in 7 of these and not present in 3 of these
trig_comm$Seeds[trig_comm$Buds == 0] # there are 23 cases when Buds are not present. Seeds are present in 5 of these and not present in 18 of these.
# therefore I'm not sure if they're too correlated or not..
```




# 3d - pneumatophores




# 4. Multivariate models

Community traits

# 4a. Community composition


```{r Community composition}
# remove columns that only have zeroes
salt_comm_comp_H_res[,1:25] %>% colSums() # the last four columns are all zeroes
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:21,26:31)]

# only include species with at least 5 occurrences.
# check occurrences of each species
colSums(salt_comm_comp_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:4,8,10,12,22:27)] # subset for only those species

SaltComm <- mvabund(salt_comm_comp_H_res[,1:7])

# check out spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(salt_comm_comp_H_res[,1:7], horizontal = TRUE, las = 2, main = "Percent cover")
# large differences in variance, therefore check out mean-variance relationship

# check out mean-variance relationship
meanvar.plot(SaltComm)
# strong mean-variance relationship (close to linear but slightly curved like a negative quadratic function), therefore use a model that appropriately accounts for this

# roughly visualise data
plot(SaltComm ~ as.factor(salt_comm_comp_H_res$YSR))

# create model with interaction term
fit_cover <- manyany(SaltComm ~ YSR * Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.1), var.power = 1.1)
# if going with this, would also need to check the residuals vs fitted values plot and check for the optimum var.power value

plot(fit_cover)

# test for the best value of the var.power element
vpwrs <- seq(1.1,1.9, by =.1)
aic_vp <- rep(NA, length(vpwrs))
for(i in 1:length(vpwrs)){ 
  fit_vp <- manyany(SaltComm ~ YSR * Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=vpwrs[i]), var.power=vpwrs[i])
  aic_vp[i] <- fit_vp$AICsum
}
# this is not working because there is no fit_vp$AICsum
# how do I calculate AIC? formula is AIC = 2K – 2ln(L) where K = # model parameters and ln(L) = log likelihood but there are a lot of log likelihood terms and I'm not sure if each species counts as a parameter?

# test importance of YSR by comparing it to a model without YSR
fit_cover_null <- manyany(SaltComm ~ Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.1), var.power = 1.1) # make a model that's the same as the desired model but without YSR term
anova(fit_cover_null, fit_cover)

# test model
# test importance of restoration 
mod_rest <- #insert best model here
mod_null <- #same as best model without the YSR term
anova(mod_null, mod_rest)
```

Species traits

# 4b. Stem density

```{r Stem density}
# note, currently: STEM DENSITY MULTIPLIED OUT - NO OFFSETS
# also can't currently included species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# transform this to wide format with a column for each species' stem density. Not sure how this works with offsets. Let's start without and then figure out there
stem_dens_wide <- stem_dens_unique %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = total_stems)

# fill NA values with zeroes
stem_dens_wide[,11:35] <- stem_dens_wide[,11:35] %>% replace(is.na(.), 0)

# subset for only Hunter and only restored
stem_dens_wide_H_res <- stem_dens_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes (i.e. no observations of that species anywhere)
stem_dens_wide_H_res[,11:35] %>% colSums() # the last four columns are all zeroes
stem_dens_wide_H_res <- stem_dens_wide_H_res[,1:31]

# now, we are only interested in species that have at least 5 total observations (otherwise there are insufficient data to analyse them)
# calculate number of non-zero elements in each column
colSums(stem_dens_wide_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
stem_dens_wide_H_res <- stem_dens_wide_H_res[,c(1:14,18,20,22)] # subset for only those species

# set up mvabund with stem density columns - these are 11-17
stemdens_mvabund <- mvabund(stem_dens_wide_H_res[,11:17])

# look at spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(stem_dens_wide_H_res[,11:17], horizontal = TRUE, las = 2, main = "Stem density")

# look at mean-variance relationship
meanvar.plot(stemdens_mvabund) # strong linear relationship

# explore visually
plot(stemdens_mvabund ~ as.factor(stem_dens_wide_H_res$YSR), cex.axis = 0.8, cex = 0.8)

# count data so model with poisson or negative binomial distribution
stemdens_mod1 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpecies, data = stem_dens_wide_H_res, family = "poisson")

# check model assumptions
plot(stemdens_mod1) # NOT OK!! there is a big trend...

# try a negative binomial model
stemdens_mod2 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpecies, data = stem_dens_wide_H_res) # default family is negative binomial

# check model assumptions
plot(stemdens_mod2) # zero inflated but much much better!

# try with DomSpeciesSimp
stemdens_mod3 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpeciesSimp, data = stem_dens_wide_H_res)

plot(stemdens_mod3) # fine
meanvar.plot(stemdens_mod3)

# try with DomSpeciesSuperSimp
stemdens_mod4 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp, data = stem_dens_wide_H_res)

plot(stemdens_mod4) # one outlier

# therefore try mod3 (residuals plot looks fine and only has species we can statistically analyse)

# use model to test hypotheses
anova(stemdens_mod3)

# get more specifics
anova(stemdens_mod3, p.uni = "adjusted")


```

```{r Stem density again - long format with one species per row?}
# can we just use Species as a predictor variable? and then we'd easily be able to include the offsets for quadrat size? don't remember the reason why we hadn't done this earlier (it might not be ok)
# yes we can, but need to account for covariance between species observations for the same quadrat:

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# only Hunter and restored...
stem_dens_unique_H_res <- stem_dens_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# determine which species have at least 5 values
Stem_dens_count <-
  stem_dens_unique_H_res %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(Stems)))
print(Stem_dens_count, n = 21)
# retain Aster, Bolboschoenus, Phragmites, Pneumatophores, Sarcocornia, Sporobolus, Triglochin

stem_dens_unique_H_res <- stem_dens_unique_H_res %>% 
  subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))

# remove NAs
stem_dens_unique_H_res <- stem_dens_unique_H_res %>% subset(!is.na(Stems))

# use glmmTMB

M1 <- glmmTMB(Stems ~ YSR * Elevation * Species + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2), family = "nbinom2", data = stem_dens_unique_H_res)
# do we need to add + (1|Combo) when that's already involved in the covariate structure?
# also what is d?

plot(predict(M1), residuals(M1)) # looks like a negative binomial spread! more spread in negative values and a couple extreme values
resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1)) # scaled residuals plot - looks ok?
plotQQunif(M1) # looks great


summary(M1)



# try adding sp_prop
M2 <- glmmTMB(Stems ~ YSR * Elevation * Species + DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2), family = "nbinom2", data = stem_dens_unique_H_res)
# do we need to add + (1|Combo) when that's already involved in the covariate structure?
# also what is d?

plot(predict(M2), residuals(M2)) # looks great and less uneven than previous
resid <- residuals(simulateResiduals(M2), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M2)) # looks good
plotQQunif(M2) # looks great


summary(M2)

```

```{r Stem density multivariate - plot}
# this is not a good plot, but not sure how to plot.
ggplot(data = stem_dens_unique_H_res, aes(y = total_stems, x = YSR, fill = Species)) +
  geom_smooth() +
  geom_point()

```


# 4c. Reproduction

```{r Reproduction (presence/absence)}
# note: can't currently include species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just reproduction data
reprod <- salt[,c(5,6,7,11,16:18,24,25,28,30:32,35,36)]

# recode seeds as a binary presence/absence variable
reprod$Seeds %>% unique() # view unique values
reprod <- reprod %>% mutate(Seeds = case_when(
  Seeds == "No" ~ 0,
  Seeds == "Yes" ~ 1,
  Seeds == "Lots" ~ 1,
  Seeds == "Some" ~ 1,
  Seeds == "Few" ~ 1,
  Seeds == "Very few" ~ 1,
  Seeds == "NA" ~ NA
))

# remove replicates from measuring multiple stems for each species per quadrat (but only one reproduction value)
# first create a column for every unique site/quadrat/species combination
reprod$unique <- factor(interaction(reprod$Combo, reprod$Species, sep = ":"))
reprod_unique <- reprod %>% distinct(unique, .keep_all = TRUE) 

# subset for only restored and Hunter
reprod_unique_H_res <- reprod_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# count number of non-na values for each species (can only analyse species with at least 5 values)
Reprod_count <-
  reprod_unique_H_res %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(Seeds))) # can choose whatever reproduction type here as when one was recorded, all were.
print(Reprod_count, n = 21)

# species with enough data are: aster, bolboschoenus, phragmites, sarcocornia, sporobolus, triglochin
reprod_unique_H_res <- reprod_unique_H_res %>% subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))

# make data longer with one row for reproduction type and another for presence/absence
reprod_long <- reprod_unique_H_res %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# transform this to wide format with a column for each species' reproduction. 
reprod_wide <- reprod_long %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, YSR, rest_status, reprod_type, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = Reproduction)

# set up mvabund with reproduction columns - these are 12-17
reprod_mvabund <- mvabund(reprod_wide[,12:17])

# look at spread of data - boxplots are not ideal for binary data...
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(reprod_wide[,12:17], horizontal = TRUE, las = 2, main = "Reproduction")

# explore visually - hard to interpret with binary data
plot(reprod_mvabund ~ as.factor(reprod_wide$YSR), cex.axis = 0.8, cex = 0.8)

# binary data so model with binomial distribution

reprod_mod1 <- manyglm(reprod_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp + reprod_type, data = reprod_wide, family = "binomial", na.rm = TRUE)

# This is coming up with errors, even though all categorical variables have multiple levels. Coming up with fatal errors when I experiment removing variables.

# maybe because Bolboschoenus only has reprod_type = seeds? and other uncommon species probably have similar problems (Aster and Phragmites)

# therefore try with only Sarcocornoia, Sporobolus and Triglochin
reprod_unique_H_res2 <- reprod_unique_H_res %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin"))

# make data longer with one row for reproduction type and another for presence/absence
reprod2_long <- reprod_unique_H_res2 %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# transform this to wide format with a column for each species' reproduction. 
reprod2_wide <- reprod2_long %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, YSR, rest_status, reprod_type, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = Reproduction)

# set up mvabund with reproduction columns - these are 12-14
reprod2_mvabund <- mvabund(reprod2_wide[,12:14])

reprod_mod2 <- manyglm(reprod2_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp + reprod_type, data = reprod2_wide, family = "binomial", na.rm = TRUE)




# check model assumptions
plot(reprod_mod2) 

# use model to test hypotheses
anova(reprod_mod2)

# get more specifics
anova(reprod_mod2, p.uni = "adjusted")
```


```{r Reproduction - try long data approach in glmmTMB}
# remove NAs
reprod_long <- reprod_long %>% subset(!is.na(Reproduction))

# not sure this is going to work as we have two grouping variables, Species and reprod_type
M1 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + DomSpeciesSuperSimp + reprod_type + rr(Species+0|Combo, d = 2), family = "binomial", data = reprod_long)
# do we need to add + (1|Combo) when that's already involved in the covariate structure?
# also what is d?
# warning message

# check model assumptions
residuals(M1)
predict(M1)
plot(predict(M1), residuals(M1))

resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1)) # scaled residuals plot - there are three outliers with large negative predicted values. are these ok? how do I know which they are and if I should remove them?
resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1), ylim = c(-20,20)) # looks pretty good without the outliers.
plotQQunif(M1) # looks great

summary(M1)




# explore - only seeds
seeds <- reprod_long %>% subset(reprod_type == "Seeds")

M2 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + DomSpeciesSuperSimp + rr(Species+0|Combo, d = 2), family = "binomial", data = seeds)
# warnings
```


Stem traits

# 4d. Stem height and diameter

```{r Stem height and diameter - prep data}
# we can model these continuous traits together using a multivariate linear mixed model.

# check number of non-NA rows for each Species (so we can exclude species with <5 values - insufficient data to analyse)
Stem_ht_count <- 
  salt_H_rest %>% 
  group_by(Species, Quadrat.f) %>% # should only count 1 per quadrat.. independent observations. therefore grouping by Quadrat.f as well.
  summarise(total_non_na = sum(!is.na(Stem_ht_mm)))
print(Stem_ht_count, n = 21)

Stem_ht_quadrats <-
  Stem_ht_count %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(total_non_na)))
print(Stem_ht_quadrats, n = 21)

# species to retain (at least 5 quadrats): Aster, Bolboschoenus, Phragmites, Pneumatophores, Sarcocornia, Sporobolus, Triglochin
# also exclude Pneumatophores as they only exist at one level of YSR so cause issues in the model.
# stem diameters were measured at the same time as stem heights so these would also be the suitable species for stem diameter.

salt_H_rest_stems <- salt_H_rest %>% subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))


# visualise relationships between traits for each species
scatterplotMatrix(~ Stem_ht_mm + Stem_dia_mm | Species, data=salt_H_rest_stems,smooth=FALSE,regLine=FALSE,ellipse=TRUE, by.groups=TRUE,diagonal=FALSE,legend=list(coords="bottomleft")) # this does not need to be a matrix as there are only two factors! Interesting to look at though.

# visualise boxplots for each factor
boxplot(salt_H_rest_stems$Stem_ht_mm ~ salt_H_rest_stems$Species)
boxplot(salt_H_rest_stems$Stem_dia_mm ~ salt_H_rest_stems$Species)

# recode characters as factors?
salt_H_rest_stems$DomSpeciesSimp <- as.factor(salt_H_rest_stems$DomSpeciesSimp)
salt_H_rest_stems$DomSpeciesSuperSimp <- as.factor(salt_H_rest_stems$DomSpeciesSuperSimp)
salt_H_rest_stems$Species <- as.factor(salt_H_rest_stems$Species)
```



```{r Stem diameter - try models and explore assumptions}
# remove NAs
salt_H_rest_stems_dia <- salt_H_rest_stems %>% subset(!is.na(Stem_dia_mm))

# explore distribution
hist(salt_H_rest_stems_dia$Stem_dia_mm) # highly right skewed
hist(log(salt_H_rest_stems_dia$Stem_dia_mm)) # better
hist(sqrt(salt_H_rest_stems_dia$Stem_dia_mm)) # better but worse than log

# explore relationship between dependent and predictor variables
plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$YSR) # not clearly non-linear
plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$Elevation) # not clearly non-linear

M1 <- glmmTMB(Stem_dia_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M1), residuals(M1)) # not that even
plotQQunif(M1) # ok?

# log model
M2 <- glmmTMB(log(Stem_dia_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M2), residuals(M2)) # not that even
plotQQunif(M2) # not great

# sqrt model
M3 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M3), residuals(M3)) # looks weird with two distinct clumps. but no trend per se and fairly equal distribution either side of zero so I think it's good
plotQQunif(M3) # ok?

# therefore use M3
summary(M3)
# YSR is not significant except in interaction with both elevation and speciesBolboschoenus
```

```{r Stem diameter - interpreting effects}
plot_model(M3, type = "pred", terms = c("YSR", "Species", "Elevation"))
plot_model(M3, type = "int", terms = c("Species", "YSR", "Elevation"))


# code modified from https://osf.io/28mpv

# Describe the interaction effect based on estimated marginal means and errors
# get and plot estimated marginal means, standard errors, and confidence intervals.

# Get estimated marginal means and errors
emm = as.data.frame(emmeans(M3, specs=c("YSR", "Species")))

# Prepare plot with stimated marginal means and CIs
mm = ggplot(data=salt_H_rest_stems_factor, aes(x=YSR, y=Stem_dia_mm, fill=Species)) + 
  #ylim(ylim) +
  geom_line(data=emm, linewidth=1.3, linetype=1,
            aes(x=YSR, y=emmean, group=Species, colour=Species)) + 
  geom_point(data=emm, size=3, shape=18, 
             aes(x=YSR, y=emmean, group=Species, colour=Species)) + 
  geom_errorbar(data=emm, size=1, width=.1,
                aes(x=YSR, y=emmean, group=Species, colour=Species, ymin=lower.CL, ymax=upper.CL)) +
  scale_colour_brewer(palette="Dark2") + scale_fill_brewer(palette="Dark2") + 
  ggtitle("Model estimated \n marginal means ") + 
  theme_bw() + 
  theme(plot.title=element_text(hjust=0.5, size=27), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        legend.position=c(.2,.85),
        legend.title=element_text(size=25), 
        legend.text=element_text(size=25),
        axis.title.x=element_text(size=27),
        axis.text.x=element_text(size=27),
        axis.title.y=element_text(size=25),
        axis.text.y=element_text(size=25),
        panel.border = element_blank(),
        axis.line.x = element_line(linewidth = 0.5, linetype = "solid", colour = "black"),
        axis.line.y = element_line(linewidth = 0.5, linetype = "solid", colour = "black"))
mm
```


```{r Stem height - try models and explore assumptions}
# remove NAs
salt_H_rest_stems_ht <- salt_H_rest_stems %>% subset(!is.na(Stem_ht_mm))

# explore distribution
hist(salt_H_rest_stems_ht$Stem_ht_mm) # highly right skewed

# explore relationship between dependent and predictor variables
plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$YSR) # not clearly non-linear
plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$Elevation) # not clearly non-linear

M0 <- glmmTMB(Stem_ht_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# iteration limit warning - try changing iteration limit
M1 <- glmmTMB(Stem_ht_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)), data = salt_H_rest_stems_ht)
# now have another error..

# try with no YSR/species interaction
M1 <- glmmTMB(Stem_ht_mm ~ Species + YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# no error - therefore a problem with Species again

plot(predict(M0), residuals(M0)) # not good
plotQQunif(M0) # not good
# therefore the non-transformed model doesn't meet assumptions anyway, so see if transformed models are better for assumptions

# log model
M2 <- glmmTMB(log(Stem_ht_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# no error with log model

plot(predict(M2), residuals(M2)) # decent but some more extreme lower values, probably ok though
plotQQunif(M2) # pretty good

# sqrt model
M3 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M3), residuals(M3)) # ok but more clumped than log
plotQQunif(M3) # pretty good

# therefore use M2
summary(M2)

# again no significance for YSR
```










--------------

```{r Elevation rescaling makes a difference?}
salt_elev_test <- salt_H_rest_stems[,c(5:7,11,20,25,30:33,35,36)]

M1 <- lmer(sqrt(Stem_dia_mm) ~ Species * YSR * Elevation + DomSpeciesSimp + sp_prop + (1|Quadrat.f), data = salt_elev_test, na.action = na.exclude)

summary(M1)

# rescale elevation
salt_elev_test <- salt_elev_test %>% 
  mutate(Elev_rescale = scale(Elevation, center = TRUE, scale = TRUE))

M2 <- lmer(sqrt(Stem_dia_mm) ~ Species * YSR * Elev_rescale + DomSpeciesSimp + sp_prop + (1|Quadrat.f), data = salt_elev_test, na.action = na.exclude)

summary(M2)
```




The following model formats are suggested by Jamil et al. (2012) for a simple model with one trait "z" and one fixed environmental vaiable "x":

M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link=“logit”), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link=“logit”), data)

However, "y" is species presence/absence or species abundance, which is not the focus of my analysis. I want to shift the focus to the trait value and have species proportions as a driver for that.

The first model includes the interaction between trait and environment and the second model is run without the interaction term so that we can compare the two models using an ANOVA to test the trait-environment interaction:

ANOVA(M0,M1)

```{r Test - log canopy height and elevation}
M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link="logit"), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link="logit"), data)

ANOVA(M0,M1)
```

