---
title: "Saltmarsh mixed modelling"
author: "Dana Lanceman"
date: "2023-10-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R script tests different types of modelling that can be applied to our saltmarsh functional traits dataset.

# 1. Set up


```{r Load packages}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")
#install.packages("ggeffects")
#install.packages("emmeans")
#install.packages("robustlmm")
#install.packages("mvabund")
#install.packages("plyr")
#install.packages("ecostats")
#install.packages("viridis")
#install.packages("betareg")
#install.packages("ggpubr")
#install.packages("countreg", repos="http://R-Forge.R-project.org", type = "binary")
#install.packages("statmod")
#install.packages("lmerTest")
#install.packages("sjPlot")
#install.packages("DHARMa")
#install.packages("MCMCglmm")
#install.packages("ggbreak") 

library(plyr)
library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(bbmle)
library(GLMMadaptive)
library(ggeffects)
library(emmeans)
library(robustlmm)
library(mvabund)
require(statmod)
library(ecostats)
library(viridis)
library(betareg)
library(ggpubr)
library(countreg)
library(lmerTest)
library(sjPlot)
library(DHARMa)
library(MCMCglmm)
library(ggbreak) 
require(tweedie)
library(glmmTMB)

#install.packages("Matrix", version = "1.6.1.1")
#library(Matrix)
#install.packages("TMB")
#library(TMB)
```

```{r Get data}
# set working directory
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

# input saltmarsh data
salt <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Saltmarsh") %>% 
  arrange(Date, Time) %>% 
  mutate(Quadrat_area = Quad_length_cm^2, # add a column for quadrat area to use as an offset
    total_stems = round(Stems * 10000/Quad_length_cm^2), # add column for total stem count per 1m2 for each species to standardise stem counts for plots. Round makes it an integer.
         Buds = case_when(  # reassign Buds as a numeric variable
           Buds == "Yes" ~ 1,
           Buds == "No" ~ 0,
           Buds == "Unknown" ~ NA,
           Buds == "NA" ~ NA
         ),
         Flowers = case_when(  # reassign Flowers as a numeric variable
           Flowers == "Yes" ~ 1,
           Flowers == "No" ~ 0,
           Flowers == "Unknown" ~ NA,
           Flowers == "NA" ~ NA
         ),
        Seeds = case_when( # standardise Seeds wording
          Seeds == "Yes" ~ "Yes",
          Seeds == "Seeds" ~ "Yes",
          Seeds == "No" ~ "No",
          Seeds == "Lots" ~ "Lots",
          Seeds == "Some" ~ "Some",
          Seeds == "some" ~ "Some",
          Seeds == "Few" ~ "Few",
          Seeds == "Very few" ~ "Very few",
          Seeds == "NA" ~ NA,
          Seeds == "Unknown" ~ NA
          ),
         rest_status = case_when(
           Site == "AE" ~ as.numeric("1"),
           Site == "HS" ~ as.numeric("1"),
           Site == "TA" ~ as.numeric("1"),
           Site == "TB" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           .default = as.numeric("0"), # add a column for restoration status where 1 = restored and 0 = natural
         ),
         rest_year = case_when(
           Site == "AE" ~ as.numeric("2017"),
           Site == "HS" ~ as.numeric("2011"),
           Site == "TA" ~ as.numeric("2007"),
           Site == "TB" ~ as.numeric("2012"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "AE" ~ as.numeric("6"),
           Site == "HS" ~ as.numeric("12"),
           Site == "TA" ~ as.numeric("16"),
           Site == "TB" ~ as.numeric("11"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9") #,
           #Site == "AI" ~ as.numeric("NA"), # figure out how best to include natural sites in model when they don't have a restoration age
           #Site == "SI" ~ as.numeric("NA"),
           #Site == "VSR" ~ as.numeric("NA"),
           #Site == "MWS" ~ as.numeric("NA"),
         ))  # add a column for years since restoration
# double check with Will years for each

# Create a column for the Dominant Species in each quadrat
salt <- salt %>%
  group_by(Combo) %>% 
  mutate(
    MaxSpeciesCover = max(`Sp_cover_%`),
    DomSpecies = ifelse(100 - `Total_cover_%` > MaxSpeciesCover, "unvegetated", 
                        paste(unique(Species[`Sp_cover_%` == MaxSpeciesCover]), collapse = ", "))) %>% # Calculate the species with maximum cover for each Quadrat, and list multiple if it's a tie
  ungroup() %>%
  dplyr::select(-MaxSpeciesCover) # Remove MaxSpeciesCover colummn


# For quadrats that have ended up listing two species as jointly dominant, manually edit these to include whichever of these species is "bulkier" as dominant
# i.e. Juncus > Triglochin, Sarcocornia > GSG, Juncus > Sporobolus

salt <- salt %>% mutate(
  DomSpecies = case_when(
    DomSpecies == "Juncus_kraussii, Sporobolus" ~ "Juncus_kraussii",
    DomSpecies == "Juncus_kraussii, Triglochin" ~ "Juncus_kraussii",
    DomSpecies == "GSG, Sarcocornia" ~ "Sarcocornia",
    .default = DomSpecies
  )
)

# create a column for proportion cover of each species (species cover/overall cover)
salt <- salt %>% mutate(sp_prop = `Sp_cover_%`/`Total_cover_%`)

# reassign Quadrat as an explictly nested variable within Site
salt$Quadrat <- as.character(salt$Quadrat)
salt$Quadrat.f <- factor(interaction(salt$Site, salt$Quadrat, sep = ":"))
salt$Quadrat.f <- as.character(salt$Quadrat.f)


# load saltmarsh community composition data
salt_comm_comp <- read_excel("Data/salt_comm_comp.xlsx", sheet = "alldata")
salt_comm_comp$YSR <- as.numeric(salt_comm_comp$YSR)
```


```{r Create species-specific dataframes}
spor <- salt %>%
  filter(Species == "Sporobolus")

sarc <- salt %>%
  filter(Species == "Sarcocornia")

trig <- salt %>%
  filter(Species == "Triglochin")

pneu <- salt %>%
  filter(Species == "Pneumatophores")

```


Outlier removal - these were checked in the Saltmarsh_fn_traits script.

```{r Remove unrealistic outliers}
salt[443,20] <- NA # remove triglochin measurement with unrealistic stem diameter >4mm
salt[c(738:744), 20] <- NA # remove triglochin measurements with unrealistic stem diameter >4mm
salt[802,19] <- NA # remove triglochin measurement with unrealistic stem height 556mm
salt[1271,19] <- NA # remove triglochin measurement with unrealistic stem height 860mm
salt[112,20] <- NA # remove pneumatophore measurement with unrealistic diameter 1mm
salt[c(862,917),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm

trig[121,19] <- NA # this value had stem height of 556mm
trig[240,19] <- NA # this value had stem height of 860mm
trig[c(98:104),20] <- NA # these had stem diameters > 4mm
trig[78,20] <- NA # stem diameter was > 4mm
pneu[40,20] <- NA # this had stem diameter of 1mm
spor[c(283,313),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm
```


Data transformations - need to check whether these are required for these models. If so, need to check across-species assumptions.
```{r Data transformations}
# overall saltmarsh
salt$ln.canopy.ht <- log(salt$Canopy_ht_cm)

# sporobolus
spor$ln.stem.ht <- log(spor$Stem_ht_mm)
spor$sq.stem.ht <- sqrt(spor$Stem_ht_mm)
spor$ln.stem.dia <- log(spor$Stem_dia_mm + 0.01)
spor$sq.stem.dia <- sqrt(spor$Stem_dia_mm)
spor$sq.stem.dens <- sqrt(spor$total_stems)

# sarcocornia
sarc$sq.stem.dia <- sqrt(sarc$Stem_dia_mm)
sarc$sq.stem.dens <- sqrt(sarc$total_stems)

# triglochin
trig$ln.sp.cover <- log(trig$`Sp_cover_%` + 0.01)
trig$sq.stem.dia <- sqrt(trig$Stem_dia_mm)
trig$ln.stem.dens <- log(trig$total_stems)

# pneumatophores
pneu$sq.sp.cover <- sqrt(pneu$`Sp_cover_%`)
pneu$sq.stem.dens <- sqrt(pneu$total_stems)
```

Check distribution of explanatory variables
```{r Check distribution of explanatory variables}
hist(salt$YSR)
hist(log(salt$YSR))
```


Can be useful to rescale explanatory variables so they have a constant mean of 0 and standard deviation of 1.
Delete this unless any models don't converge or to compare variable importance.
```{r Rescale/standardise explanatory variables}
#salt$Elevation <- scale(salt$Elevation, center = TRUE, scale = TRUE)
#spor$Elevation <- scale(spor$Elevation, center = TRUE, scale = TRUE)
#sarc$Elevation <- scale(sarc$Elevation, center = TRUE, scale = TRUE)
#trig$Elevation <- scale(trig$Elevation, center = TRUE, scale = TRUE)
#pneu$Elevation <- scale(pneu$Elevation, center = TRUE, scale = TRUE)

```


Duplicate deletion - for community-level variables, there are several rows for each quadrat that are all identical. We need to remove these duplicate rows

```{r Duplicate deletion - community-level variables}
salt_comm <- salt %>% distinct(Combo, .keep_all = TRUE) 
salt_comm <- salt_comm[,-c(11:20,22,26,27,32,34)] # remove irrelevant rows
# turn total cover into a proportion between 0 and 1 instead of between 0 and 100
salt_comm <- salt_comm %>% mutate(total_cover_prop = `Total_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.

spor_comm <- spor %>% distinct(Combo, .keep_all = TRUE) 
spor_comm <- spor_comm[,-c(19,20,34:37)] # remove irrelevant rows

sarc_comm <- sarc %>% distinct(Combo, .keep_all = TRUE) 
sarc_comm <- sarc_comm[,-c(19,20,34)] # remove irrelevant rows

trig_comm <- trig %>% distinct(Combo, .keep_all = TRUE) 
trig_comm <- trig_comm[,-c(19,20,35)] # remove irrelevant rows

pneu_comm <- pneu %>% distinct(Combo, .keep_all = TRUE) 
pneu_comm <- pneu_comm[,-c(19,20)] # remove irrelevant rows
  
```

```{r New variables}
# turn species cover into a proportion between 0 and 1 instead of between 0 and 100
spor_comm <- spor_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.
sarc_comm <- sarc_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
trig_comm <- trig_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)

# make a simplified DomSpecies variable where rare DomSpecies are grouped together in class "other"
salt_comm <- salt_comm %>% mutate(DomSpeciesSimp = case_when(
  DomSpecies == "Sporobolus" ~ "Sporobolus",
  DomSpecies == "Sarcocornia" ~ "Sarcocornia",
  DomSpecies == "Bolboschoenus" ~ "Bolboschoenus",
  DomSpecies == "Phragmites" ~ "Phragmites",
  DomSpecies == "unvegetated" ~ "Other",
  DomSpecies == "Juncus_kraussii" ~ "Other",
  DomSpecies == "Aster" ~ "Other",
  DomSpecies == "Triglochin" ~ "Other",
  DomSpecies == "Suaeda" ~ "Other",
  DomSpecies == "Juncus_sp1" ~ "Other",
  DomSpecies == "Juncus_sp2" ~ "Other"
))

salt <- salt %>% mutate(DomSpeciesSimp = case_when(
  DomSpecies == "Sporobolus" ~ "Sporobolus",
  DomSpecies == "Sarcocornia" ~ "Sarcocornia",
  DomSpecies == "Bolboschoenus" ~ "Bolboschoenus",
  DomSpecies == "Phragmites" ~ "Phragmites",
  DomSpecies == "unvegetated" ~ "Other",
  DomSpecies == "Juncus_kraussii" ~ "Other",
  DomSpecies == "Aster" ~ "Other",
  DomSpecies == "Triglochin" ~ "Other",
  DomSpecies == "Suaeda" ~ "Other",
  DomSpecies == "Juncus_sp1" ~ "Other",
  DomSpecies == "Juncus_sp2" ~ "Other"
))


# try even simpler with DomSpeciesSuperSimp - only Sporobolus, Sarcocornia or Other
salt_comm <- salt_comm %>% mutate(DomSpeciesSuperSimp = case_when(
  DomSpeciesSimp == "Sporobolus" ~ "Sporobolus",
  DomSpeciesSimp == "Sarcocornia" ~ "Sarcocornia",
  DomSpeciesSimp == "Bolboschoenus" ~ "Other",
  DomSpeciesSimp == "Phragmites" ~ "Other",
  DomSpeciesSimp == "Other" ~ "Other"
))

salt <- salt %>% mutate(DomSpeciesSuperSimp = case_when(
  DomSpeciesSimp == "Sporobolus" ~ "Sporobolus",
  DomSpeciesSimp == "Sarcocornia" ~ "Sarcocornia",
  DomSpeciesSimp == "Bolboschoenus" ~ "Other",
  DomSpeciesSimp == "Phragmites" ~ "Other",
  DomSpeciesSimp == "Other" ~ "Other"
))

```


Create datasets for just restored data and just natural data
```{r Subsetting dataframes}
salt_H <- salt %>% subset(Estuary == "Hunter")
spor_H <- spor %>% subset(Estuary == "Hunter")
sarc_H <- sarc %>% subset(Estuary == "Hunter")
trig_H <- trig %>% subset(Estuary == "Hunter")
pneu_H <- pneu %>% subset(Estuary == "Hunter")

salt_H_rest <- salt_H %>% subset(rest_status == 1)
spor_H_rest <- spor_H %>% subset(rest_status == 1)
sarc_H_rest <- sarc_H %>% subset(rest_status == 1)
trig_H_rest <- trig_H %>% subset(rest_status == 1)
pneu_H_rest <- pneu_H %>% subset(rest_status == 1)

salt_H_nat <- salt_H %>% subset(rest_status == 0)
spor_H_nat <- spor_H %>% subset(rest_status == 0)
sarc_H_nat <- sarc_H %>% subset(rest_status == 0)
trig_H_nat <- trig_H %>% subset(rest_status == 0)
pneu_H_nat <- pneu_H %>% subset(rest_status == 0)

salt_comm_rest <- salt_comm %>% subset(salt_comm$rest_status == 1)
salt_comm_nat <- salt_comm %>% subset(salt_comm$rest_status == 0)
salt_comm_rest_H <- salt_comm_rest %>% subset(salt_comm_rest$Estuary == "Hunter")
salt_comm_nat_H <- salt_comm_nat %>% subset(salt_comm_nat$Estuary == "Hunter")
salt_comm_H <- salt_comm %>% subset(salt_comm$Estuary == "Hunter")

spor_comm_H <- spor_comm %>% subset(Estuary == "Hunter")
sarc_comm_H <- sarc_comm %>% subset(Estuary == "Hunter")
trig_comm_H <- trig_comm %>% subset(Estuary == "Hunter")
pneu_comm_H <- pneu_comm %>% subset(Estuary == "Hunter")

# Hunter only, restored only 
spor_comm_H_res <- spor_comm_H %>% subset(rest_status == "1")
sarc_comm_H_res <- sarc_comm_H %>% subset(rest_status == "1")
trig_comm_H_res <- trig_comm_H %>% subset(rest_status == "1")
pneu_comm_H_res <- pneu_comm_H %>% subset(rest_status == "1")

# Hunter only, natural only 
spor_comm_H_nat <- spor_comm_H %>% subset(rest_status == "0")
sarc_comm_H_nat <- sarc_comm_H %>% subset(rest_status == "0")
trig_comm_H_nat <- trig_comm_H %>% subset(rest_status == "0")
pneu_comm_H_nat <- pneu_comm_H %>% subset(rest_status == "0")

# community composition
salt_comm_comp_H <- salt_comm_comp %>% subset(Estuary == "Hunter")
salt_comm_comp_H_res <- salt_comm_comp_H %>% subset(rest_status == "1")
salt_comm_comp_H_nat <- salt_comm_comp_H %>% subset(rest_status == "0")
```

Before running models, we need to make sure none of our dependent variables are strongly correlated. If so, we cannot include all variables in analysis.

Our dependent variables of interest are:
- 	Community composition (multivariate) (can't really test for relationships here as it's a matrix)
-   Total cover (univariate)
-   Stem density
-   Stem diameter
-   Stem height
-   Reproduction (presence/absence) (can't really test for relationships here as they're binary variables?)

Exclude variables if their correlation coefficient is >0.8 (is this correct? and what can I cite for this?)

```{r Test for correlations between dependent variables}
# correlation matrix of correlation coefficients
cor(salt[,c(9,10,19,20,27)], use = "pairwise.complete.obs") # all correlation coefficients are >0.8, therefore retain all variables

# plot correlations between variables
# plot a bunch of correlation plots at once
salt_numeric <- salt[,c(9,10,19,20,27)]
plot(salt_numeric)
```

```{r Summary stats}
# number of quadrat observations for each species 

# hunter estuary
colSums(salt_comm_comp_H != 0)

# maroochy estuary
salt_comm_comp_M <- salt_comm_comp %>% subset(Estuary == "Maroochy")
colSums(salt_comm_comp_M != 0)
```


# A. Hunter only

# 2. Simple trial models - community level

First, let's create univariate models for our community-level variables (tallest canopy height, total cover and burrows).

# 2a - Total cover 

Total cover
- Total cover ~ YSR + DomSpecies + Elevation 
- beta distribution (proportional data with 2 categories - cover and non cover)
- not a mixed model

```{r Total cover - Plot relationships between variables}
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$Elevation) # possibly non-linear

# plot what % covers we have at each YSR for each dominant species

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = total_cover_prop, group = DomSpeciesSuperSimp)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp)


# plot what Elevations are at each YSR for each dominant species

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = Elevation, group = DomSpeciesSuperSimp)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp) # these variables are correlated..

# general relationship between Elevation and YSR
plot(salt_comm_rest_H$Elevation ~ salt_comm_rest_H$YSR) # look less correlated when all data are combined

```

```{r Total cover - model}
# use glm with tweedie distrubution as tweedie is similar to beta distrubtion
M <- glm(total_cover_prop ~ poly(YSR,2) * DomSpecies * poly(Elevation,2), data = salt_comm_rest_H, family = tweedie(var.power=1.5, link = 0), na.action = na.exclude)
plot(M) # does not look good. regardless of var.power value. or whether YSR and elevation are included as polynomial or linear variables. or whether interactions are included or not.

# try with DomSpeciesSuperSimp and not interacting
M1 <- glm(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, family = tweedie(var.power=1.5, link = 0), na.action = na.exclude)
plot(M1)
# still not good

# try beta regression
M2 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) * DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
# error here - because of DomSpecies interaction

# beta regression with DomSpecies non-interacting
M3 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M3) # crazy large cooks distance for 7, 42 and 60. This is because these plots have unusual DomSpecies. Need to discuss.

# beta regression without DomSpecies
M4 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M4) # plots generally look good, except some relatively large cook's distance values (point 7 and 69) - not sure why 69 is large as it has the same total cover as other values. 7 has extremely low total cover but it's realistic.
summary(M4)

# check whether exclusion of influential points changes parameter estimates
M5 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H[-c(7,69),], link = "logit", na.action = na.exclude)
plot(M5) 
summary(M5)
# not massive differences in parameter estimates. Therefore hopefully OK to retain more influential values and use M4



# try DomSpeciesSimp instead that clumps rare DomSpecies into "Other"
# DomSpecies interaction is still not ok

# beta regression with DomSpecies non-interacting
M8 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M8) # now point 41 has very high cook's distnace and 7 and 69 are still high...

# try DomSpeciesSuperSimp
M9 <- betareg(total_cover_prop ~ poly(cbind(YSR,Elevation),2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M9) # still large cook's distance at 7, 41 and 69 but a bit better than before
summary(M9)
# after adjusting p-values by multiplying by 2, it's pretty similar to M4 - no significance, except in DomSpeciesSuperSimpSporobolus - more sporobolus means more cover. (highly significant)

# residuals plots comprehensive
plot(M9, which = 1:6,
  caption = c("Residuals vs indices of obs.", "Cook's distance plot",
    "Generalized leverage vs predicted values", "Residuals vs linear predictor", 
    "Half-normal plot of residuals", "Predicted vs observed values"),
    sub.caption = paste(deparse(M9$call), collapse = "\n"), main = "", 
    ask = prod(par("mfcol")) < length(which) && dev.interactive(), type = "sweighted2", nsim = 100, level = 0.9)

# check whether similar results are obtained when extreme cook's distance values are removed
M10 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSuperSimp, data = salt_comm_rest_H[-c(7,41,69),], link = "logit", na.action = na.exclude)
plot(M10) # cook's distance plot looks much better
summary(M10) # there are some differences from M9. but the influential values are realistic so should be retained..



M11 <- lm(total_cover_prop ~ poly(cbind(YSR,Elevation),2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, na.action = na.exclude)
plot(M11)

plot(salt_comm_rest_H$total_cover_prop)
hist(log(1-salt_comm_rest_H$total_cover_prop))

# use M12 - too many 1's for a beta regression + cbind the two poly variables so we're not modelling interactions between their polynomial terms
M12 <- lm(log(1-salt_comm_rest_H$total_cover_prop) ~ poly(cbind(YSR,Elevation),2) +  DomSpeciesSuperSimp, data = salt_comm_rest_H, na.action = na.exclude)
plot(M12) # plots look good enough - the data are ~1 inflated so that's going to show up regardless but the spread looks way better now.
summary(M12)

# visually interpret the results
# first calculate quantile values for elevation
quantile(salt_comm_rest_H$Elevation)
# insert quantile 1 and quantile 3 values as Elevation values to use
plot <- emmip(M12, Elevation~YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,9,11,12,19,30,33), Elevation = c(0.143, 0.469)))
plotdata <- plot$data
plotdata$Elevation <- as.factor(plotdata$Elevation)
# this plot has transformed data, so doesn't mean much

# backtransform data 
plotdata <- plotdata %>% 
  mutate(Cover = (1 - exp(yvar))*100)

# plot 
ggplot(aes(x = YSR, y = Cover, group = Elevation, color = Elevation), data = plotdata) +
  geom_line() +
  facet_wrap(~DomSpeciesSuperSimp) + 
  coord_cartesian(ylim=c(0, 100)) +
  ylab("Total cover")

# so total cover increases with increasing elevation, is higher at middle YSR, is lowest for higher YSR, and is higher for sporobolus



# add Site as a random effect
M13 <- lmer(log(1-salt_comm_rest_H$total_cover_prop) ~ poly(cbind(YSR,Elevation),2) +  DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)

# plot this
resid <- residuals(simulateResiduals(M13), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13,re.form = NA), resid) # pretty ok, one outlier

summary(M13)

#plot
# first calculate quantile values for elevation
quantile(salt_comm_rest_H$Elevation)
# insert quantile 1 and quantile 3 values as Elevation values to use
plot <- emmip(M13, Elevation~YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,9,11,12,19,30,33), Elevation = c(0.143, 0.469)))
plotdata <- plot$data
plotdata$Elevation <- as.factor(plotdata$Elevation)
# this plot has transformed data, so doesn't mean much

# backtransform data 
plotdata <- plotdata %>% 
  mutate(Cover = (1 - exp(yvar))*100)

# plot 
ggplot(aes(x = YSR, y = Cover, group = Elevation, color = Elevation), data = plotdata) +
  geom_line() +
  facet_wrap(~DomSpeciesSuperSimp) + 
  coord_cartesian(ylim=c(0, 100)) +
  ylab("Total cover")






# No interaction with elevation
M14 <- glmmTMB(log(1-total_cover_prop) ~ poly(YSR,2) + poly(Elevation,2) + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H, family = "gaussian")

# plot this
resid <- residuals(simulateResiduals(M14), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M14,re.form = NA), resid) # not exactly straight but ok

summary(M14)
```


```{r Total cover - plot predicted results}
# visually interpret the results

# elevation and YSR exist in a matrix with a lot of gaps. The only elevation value with data across the YSR range is ~0.4. Therefore plot YSR effects at elevation 0.4m.

# we're not plotting interactions, we're just plotting the effect of one variable.

# try with only an intermediate elevation value - 0.4
plotting_single_elevation1 <- tibble(YSR = c(6,9,11,12,16,30,33),
                                    Elevation = c(0.4,0.4,0.4,0.4,0.4,0.4,0.4),
                                    Site = NA,
                                    DomSpeciesSuperSimp = "Sporobolus")
plotting_single_elevation2 <- plotting_single_elevation1 %>% 
  mutate(DomSpeciesSuperSimp = "Sarcocornia")
plotting_single_elevation3 <- plotting_single_elevation1 %>% 
  mutate(DomSpeciesSuperSimp = "Other")
plotting_single_elevation <- rbind(plotting_single_elevation1,plotting_single_elevation2,plotting_single_elevation3)
plotting_single_elevation$predict_cover <- predict(M14, newdata = plotting_single_elevation, re.form = NULL)

# backtransform data 
plotting_single_elevation <- plotting_single_elevation %>% 
  mutate(Cover = (1 - exp(predict_cover))*100)

# append these data onto the original dataset

salt_comm_rest_H2 <- left_join(salt_comm_rest_H, plotting_single_elevation, by = c("YSR", "DomSpeciesSuperSimp"))

ggplot(data = salt_comm_rest_H2, aes(x = YSR, y = Cover)) +
  geom_point(aes(x = YSR, y = total_cover_prop*100), alpha = 0.5) +
  geom_line(size = 1) +
  theme(axis.title = element_text(size = 24),
        axis.text = element_text(size = 18),
        strip.text = element_text(size = 24)) +
  xlab("Years since restoration") +
  ylab("Total cover (%)") +
  facet_wrap(~DomSpeciesSuperSimp) +
  ylim(0,100) 
# export at 1000 x 700




# what is the average elevation at each YSR/dominant species combo?

salt_comm_rest_H_av <- salt_comm_rest_H %>% 
  group_by(YSR, DomSpeciesSuperSimp) %>% 
  summarise(mean(Elevation)) %>% 
  ungroup() %>% 
  rename(Elevation = `mean(Elevation)`) %>% 
  mutate(Site = NA)

# use this dataframe for plotting instead

# add predicted data
salt_comm_rest_H_av$predict_cover <- predict(M14, newdata = salt_comm_rest_H_av, re.form = NULL)

# backtransform data 
salt_comm_rest_H_av <- salt_comm_rest_H_av %>% 
  mutate(Cover = (1 - exp(predict_cover))*100)

# append these data onto the original dataset

salt_comm_rest_H3 <- left_join(salt_comm_rest_H, salt_comm_rest_H_av, by = c("YSR", "DomSpeciesSuperSimp")) %>% 
  mutate(DomSpeciesSuperSimp = factor(DomSpeciesSuperSimp, levels = c("Sporobolus", "Sarcocornia", "Other")))

ggplot(data = salt_comm_rest_H3, aes(x = YSR, y = Cover)) +
  geom_point(aes(x = YSR, y = total_cover_prop*100), alpha = 0.5) +
  geom_line(size = 1) +
  theme(axis.title = element_text(size = 24),
        axis.text = element_text(size = 18),
        strip.text = element_text(size = 24)) +
  xlab("Years since restoration") +
  ylab("Total cover (%)") +
  facet_wrap(~DomSpeciesSuperSimp) +
  ylim(0,100) 
# export at 1000 x 700

```


```{r Total cover - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = total_cover_prop*100)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 10) +
    labs(y = "Total cover (%)", x = "Years since restoration") +
      theme_classic()
# all look very similar

# natural sites - raw data and point means with error bars


# plot restoring sites  - violin plot
ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (proportion)") +
  xlim(0,35) + 
  ylim(0,1)
# print at 1500 x 789

# plot restoring sites  - box plot
S_Cov_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop*100, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (%)") +
  xlim(0,35) + 
  ylim(0,100) 
S_Cov_rest
# print at 1500 x 789
# export at 2200 x 800 for preso, 1500 x 800 for paper

# plot natural sites - violin plot
ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,1)
# print at 700 x 789

# plot natural sites - box plot
S_Cov_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop*100, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,100)
S_Cov_nat
# print at 700 x 789

# plot natural and restored together
ggarrange(S_Cov_rest,S_Cov_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# Elevation
ggplot(salt_comm_rest_H, aes(x = Elevation, y = total_cover_prop)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = lm) +
    labs(y = "Total cover (proportion)", x = "Elevation (standardised)") +
      theme_classic() 
# looks very similar
# ideally back-transform the elevation axis
```

```{r Total cover - summary stats}
# summary for all sites
summary(salt_comm$total_cover_prop, mean)
# summary by estuary
tapply(salt_comm$total_cover_prop, salt_comm$Estuary, mean)
# summary by site
tapply(salt_comm$total_cover_prop, salt_comm$Site, mean)
```


#2b - burrows

```{r Burrows - Exploration and data prep}
# histogram of burrows per site
ggplot(data = salt_comm_rest_H, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)

# plot relationships between variables
plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$YSR) # potentially non-linear
plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$Elevation) # relatively linear

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = Burrows_0.5x0.5)) +
  geom_point() +
  geom_smooth()

plot(salt_comm_rest_H$Elevation ~ salt_comm_rest_H$YSR)

# remove NA data
salt_comm_rest_H_burrows <- salt_comm_rest_H %>% subset(!is.na(Burrows_0.5x0.5))

```

```{r Zero-inflation testing and model approach}
# test for zero-inflation

100*sum(salt_comm_rest_H_burrows$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm_rest_H_burrows)
# 67% of our data are zeroes

# check if this number of zeroes can be predicted under a poisson model
M1 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + DomSpecies + Elevation,
          family = 'poisson',
          data = salt_comm_rest_H_burrows)
plot(M1) # plot doesn't look good

# check if this number of zeroes can be predicted under a negative binomial model

M2 <- glm.nb(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          data = salt_comm_rest_H_burrows)
plot(M2) # plot doesn't look good

M3 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          family = 'nbinom2',
          data = salt_comm_rest_H_burrows)
plot(M3) # plot doesn't look good

# try zero inflated poisson with the package pscl
M4 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "poisson", na.action = na.exclude)
# DomSpecies is not working as an interaction so just including as a separate predictor
rootogram(M4, main = "ZIP", ylim = c(-5, 15), max = 50)
qqrplot(M4, main = "ZIP")


# also try zero-inflated negative binomial model
M5 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M5, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M5, main = "ZINB")
summary(M5)
# not computing standard errors...


# try hurdle negative binomial model
M6 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)

rootogram(M6, main = "HNB", ylim = c(-5, 15), max = 50) # smooth curve indicates good fit
qqrplot(M6, main = "HNB")


# zero-inflated negative binomial model (M5) looks like the best fit.
#  https://rpubs.com/kaz_yos/pscl-2 seems to think this sort of model is best when both structural zeroes (must be zero) and sampling zeroes (could have been other numbers) are present - not sure if this is the case for my data or if it matters?
# I think this would be the case for my model - there would be structural zeroes where the quadrat simply had no crab holes so it would be impossible to find burrows, but there might also be sampling zeroes where there was a crab burrow but it was missed? / or structural zeroes where the site has no crab burrows and sampling zeroes where the particular quadrat happens to have no crab burrows even though they do exist elsewhere on site


# try without DomSpecies to see if that's what's causing the problem (no SEs)
M7 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation , data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M7, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M7, main = "ZINB")

summary(M7) # standard errors are produced, therefore looks like DomSpecies is causing the issue. Probably because some values of DomSpecies only have one occurrence. Should we group these into an "other vege" or something?

# interpreting model with coefficients
expCoef <- exp(coef((M7)))
expCoef <- matrix(expCoef, ncol = 2)

rownames(expCoef) <- c("(intercept)","poly(YSR,2)1","poly(YSR,2)2","Elevation","poly(YSR,2)1:Elev", "poly(YSR,2)2:Elev")
colnames(expCoef) <- c("Count_model","Zero_inflation_model")
expCoef

# trying to interpret the count model. 
# - the baseline number of crabs is 0.68.
# - one unit increase in the first "arm" of YSR polynomial corresponds to 282523 x more crabs (???)
# - one unit increase in the second "arm" of YSR polynomial corresponds to 5.2 x more crabs (non significant)
# - one unit increase in elevation corresponds to 0.2 less crabs
# - there is a positive interaction between the first "arm" of YSR and elevation
# - there is a negative interaction between the second "arm" of YSR and elevation



# try a version of M5 with DomSpeciesSimp instead

M8 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSimp, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
summary(M8) # still comes up with error

# Try DomSpeciesSuperSimp
M9 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp, data = salt_comm_rest_H_burrows, dist = "negbin", na.action = na.exclude)
rootogram(M9, main = "ZINB", ylim = c(-5, 15), max = 50) # looks fine
qqrplot(M9, main = "ZINB") # looks fine
summary(M9) # now no error.
plot(predict(M9), residuals(M9))

# try negative binomial in glmmTMB - might be ok without zero inflation
M10 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")

# try zero inflated negative binomial model in glmmTMB
M11 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2", ziformula =~1)
# in this plot we expect to see an increasing variance trend as it's a negative binomial distribution and hasn't been altered to fit a flat distribution.
plot(predict(M11), residuals(M11), ylim = c(-50,50))


# plot residuals vs predicted values with adjustments for easier interpretation - should see a relatively flat, even spread of residuals with no clear trend
resid <- residuals(simulateResiduals(M10), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10,re.form = NA), resid) # good
resid <- residuals(simulateResiduals(M11), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11,re.form = NA), resid) # looks a bit odd
hist(resid) # check distribution of residuals - should be normal
scatter.smooth(abs(resid), predict(M11,re.form = NA)) # test homogeneity of variance - looks fine with absolute values so should be ok

anova(M10,M11)
# significance here means the zero inflated part of the model does explain more of the variation, so therefore we should use the zero inflated model - M11

summary(M11)


# without elevation interaction
# try negative binomial in glmmTMB - might be ok without zero inflation
M12 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")

# try zero inflated negative binomial model in glmmTMB
M13 <- glmmTMB(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2", ziformula =~1)

# plot residuals vs predicted values with adjustments for easier interpretation - should see a relatively flat, even spread of residuals with no clear trend
resid <- residuals(simulateResiduals(M12), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M12,re.form = NA), resid) # good
resid <- residuals(simulateResiduals(M13), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13,re.form = NA), resid) # good

anova(M12,M13)
# lack of significance here means the zero inflated part of the model does not explain more of the variation, so therefore we should use the non-zero inflated model - M12

summary(M12)
```

```{r Burrows - plot}
# need to consider the data space with YSR and Elevation
plot(salt_comm_rest_H$Elevation ~ salt_comm_rest_H$YSR)
# there are only low elevations with low YSR and high elevations with high YSR, therefore we don't have a full matrix so can't model the entire data space. create a new dataframe to reflect the part of the matrix we have data for and include a column "Site" filled with NA
# let's do a matrix with 0.1-0.4m elevations for YSRs 6-16 and 0.5-0.8m elevations for YSRs 30-33

# also need to know how this is for each DomSpeciesSuperSimp.
t <- salt_comm_rest_H %>% subset(DomSpeciesSuperSimp == "Sporobolus") 
plot(t$Elevation ~ t$YSR) # has data across all Elevations/YSRs that the entire data cover (as above)
t <- salt_comm_rest_H %>% subset(DomSpeciesSuperSimp == "Sarcocornia") 
plot(t$Elevation ~ t$YSR) # only one data point at YSR 30 (elevation 0.6), rest of data are YSR 6-12 & elevation 0.2-0.5. Also YSR and elevation are correlated for this variable
t <- salt_comm_rest_H %>% subset(DomSpeciesSuperSimp == "Other") 
plot(t$Elevation ~ t$YSR) # only two data points at YSR 30/33 (elevation 0.5), rest of data are YSR 11-16 & elevation 0-0.2

plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$Elevation)



plotting_space1 <- tibble(Elevation = c(0.1,0.2,0.3,0.4,
                                       0.1,0.2,0.3,0.4,
                                       0.1,0.2,0.3,0.4,
                                       0.1,0.2,0.3,0.4,
                                       0.5,0.6,0.7,0.8,
                                       0.5,0.6,0.7,0.8),
                         YSR = c(6,6,6,6,
                                 9,9,9,9,
                                 12,12,12,12,
                                 16,16,16,16,
                                 30,30,30,30,
                                 33,33,33,33),
                         Site = NA,
                         DomSpeciesSuperSimp = "Sporobolus")

plotting_space2 <- tibble(Elevation = c(0.2,0.3,0.4,0.5,
                                        0.2,0.3,0.4,0.5,
                                        0.2,0.3,0.4,0.5,
                                        0.6),
                          YSR = c(6,6,6,6,
                                  9,9,9,9,
                                  12,12,12,12,
                                  30),
                          Site = NA,
                          DomSpeciesSuperSimp = "Sarcocornia")

plotting_space3 <- tibble(Elevation = c(0,0.1,0.2,
                                        0,0.1,0.2,
                                        0.5,0.5),
                          YSR = c(11,11,11,
                                  16,16,16,
                                  30,33),
                          Site = NA,
                          DomSpeciesSuperSimp = "Other")

plotting_space <- rbind(plotting_space1, plotting_space2, plotting_space3)

plotting_space$predict_burrows <- predict(M12, newdata = plotting_space, type = "response")

ggplot(data = plotting_space, aes(x = YSR, y = predict_burrows, color = Elevation)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp)

# try with only an intermediate elevation value - 0.4
plotting_single_elevation1 <- tibble(YSR = c(6,9,11,12,16,30,33),
                                    Elevation = c(0.4,0.4,0.4,0.4,0.4,0.4,0.4),
                                    Site = NA,
                                    DomSpeciesSuperSimp = "Sporobolus")
plotting_single_elevation2 <- plotting_single_elevation1 %>% 
  mutate(DomSpeciesSuperSimp = "Sarcocornia")
plotting_single_elevation3 <- plotting_single_elevation1 %>% 
  mutate(DomSpeciesSuperSimp = "Other")
plotting_single_elevation <- rbind(plotting_single_elevation1,plotting_single_elevation2,plotting_single_elevation3)
plotting_single_elevation$predict_burrows <- predict(M12, newdata = plotting_single_elevation, type = "response")


ggplot(data = plotting_single_elevation, aes(x = YSR, y = predict_burrows)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp)




# this doesn't take into account any of the other factors or interactions...
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = Burrows_0.5x0.5)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(span = 10)  +
    labs(y = "Burrows", x = "Years since restoration") +
      theme_classic()

# natural only
ggplot(salt_comm_nat_H, aes(x = Site, y = Burrows_0.5x0.5)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Burrows") +
  theme_classic()

salt_comm_rest_H$Burrows_ln <- log(salt_comm_rest_H$Burrows_0.5x0.5 + 0.001)

# boxplots - restored sites
S_Bur_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=(Burrows_0.5x0.5+0.01), group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of burrows") +
  xlim(0,35)  + ylim(0,62)
S_Bur_rest

# boxplots - natural sites
S_Bur_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=Burrows_0.5x0.5, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  scale_y_log10() 
S_Bur_nat

# plot natural and restored together
ggarrange(S_Bur_rest,S_Bur_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# predict effects of YSR when controlling for the other factors
predict_YSR <- ggemmeans(M12, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T) +
  ggtitle("") +  geom_line(linewidth = 1.2) +
  labs(y = "Burrows", x = "Years since restoration") +
  theme_classic() 
```


# 2c. Overall stem diameters and heights

```{r Overall stem diameters}
# to work out how the community looks in terms of stem diameters, we need to weight each species' diameters by their proportion. 
# for this, we'll need to create a wider dataset that has a row for every species' stem diameter and corresponding species proportion in that quadrat.
# this can be based on the average diameter of each species for each quadrat, so we'd end up with one row per quadrat.

# first, subset the salt dataset for only diameter-related data

salt_dia <- salt[,c(5:7,11,12,20,24,25,28,30:33,35,36)]

# then, widen based on both Stem_dia_mm and sp_prop. Calculate the mean stem diameter during this process (mean sp_prop will be identical to each sp_prop as this value is the same for each quadrat)

salt_dia_wider <- pivot_wider(salt_dia, id_cols = c(Estuary, Site, Quadrat, Quadrat.f, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = c(Species), values_from = c(Stem_dia_mm, sp_prop), values_fn = mean)

# then, calculate the average stem diameter for each quadrat
salt_dia_wider <-
  salt_dia_wider %>% 
  #rowwise will make sure the sum operation will occur on each row
  rowwise() %>% 
  mutate(Stem_dia_average = sum(Stem_dia_mm_Alternanthera*sp_prop_Alternanthera, 
    Stem_dia_mm_Aster*sp_prop_Aster,
    Stem_dia_mm_Ambrosia*sp_prop_Ambrosia,
    Stem_dia_mm_Bolboschoenus*sp_prop_Bolboschoenus,
    Stem_dia_mm_Cotula*sp_prop_Cotula,
    Stem_dia_mm_Grass_B * sp_prop_Grass_B,
    Stem_dia_mm_Grass_C * sp_prop_Grass_C,
    Stem_dia_mm_Grass_sp_1 * sp_prop_Grass_sp_1,
    Stem_dia_mm_Grass_sp_2 * sp_prop_Grass_sp_2,
    Stem_dia_mm_GSG * sp_prop_GSG,
    Stem_dia_mm_Juncus_acutus * sp_prop_Juncus_acutus,
    Stem_dia_mm_Juncus_kraussii * sp_prop_Juncus_kraussii,
    Stem_dia_mm_Juncus_sp1 * sp_prop_Juncus_sp1,
    Stem_dia_mm_Juncus_sp2 * sp_prop_Juncus_sp2,
    Stem_dia_mm_Lobelia * sp_prop_Lobelia,
    Stem_dia_mm_Mangrove_saplings_river * sp_prop_Mangrove_saplings_river,
    Stem_dia_mm_Mangrove_seedling * sp_prop_Mangrove_seedling,
    Stem_dia_mm_Pasture_grass * sp_prop_Pasture_grass,
    Stem_dia_mm_Phragmites * sp_prop_Phragmites,
    Stem_dia_mm_Pneumatophores * sp_prop_Pneumatophores,
    Stem_dia_mm_Sarcocornia * sp_prop_Sarcocornia,
    Stem_dia_mm_Sporobolus * sp_prop_Sporobolus,
    Stem_dia_mm_Suaeda * sp_prop_Suaeda,
    Stem_dia_mm_Triglochin * sp_prop_Triglochin,
    Stem_dia_mm_Watsonia * sp_prop_Watsonia, 
    na.rm=TRUE))

boxplot(salt_dia_wider$Stem_dia_average ~ salt_dia_wider$YSR)
boxplot(salt_dia_wider$Stem_dia_average ~ salt_dia_wider$Site) # weighted averages across site
boxplot(salt$Stem_dia_mm ~ salt$Site) # compare to incorrect averages across site


# try modelling?

M1 <- lm(Stem_dia_average ~ YSR * Elevation + DomSpeciesSuperSimp, data = salt_dia_wider)
plot(M1) # not good

M2 <- lm(log(Stem_dia_average) ~ YSR * Elevation + DomSpeciesSuperSimp, data = salt_dia_wider)
plot(M2) # pretty good
summary(M2) # no significant differences except with different DomSpecies
```

```{r Overall stem heights}
# similar approach for stem heights!

# first, subset the salt dataset for only height-related data

salt_ht <- salt[,c(5:7,11,12,19,24,25,28,30:33,35,36)]

# then, widen based on both Stem_dia_mm and sp_prop. Calculate the mean stem diameter during this process (mean sp_prop will be identical to each sp_prop as this value is the same for each quadrat)

salt_ht_wider <- pivot_wider(salt_ht, id_cols = c(Estuary, Site, Quadrat, Quadrat.f, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = c(Species), values_from = c(Stem_ht_mm, sp_prop), values_fn = mean)

# then, calculate the average stem diameter for each quadrat
salt_ht_wider <-
  salt_ht_wider %>% 
  #rowwise will make sure the sum operation will occur on each row
  rowwise() %>% 
  mutate(Stem_ht_average = sum(Stem_ht_mm_Alternanthera*sp_prop_Alternanthera, 
    Stem_ht_mm_Aster*sp_prop_Aster,
    Stem_ht_mm_Ambrosia*sp_prop_Ambrosia,
    Stem_ht_mm_Bolboschoenus*sp_prop_Bolboschoenus,
    Stem_ht_mm_Cotula*sp_prop_Cotula,
    Stem_ht_mm_Grass_B * sp_prop_Grass_B,
    Stem_ht_mm_Grass_C * sp_prop_Grass_C,
    Stem_ht_mm_Grass_sp_1 * sp_prop_Grass_sp_1,
    Stem_ht_mm_Grass_sp_2 * sp_prop_Grass_sp_2,
    Stem_ht_mm_GSG * sp_prop_GSG,
    Stem_ht_mm_Juncus_acutus * sp_prop_Juncus_acutus,
    Stem_ht_mm_Juncus_kraussii * sp_prop_Juncus_kraussii,
    Stem_ht_mm_Juncus_sp1 * sp_prop_Juncus_sp1,
    Stem_ht_mm_Juncus_sp2 * sp_prop_Juncus_sp2,
    Stem_ht_mm_Lobelia * sp_prop_Lobelia,
    Stem_ht_mm_Mangrove_saplings_river * sp_prop_Mangrove_saplings_river,
    Stem_ht_mm_Mangrove_seedling * sp_prop_Mangrove_seedling,
    Stem_ht_mm_Pasture_grass * sp_prop_Pasture_grass,
    Stem_ht_mm_Phragmites * sp_prop_Phragmites,
    Stem_ht_mm_Pneumatophores * sp_prop_Pneumatophores,
    Stem_ht_mm_Sarcocornia * sp_prop_Sarcocornia,
    Stem_ht_mm_Sporobolus * sp_prop_Sporobolus,
    Stem_ht_mm_Suaeda * sp_prop_Suaeda,
    Stem_ht_mm_Triglochin * sp_prop_Triglochin,
    Stem_ht_mm_Watsonia * sp_prop_Watsonia, 
    na.rm=TRUE))

boxplot(salt_ht_wider$Stem_ht_average ~ salt_ht_wider$YSR)
boxplot(salt_ht_wider$Stem_ht_average ~ salt_ht_wider$Site) # weighted averages across site
boxplot(salt$Stem_ht_mm ~ salt$Site) # compare to incorrect averages across site

M1 <- lm(Stem_ht_average ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M1) # not good

M2 <- lm(log(Stem_ht_average) ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M2) # not great

M3 <- lm(sqrt(Stem_ht_average) ~ YSR * Elevation * DomSpeciesSimp, data = salt_ht_wider)
plot(M3) # not great

# none are probably good enough but test M2 for interest
summary(M2) # lots of potential significance
```


# 3. Simple trial models - species level

# 3a - Sporobolus

Sporobolus stem density, height and diameter

Explanatory variables:
- restoration status (binary) OR YSR (continuous), depending on the model
- Elevation (continuous)
- Site (random, nested in restoration status)
- Quadrat (for stem height and diameter, unless we average them) (random, nested in Site in restoration status)
- Dominant species (categorical)
- species proportional cover (continuous)


```{r Sporobolus continuous depedent variables - check correlations}
plot(spor_H$total_stems ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$Stem_ht_mm ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$total_stems ~ spor_H$Stem_ht_mm) # not correlated

# therefore can model all three variables, as none are correlated

plot(spor_H$total_stems ~ spor_H$`Sp_cover_%`) # somewhat correlated but lots of variability especially in high cover %s
```

Should we only include Dominant Species of interest?

# 3ai. Sporobolus stem height

```{r Sporobolus stem height - initial assumptions}
hist(spor_H$Stem_ht_mm)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_ht_mm ~ spor_H$sp_prop) # potentially slightly non-linear, and clearly species proportion is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.
ggplot(spor_H, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 1) 

plot(spor_H$Stem_ht_mm ~ spor_H$Elevation) # looks non-linear
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.5)
# therefore try including these variables as non-linear predictor variables. Maybe a quadratic and cubic function respectively?

plot(spor_H$Stem_ht_mm ~ spor_H$YSR) # not sure
ggplot(spor_H, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.8) # maybe non-linear
```


```{r Sporobolus stem height - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  #geom_smooth(span = 1)
  stat_smooth(method="lm", se=TRUE, fill=NA,
                formula=y ~ poly(x, 2, raw=TRUE))

boxplot(spor_H$Stem_ht_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_ht_mm ~ spor_H$DomSpecies)
```



```{r Sporobolus stem height - YSR - plot}

ggplot(spor_H_rest, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_H_rest, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)
```



# 3aii. Stem diameter

```{r Sporobolus stem diameter - initial assumptions}
hist(spor_H$Stem_dia_mm)
hist(spor_H$sp_prop)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_dia_mm ~ spor_H$sp_prop) # linearity is fine, but clearly sp. proportions is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.

plot(spor_H$Stem_dia_mm ~ spor_H$Elevation) # looks fine

plot(spor_H$Stem_dia_mm ~ spor_H$YSR) # fine
```



```{r Sporobolus stem diameter - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_dia_mm)) +
  geom_point() +
  stat_smooth(method="lm")

boxplot(spor_H$Stem_dia_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_dia_mm ~ spor_H$DomSpecies)

boxplot(spor_H$Stem_dia_mm ~ spor_H$Site)
```



```{r Sporobolus stem diameter - YSR - plot}
ggplot(spor_H_rest, aes(x = YSR, y = sq.stem.dia)) +
  geom_point() +
  geom_smooth(method = lm)

# plot natural stem diameters
ggplot(spor_H_nat, aes(x = Site, y = ln.stem.dia)) +
  geom_boxplot() +
  geom_jitter(width=0.1) +
    scale_y_continuous(breaks = log(pretty(exp(spor_H_nat$ln.stem.dia))), labels = pretty(exp(spor_H_nat$ln.stem.dia))) +
    labs(y = "Sporobolus stem diameter (mm)", x = "Site") +
  theme_classic() 

# elevation
ggplot(spor_H_rest, aes(x = Elevation, y = ln.stem.dia)) +
  geom_point() +
  geom_smooth(span = 1)

# dominant species
ggplot(spor_H_rest, aes(x = DomSpecies, y = ln.stem.dia)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Log stem diameter") +
  theme_classic()

# need to back-transform and label these properly
```


# 3aiii. Sporobolus stem density 
- Stem density ~ YSR + Elevation + DomSpecies + SpeciesProportion + (1|Site)
- stem density is a positive integer value so should be able to conform to a roughly normal distribution

First assumption: linear relationship between predictors and response variable

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Sporoblus stem density - initial assumptions}
# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_comm_H$total_stems ~ spor_comm_H$sp_prop) # potentially non-linear
ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 1) +
  geom_smooth(method = lm) # polynomial is a better fit, try that first

plot(spor_comm_H$total_stems ~ spor_comm_H$Elevation) # not obviously non-linear

plot(spor_comm_H$total_stems ~ spor_comm_H$YSR) # looks potentially non-linear
ggplot(spor_comm_H, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 2) +
  geom_smooth(method = lm) # non-linear is a better fit
```


```{r Sporoblus stem density - restoration status - plot}
# plot
ggplot(spor_comm_H, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$total_stems ~ spor_comm_H$rest_status)
```


```{r Sporoblus stem density - YSR - model}
M <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + poly(sp_prop,2) + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M)

# everything except DomSpecies is significant. But sp_prop should probably be excluded.

M2 <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M2)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M2) # all VIF are <5 (low collinearity)

# residuals plots
plot(M2) # not equal variances
qqnorm(resid(M2)) 
qqline(resid(M2)) # normality is great!

# try sqrt transform
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

plot(M3) # good
qqnorm(resid(M3)) 
qqline(resid(M3)) # a couple diverging values, but good enough
```


```{r Sporoblus stem density - YSR - plot}
# final model
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

# plot - YSR
ggplot(spor_comm_H_res, aes(x = YSR, y = sq.stem.dens)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
      theme_classic() +
  xlim(0,35)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M3, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T, add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
  labs(y = "Sporobolus stems per square metre", x = "Years since restoration") +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

# plot restoring sites  - box plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 1.5) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789
# export at 2200 x 800

# plot natural sites - box plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

ggplot(spor_comm_H_res, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)
```


# 3av - Sporobolus % species cover

Sporobolus % species cover
- Total cover ~ rest_status*YSR + Elevation + (1|Estuary) + (1|Site)
- beta distribution (proportional data with 2 categories - cover and non cover)


```{r sporobolus % cover univariate}
ggplot(spor_comm_H, aes(x = YSR, y = `Sp_cover_%`)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$`Sp_cover_%` ~ spor_comm_H$rest_status)
```


Other assumptions (??)


```{r Sporobolus species cover - plot}
ggplot(spor_comm_H, aes(x = YSR, y = sp_cover_prop)) +   
      geom_point(alpha = 0.5) +
    geom_smooth() + # meaningless
      theme_classic()
# older sites have consistently higher cover, compared with more varied cover at younger sites

spor_comm_H %>% subset(rest_status == "0") %>% 
  ggplot(., aes(x = Site, y=sp_cover_prop)) +
  geom_boxplot() +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sp_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus species cover (proportion)") +
  xlim(0,35) +
  ylim(0,1)
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sp_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,1)
# print at 700 x 789
```


# 3avii - Sporobolus seeding

Sporobolus seeding - ordinal categorical response variable

```{r Sporobolus seeding - Data manipulation}
# make seeds into an ordinal variable
spor_comm$Seeds <- factor(spor_comm$Seeds, order = TRUE, levels = c("No", "Very few", "Few", "Some", "Lots"))
```

# 4. Multivariate models

Community traits

# 4a. Community composition

```{r Community composition}
# remove columns that only have zeroes
salt_comm_comp_H_res[,1:25] %>% colSums() # the last four columns are all zeroes
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:21,26:31)]

# only include species with at least 5 occurrences.
# check occurrences of each species
colSums(salt_comm_comp_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
# also remove Pneumatophores - they are not a saltmarsh species so are not that relevant for understanding community composition.
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:3,8,10,12,22:27)] # subset for only those species

SaltComm <- mvabund(salt_comm_comp_H_res[,1:6])

# check out spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(salt_comm_comp_H_res[,1:6], horizontal = TRUE, las = 2, main = "Percent cover")
# large differences in variance, therefore check out mean-variance relationship

# check out mean-variance relationship
meanvar.plot(SaltComm)
# strong mean-variance relationship (close to linear but slightly curved like a negative quadratic function), therefore use a model that appropriately accounts for this

# roughly visualise data
plot(SaltComm ~ as.factor(salt_comm_comp_H_res$YSR))




# create model with interaction term
fit_cover <- manyany(SaltComm ~ YSR * Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.1), var.power = 1.1)
sum(fit_cover$logL) # sum of log likelihood = -3797

# now check the residuals vs fitted values plot and check for the optimum var.power value

plot(fit_cover) # looks ok

# test for the best value of the var.power element
vpwrs <- seq(1.1,1.8, by =.1) # only going up to 1.8 rather than 1.9 as 1.9 creates errors and would be a worse fit than 1.8 anyway
LogL_vp <- rep(NA, length(vpwrs))
for(i in 1:length(vpwrs)){ 
  fit_vp <- manyany(SaltComm ~ YSR * Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=vpwrs[i]), var.power=vpwrs[i])
  LogL_vp[i] <- sum(fit_vp$logL)
}

# looking for whichever model has the greatest log Likelihood
plot(LogL_vp) # log likelihood maximised at 1.6

# should create new model with var.power = 1.6. However, later at the anova stage, this doesn't work. Try lower values
fit_cover2 <- manyany(SaltComm ~ YSR * Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.5), var.power = 1.5)

plot(fit_cover2) # residuals look ok - assumptions ok

# test importance of YSR by comparing it to a model without YSR and without YSR * Elevation interaction
# without interaction
fit_cover_null <- manyany(SaltComm ~ YSR + Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.5), var.power = 1.5) 
# without YSR term
fit_cover_null2 <- manyany(SaltComm ~ Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.5), var.power = 1.5)

# test for differences between the models
anova(fit_cover_null, fit_cover2) # testing for interaction between YSR and Elevation
anova(fit_cover_null2, fit_cover_null) # testing for YSR




# Use this - no interaction between Elevation and YSR

fit_cover3 <- manyany(SaltComm ~ YSR + Elevation + Site, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.1), var.power = 1.1)
sum(fit_cover3$logL) # sum of log likelihood = -3941

# now check the residuals vs fitted values plot and check for the optimum var.power value

plot(fit_cover3) # looks ok

# test for the best value of the var.power element
vpwrs <- seq(1.1,1.8, by =.1) # only going up to 1.8 rather than 1.9 as 1.9 creates errors and would be a worse fit than 1.8 anyway
LogL_vp <- rep(NA, length(vpwrs))
for(i in 1:length(vpwrs)){ 
  fit_vp <- manyany(SaltComm ~ YSR + Elevation + Site, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=vpwrs[i]), var.power=vpwrs[i])
  LogL_vp[i] <- sum(fit_vp$logL)
}

# looking for whichever model has the greatest log Likelihood
plot(LogL_vp) # log likelihood maximised at 1.6

# should create new model with var.power = 1.6. However, later at the null model stage, this doesn't work. Try lower values - 1.4 is the highest value that works
fit_cover4 <- manyany(SaltComm ~ YSR + Elevation + Site, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.4), var.power = 1.4)

plot(fit_cover4) # residuals look ok - assumptions ok

# test importance of YSR by comparing it to a model without YSR 
fit_cover_null <- manyany(SaltComm ~ Elevation + Site, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.4), var.power = 1.4) # only works at max var.power = 1.4

# test for differences between the models
anova(fit_cover_null, fit_cover4) 
# glm.fit: algorithm did not converge error - coming up when playing around with different values of var.power too

```


```{r Community composition - glmmTMB}
# remove columns that only have zeroes
salt_comm_comp_H_res[,1:25] %>% colSums() # the last four columns are all zeroes
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:21,26:31)]

# only include species with at least 5 occurrences.
# check occurrences of each species
colSums(salt_comm_comp_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
# also remove Pneumatophores - they are not a saltmarsh species so are not that relevant for understanding community composition.
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:3,8,10,12,22:27)] # subset for only those species



# make these data long - suitable format for glmmTMB
comm_comp_long <- salt_comm_comp_H_res %>% 
  pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Bolboschoenus, Aster, Phragmites), names_to = "Species", values_to = "Percent_cover") %>% 
  unite("Combo",2:3,remove = FALSE) %>% 
  mutate(cover_prop = case_when(
    Percent_cover == 0 ~ 0.000000000001,
    .default = Percent_cover/100 - 0.0000000001))

# plot relationships between variables
ggplot(data = comm_comp_long, aes(x = YSR, y = Percent_cover)) +
  geom_point() +
  facet_wrap(~Species) #no evidence of non-linearity
ggplot(data = comm_comp_long, aes(x = Elevation, y = Percent_cover)) +
  geom_point() +
  facet_wrap(~Species) # no evidence of nonlinearity

# distribution of data
ggplot(data = comm_comp_long, aes(x = Percent_cover)) +
  geom_histogram() +
  facet_wrap(~Species)
ggplot(data = comm_comp_long, aes(x = log(Percent_cover + 0.00001))) +
  geom_histogram() +
  facet_wrap(~Species) # log not helpful
ggplot(data = comm_comp_long, aes(x = log(1- cover_prop + 0.00001))) +
  geom_histogram() +
  facet_wrap(~Species) # not good either
ggplot(data = comm_comp_long, aes(x = sqrt(cover_prop))) +
  geom_histogram() +
  facet_wrap(~Species) # maybe slightly better

# model - with reduced rank covariance structure
M1 <- glmmTMB(Percent_cover ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long)

# check assumptions
resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1,re.form = NA), resid) # scaled residuals plot - not good.
plotQQunif(M1) # normal QQ plot - not good

# should use a beta distribution or similar to reflect the distribution of the data
M2 <- glmmTMB(cover_prop ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = beta_family(link = "logit"))

# check assumptions
resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2,re.form = NA), resid) # scaled residuals plot - not good.
plotQQunif(M2) # not good

# try tweedie distribution with the proportion data
M3 <- glmmTMB(cover_prop ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = glmmTMB::tweedie(link = "log"))
# error 

# check assumptions
resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3,re.form = NA), resid) # scaled residuals plot - not good.
plotQQunif(M3)


M3 <- glmmTMB(cover_prop ~ Species * YSR + Elevation + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = glmmTMB::tweedie(link = "log"))
# still error


# try logit-transforming first
comm_comp_long$logit_cover <- log(comm_comp_long$cover_prop / (1 - comm_comp_long$cover_prop))

#This calculates the logit or log-odds of the percentage cover.

M4 <- glmmTMB(logit_cover ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long)
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4,re.form = NA), resid) # scaled residuals plot - weird with two clumps
plotQQunif(M4) # ok


# try other models
M5 <- glmmTMB(log(Percent_cover + 0.000001) ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long)
resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5,re.form = NA), resid) # clumped.. and a couple outliers
plotQQunif(M5) # not terrible

M6 <- glmmTMB(sqrt(Percent_cover + 0.000001) ~ Species:(YSR + Elevation) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long)
resid <- residuals(simulateResiduals(M6), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6,re.form = NA), resid) # slightly better. still weird but more evenly spread
plotQQunif(M6) # not great
```


```{r Community composition - plot}
# make data longer
salt_comm_comp_H_res_long <- salt_comm_comp_H_res %>% pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Aster, Bolboschoenus, Phragmites), names_to = "Species", values_to = "Percent_cover")

# plot
ggplot(data = salt_comm_comp_H_res_long, aes(x = as.factor(YSR), y = Percent_cover, fill = Species)) +
  geom_boxplot() +
  facet_wrap(~Species) +
  scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 1, option = "A") +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Species percent cover") +
  theme(strip.text = element_text(size = 24))
# print at 1500 x 1200

```


Species traits

# 4b. Stem density

```{r Stem density}
# note, currently: STEM DENSITY MULTIPLIED OUT - NO OFFSETS
# also can't currently included species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# transform this to wide format with a column for each species' stem density. Not sure how this works with offsets. Let's start without and then figure out there
stem_dens_wide <- stem_dens_unique %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = total_stems)

# fill NA values with zeroes
stem_dens_wide[,11:35] <- stem_dens_wide[,11:35] %>% replace(is.na(.), 0)

# subset for only Hunter and only restored
stem_dens_wide_H_res <- stem_dens_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes (i.e. no observations of that species anywhere)
stem_dens_wide_H_res[,11:35] %>% colSums() # the last four columns are all zeroes
stem_dens_wide_H_res <- stem_dens_wide_H_res[,1:35]

# now, we are only interested in species that have at least 5 total observations (otherwise there are insufficient data to analyse them)
# calculate number of non-zero elements in each column
colSums(stem_dens_wide_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
stem_dens_wide_H_res <- stem_dens_wide_H_res[,c(1:14,18,20,22)] # subset for only those species

# set up mvabund with stem density columns - these are 11-17
stemdens_mvabund <- mvabund(stem_dens_wide_H_res[,11:17])

# look at spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(stem_dens_wide_H_res[,11:17], horizontal = TRUE, las = 2, main = "Stem density")

# look at mean-variance relationship
meanvar.plot(stemdens_mvabund) # strong linear relationship

# explore visually
plot(stemdens_mvabund ~ as.factor(stem_dens_wide_H_res$YSR), cex.axis = 0.8, cex = 0.8)

# count data so model with poisson or negative binomial distribution
stemdens_mod1 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpecies, data = stem_dens_wide_H_res, family = "poisson")

# check model assumptions
plot(stemdens_mod1) # NOT OK!! there is a big trend...

# try a negative binomial model
stemdens_mod2 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpecies, data = stem_dens_wide_H_res) # default family is negative binomial

# check model assumptions
plot(stemdens_mod2) # zero inflated but much much better!

# try with DomSpeciesSimp
stemdens_mod3 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpeciesSimp, data = stem_dens_wide_H_res)

plot(stemdens_mod3) # fine
meanvar.plot(stemdens_mod3)

# try with DomSpeciesSuperSimp
stemdens_mod4 <- manyglm(stemdens_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp, data = stem_dens_wide_H_res)

plot(stemdens_mod4) # one outlier

# therefore try mod3 (residuals plot looks fine and only has species we can statistically analyse)

# use model to test hypotheses
anova(stemdens_mod3)

# get more specifics
anova(stemdens_mod3, p.uni = "adjusted")


```

```{r Stem density again - long format with one species per row?}
# can we just use Species as a predictor variable? and then we'd easily be able to include the offsets for quadrat size? don't remember the reason why we hadn't done this earlier (it might not be ok)
# yes we can, but need to account for covariance between species observations for the same quadrat:

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# only Hunter and restored...
stem_dens_unique_H_res <- stem_dens_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# determine which species have at least 5 values
Stem_dens_count <-
  stem_dens_unique_H_res %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(Stems)))
print(Stem_dens_count, n = 21)
# retain Aster, Bolboschoenus, Phragmites, Pneumatophores, Sarcocornia, Sporobolus, Triglochin

stem_dens_unique_H_res <- stem_dens_unique_H_res %>% 
  subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Pneumatophores", "Sarcocornia", "Sporobolus", "Triglochin"))

# remove NAs
stem_dens_unique_H_res <- stem_dens_unique_H_res %>% subset(!is.na(Stems))

# use glmmTMB

M1 <- glmmTMB(Stems ~ YSR * Elevation + YSR * Species + Elevation * Species + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + (1|Combo) + rr(Species+0|Combo, d = 1), family = "nbinom2", data = stem_dens_unique_H_res)

M1 <- glmmTMB(Stems ~ YSR * Elevation + YSR * Species + Elevation * Species + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + rr(Species+1|Combo, d = 1), family = "nbinom2", data = stem_dens_unique_H_res)


M1 <- glmmTMB(Stems ~ YSR * Species * Elevation + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + Combo + rr(Species+0|Combo, d = 1), family = "nbinom2", data = stem_dens_unique_H_res)


plot(predict(M1), residuals(M1)) # looks like a negative binomial spread! more spread in negative values and a couple extreme values
resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1)) # scaled residuals plot - looks ok?
plotQQunif(M1) # looks great


summary(M1)



# try adding sp_prop
M2 <- glmmTMB(Stems ~ YSR * Elevation * Species + DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2), family = "nbinom2", data = stem_dens_unique_H_res)
# do we need to add + (1|Combo) when that's already involved in the covariate structure?
# also what is d?

plot(predict(M2), residuals(M2)) # looks great and less uneven than previous
resid <- residuals(simulateResiduals(M2), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M2)) # looks good
plotQQunif(M2) # looks great


summary(M2)



M3 <- glmmTMB(Stems ~ Species:(YSR + Elevation + sp_prop ) + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3, re.form = NA), resid) # has a trend.. however this is only driven by a few points so might be ok
plotQQunif(M3) # looks great

summary(M3)

```

```{r Stem density - mvabund with offset matrix - incomplete dataset}
# I think we're likely going to have errors due to not having each species in each quadrat...

# define some parameters
nspec = n_distinct(stem_dens_unique_H_res$Species) #number of species
nquadrat = nrow(stem_dens_unique_H_res) #number of rows/ quadrats
nBoot = 999 #desired number of bootstraps

# create some bootstrapping matrixes
#bootID short is a matrix with nBOOT rows (e.g. 99 or 999), and nsite columns. As in the regular anova the response has length nsite
bootID_short =  matrix(NA, nrow = nBoot, ncol = nquadrat)
#bootID long is a matrix with nBOOT rows (e.g. 99 or 999), and nsite*nspecies columns. As in the long format anova the response has length nspecies
bootID_long = matrix(NA, nrow = nBoot, ncol = nquadrat*nspec)

#construct a bootID by sampling quadrats with replacement
for (b in 1:nBoot){
  site_samples = sample(1:nquadrat,nquadrat, replace = TRUE) 
  bootID_short[b,] = site_samples
}

# long format data - cull rows I don't need and add a long data row index
stem_dens_unique_H_res <- stem_dens_unique_H_res %>% 
  dplyr::select(Combo, Species, Stems, Elevation, Quadrat_area, total_stems, YSR, DomSpeciesSuperSimp, sp_prop, unique) %>%
  mutate(long_data.row.index = 1:n())

#In this data, the row names are not the row indexes, otherwise you could skip this step and join on the row names. To be safe we join on row indexes in the next step. 
row_names_row_index_lookup_table = data.frame(Combo = stem_dens_unique_H_res$Combo) %>% mutate(row.index = 1:nquadrat)
row_names_row_index_lookup_table

#This step selects the rows of the long format data which are selected in each bootstrap iteration. The important thing is that all rows corresponding to a site will be sampled in a bootstrap sample. 
for(i in 1:nBoot){
  bootID_long[i, ] = data.frame(row.index = matrix((bootID_short[i,]), ncol=1)) %>% #select the ith row of bootID_short
    left_join(row_names_row_index_lookup_table) %>%  #joins on "row.index" This step is needed as the site names are not the row indexes
    left_join(stem_dens_unique_H_res, multiple = "all") %>% #joins on "rows" (which are the site names in reveg). This is a many to one join. We take 10 rows and return 240 rows. 
    dplyr::select(long_data.row.index) %>% #now we select the row indexes of the long format data which will be used in the ith bootstrap resample
    unlist()
  #these are the rows in the ith bootstrap 
}
# this is not working - most likely because it expects a complete matrix with all 6 species listed for all 139 quadrats, which is not the case.
```


```{r Stem density - mvabund with offset matrix - full dataset}
# set up new dataframes based on non-adjusted Stem data

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# transform this to wide format with a column for each species' stem density. Not sure how this works with offsets. Let's start without and then figure out there
stem_dens_wide <- stem_dens_unique %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, rest_status, YSR, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = Stems)

# fill NA values with zeroes
stem_dens_wide[,11:35] <- stem_dens_wide[,11:35] %>% replace(is.na(.), 0)

# subset for only Hunter and only restored
stem_dens_wide_H_res <- stem_dens_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes (i.e. no observations of that species anywhere)
stem_dens_wide_H_res[,11:35] %>% colSums() # the last four columns are all zeroes
stem_dens_wide_H_res <- stem_dens_wide_H_res[,1:35]

# now, we are only interested in species that have at least 5 total observations (otherwise there are insufficient data to analyse them)
# calculate number of non-zero elements in each column
colSums(stem_dens_wide_H_res != 0) # species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites
# however, don't include pneumatophores, as they're only present at one site
stem_dens_wide_H_res <- stem_dens_wide_H_res[,c(1:13,18,20,22)] # subset for only those species


# now we can convert the wide format to long format so we can retain rows with zero observations

stem_dens_long_zeroes <- stem_dens_wide_H_res %>% 
  pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Bolboschoenus, Aster, Phragmites), names_to = "Species", values_to = "Stems") %>% 
  mutate(unique = paste0(Combo,":",Species))

# this dataset does not have species proportion or offset data - we will need to add these

id_data <- stem_dens_unique_H_res %>% dplyr::select(Quadrat_area, sp_prop, unique, Species) %>% subset(Species != "Pneumatophores") %>% dplyr::select(Quadrat_area, sp_prop, unique) 

stem_dens_long_zeroes <- stem_dens_long_zeroes %>% full_join(id_data) %>% 
  mutate(
    Quadrat_area = Quadrat_area %>% replace(is.na(.), 10000), # replace missing data with 1 x 1 m quadrat
    sp_prop = sp_prop %>% replace(is.na(.), 0), # replace missing species proportions with 0 (there were none)
    total_stems = round(Stems * 10000/Quadrat_area), # column for total stems adjusting for different quadrat sizes (for plottin only, using offsets for modelling)
    long_data.row.index = 1:n()) # add unique row index identifier

# define some parameters
nspec = n_distinct(stem_dens_long_zeroes$Species) #number of species
nquadrat = nrow(stem_dens_long_zeroes)/6 #number of rows/ quadrats - this dataset has one row per each of 6 species so to get # quadrats we need to divide by 6
nBoot = 999 #desired number of bootstraps

# create some bootstrapping matrixes
#bootID short is a matrix with nBOOT rows (e.g. 99 or 999), and nsite columns. As in the regular anova the response has length nsite
bootID_short =  matrix(NA, nrow = nBoot, ncol = nquadrat)
#bootID long is a matrix with nBOOT rows (e.g. 99 or 999), and nsite*nspecies columns. As in the long format anova the response has length nspecies
bootID_long = matrix(NA, nrow = nBoot, ncol = nquadrat*nspec)

#construct a bootID by sampling quadrats with replacement
for (b in 1:nBoot){
  site_samples = sample(1:nquadrat,nquadrat, replace = TRUE) 
  bootID_short[b,] = site_samples
}

#In these data, the row names are not the row indexes, otherwise you could skip this step and join on the row names. To be safe we join on row indexes in the next step. 
row_names_row_index_lookup_table = data.frame(Combo = unique(stem_dens_long_zeroes$Combo)) %>% mutate(row.index = 1:nquadrat)
row_names_row_index_lookup_table

#This step selects the rows of the long format data which are selected in each bootstrap iteration. The important thing is that all rows corresponding to a site will be sampled in a bootstrap sample. 
for(i in 1:nBoot){
  bootID_long[i, ] = data.frame(row.index = matrix((bootID_short[i,]), ncol=1)) %>% #select the ith row of bootID_short
    left_join(row_names_row_index_lookup_table) %>%  #joins on "row.index" This step is needed as the site names are not the row indexes
    left_join(stem_dens_long_zeroes, multiple = "all") %>% #joins on "rows" (which are the site names in reveg). This is a many to one join. We take 10 rows and return 240 rows. 
    dplyr::select(long_data.row.index) %>% #now we select the row indexes of the long format data which will be used in the ith bootstrap resample
    unlist()
  #these are the rows in the ith bootstrap 
}


# use data with NAs rather than zeroes

stem_dens_long_NA <- stem_dens_long_zeroes %>% mutate(
  Stems = case_when(Stems == 0 ~ NA,
                    .default = Stems),
  total_stems = case_when(total_stems == 0 ~ NA,
                    .default = total_stems)
)

# run the model with an offset - which could vary by species as the data is long format - using a bootID matrix to make sure sites are resampled together. 
fit_null_2 = manyglm(Stems ~ Elevation * Species + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA) # without YSR
fit_null2_2 = manyglm(Stems ~ YSR * Species + Elevation * Species + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA)

fit_alt_2 = manyglm(Stems ~ YSR * Elevation * Species  + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA)

# test model assumptions (?)
plot(fit_alt_2)

anova(fit_null_2, fit_null2_2, bootID = bootID_long) # testing for importance of YSR
anova(fit_null2_2, fit_alt_2, bootID = bootID_long) # testing for importance of YSR * Elevation interaction








# isn't using the boot_ID matrix we've made, likely because of the NAs.
# can we create a matrix with just the non-NA data?

stem_dens_non_NA <- stem_dens_long_NA %>% subset(!is.na(Stems))
non_NA_rows <- stem_dens_non_NA$long_data.row.index

# define some parameters
nspec = n_distinct(stem_dens_non_NA$Species) #number of species
nquadrat = nrow(stem_dens_long_zeroes)/6 #number of rows/ quadrats - this dataset has one row per each of 6 species so to get # quadrats we need to divide by 6
nBoot = 999 #desired number of bootstraps

# create some bootstrapping matrixes
#bootID short is a matrix with nBOOT rows (e.g. 99 or 999), and nsite columns. As in the regular anova the response has length nsite
bootID_short =  matrix(NA, nrow = nBoot, ncol = nquadrat)
#bootID long is a matrix with nBOOT rows (e.g. 99 or 999), and nsite*nspecies columns. As in the long format anova the response has length nspecies
bootID_long = matrix(NA, nrow = nBoot, ncol = nquadrat*nspec)

#construct a bootID by sampling quadrats with replacement
for (b in 1:nBoot){
  site_samples = sample(non_NA_rows,nquadrat, replace = TRUE) 
  bootID_short[b,] = site_samples
}

#In these data, the row names are not the row indexes, otherwise you could skip this step and join on the row names. To be safe we join on row indexes in the next step. 
row_names_row_index_lookup_table = data.frame(Combo = unique(stem_dens_non_NA$Combo)) %>% mutate(row.index = 1:nquadrat)
row_names_row_index_lookup_table

#This step selects the rows of the long format data which are selected in each bootstrap iteration. The important thing is that all rows corresponding to a site will be sampled in a bootstrap sample. 
for(i in 1:nBoot){
  bootID_long[i, ] = data.frame(row.index = matrix((bootID_short[i,]), ncol=1)) %>% #select the ith row of bootID_short
    left_join(row_names_row_index_lookup_table) %>%  #joins on "row.index" This step is needed as the site names are not the row indexes
    left_join(stem_dens_long_zeroes, multiple = "all") %>% #joins on "rows" (which are the site names in reveg). This is a many to one join. We take 10 rows and return 240 rows. 
    dplyr::select(long_data.row.index) %>% #now we select the row indexes of the long format data which will be used in the ith bootstrap resample
    unlist()
  #these are the rows in the ith bootstrap 
}


# doesn't work because the different matrixes have different lengths, just like when we were trying with the incomplete dataset earlier






#delete this part eventually
# for some reason the manual bootstrapping seems to work with total_stems but not with Stems...
fit_null = manyglm(total_stems ~ Elevation * Species + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA) # without YSR
fit_null2 = manyglm(total_stems ~ YSR * Species + Elevation * Species + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA) # without Elevation * YSR interaction

fit_alt = manyglm(total_stems ~ YSR * Elevation * Species + 
                     DomSpeciesSuperSimp + sp_prop + offset(log(Quadrat_area)),
                   data=stem_dens_long_NA)

# test model assumptions (?)
plot(fit_alt)

anova(fit_null, fit_null2, bootID = bootID_long) # testing for importance of YSR
anova(fit_null2, fit_alt, bootID = bootID_long) # testing for importance of YSR * Elevation interaction
```


```{r Stem density - complete correlation model}
# use glmmtmb with (0 + Species|Combo) random effect term that takes into account correlations between species in each quadrat

# plot stem densities of each species per site
ggplot(stem_dens_unique_H_res, aes(y = total_stems, x = Site, group = Species)) +
  geom_point() +
  facet_wrap(~Species)
# model works best with <5 species, therefore remove pneumatophores and phragmites, which are only present at 1 and 3 sites, respectively

stem_dens_unique_H_res <- stem_dens_unique_H_res %>% subset(Species %in% c("Aster", "Bolboschoenus", "Sarcocornia", "Sporobolus", "Triglochin"))

# also plot sp_prop of each species per site
ggplot(stem_dens_unique_H_res, aes(y = sp_prop, x = Site, group = Species)) +
  geom_point() +
  facet_wrap(~Species)

plot(stem_dens_unique_H_res$sp_prop ~ stem_dens_unique_H_res$total_stems) # not problematically correlated

M2 <- glmmTMB(Stems ~ YSR * Elevation * Species + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + (0 + Species|Combo) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
# doesn't work with sp_prop, doesn't work with species() format
# doesn't work without DomSpeciesSuperSimp. Also surely DomSpeciesSuperSimp is a similar term to the species correlation?

resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2, re.form = NA), resid) # has somewhat of a trend and two outliers
plotQQunif(M2) # looks great

# trying to make another version of the model that's formatted better and has better looking residuals graphs, but this code isn't working...
M3 <- glmmTMB(Stems ~ Species:(YSR + Elevation)  + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + (0 + Species|Combo) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

# without species interacting with elevation
M4 <- glmmTMB(Stems ~ Species * YSR + Elevation  + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + (0 + Species|Combo) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
# also a warning message

#summary(M2)




# model without YSR/elevation interaction - works with interaction but not without? doesn't even work with only YSR * Species

M4 <- glmmTMB(Stems ~ YSR * Species + Elevation + DomSpeciesSuperSimp + offset(log(Quadrat_area)) + (0 + Species|Combo) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
```



```{r Stem density - plot}

# at different elevations
# median elevation:
median(stem_dens_long_NA$Elevation) # 0.298
# split data into two groups, one <0.298 and one >0.298 elevation
stem_dens_long_NA <- stem_dens_long_NA %>% mutate(Elev_class =
                                                    case_when(Elevation < 0.298 ~ "Low",
                                                              Elevation >= 0.298 ~ "High"))


# use total stems column for plotting
stem_dens_summary <- stem_dens_long_NA %>% 
  subset(!is.na(total_stems)) %>% 
  group_by(Site, Species, Elev_class) %>% 
  summarise(avg = mean(total_stems), se = sd(total_stems)/sqrt(n()), YSR = mean(YSR)) %>% 
  ungroup()

stem_dens_summary <- stem_dens_summary %>% mutate(Site = factor(Site, levels = c("AE", "TB", "HS", "TA", "CF", "CC")))

# By YSR
ggplot(data = stem_dens_summary, aes(x = YSR, y = avg, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species, scales = "free_y")

# By species
ggplot(data = stem_dens_summary, aes(x = Site, y = avg, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species, scales = "free_y")


# By YSR
ggplot(data = stem_dens_summary, aes(x = YSR, y = avg, group = Elev_class, color = Elev_class, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species, scales = "free_y")








# this is still coded for reproduction

# By YSR
reprod_proportions %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(reprod_type != "Buds") %>% 
  ggplot(aes(x = YSR, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point(size = 4) +
  geom_errorbar(size = 2) +
  facet_wrap(~Species) +
  ylab("Proportion of quadrats with reproduction") +
  xlab("Years since restoration") +
  labs(color = "Reproduction type") +
  theme_bw() +
  theme(axis.title = element_text(size = 28), axis.text = element_text(size = 24), legend.title = element_blank(), legend.text = element_text(size = 24), strip.text = element_text(size = 24)) +
  scale_color_viridis(discrete = TRUE, begin = 0.4, end = 0.8, option = "A") 

```


# 4c. Reproduction

```{r Reproduction (presence/absence)}
# note: can't currently include species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just reproduction data
reprod <- salt[,c(5,6,7,11,16:18,24,25,28,30:32,35,36)]

# recode seeds as a binary presence/absence variable
reprod$Seeds %>% unique() # view unique values
reprod <- reprod %>% mutate(Seeds = case_when(
  Seeds == "No" ~ 0,
  Seeds == "Yes" ~ 1,
  Seeds == "Lots" ~ 1,
  Seeds == "Some" ~ 1,
  Seeds == "Few" ~ 1,
  Seeds == "Very few" ~ 1,
  Seeds == "NA" ~ NA
))

# remove replicates from measuring multiple stems for each species per quadrat (but only one reproduction value)
# first create a column for every unique site/quadrat/species combination
reprod$unique <- factor(interaction(reprod$Combo, reprod$Species, sep = ":"))
reprod_unique <- reprod %>% distinct(unique, .keep_all = TRUE) 

# subset for only restored and Hunter
reprod_unique_H_res <- reprod_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# count number of non-na values for each species (can only analyse species with at least 5 values)
Reprod_count <-
  reprod_unique_H_res %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(Seeds))) # can choose whatever reproduction type here as when one was recorded, all were.
print(Reprod_count, n = 21)

# species with enough data are: aster, bolboschoenus, phragmites, sarcocornia, sporobolus, triglochin
reprod_unique_H_res <- reprod_unique_H_res %>% subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))

# make data longer with one row for reproduction type and another for presence/absence
reprod_long <- reprod_unique_H_res %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# transform this to wide format with a column for each species' reproduction. 
reprod_wide <- reprod_long %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, YSR, rest_status, reprod_type, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = Reproduction)

# set up mvabund with reproduction columns - these are 12-17
reprod_mvabund <- mvabund(reprod_wide[,12:17])

# look at spread of data - boxplots are not ideal for binary data...
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(reprod_wide[,12:17], horizontal = TRUE, las = 2, main = "Reproduction")

# explore visually - hard to interpret with binary data
plot(reprod_mvabund ~ as.factor(reprod_wide$YSR), cex.axis = 0.8, cex = 0.8)

# binary data so model with binomial distribution

reprod_mod1 <- manyglm(reprod_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp + reprod_type, data = reprod_wide, family = "binomial", na.rm = TRUE)

# This is coming up with errors, even though all categorical variables have multiple levels. Coming up with fatal errors when I experiment removing variables.

# maybe because Bolboschoenus only has reprod_type = seeds? and other uncommon species probably have similar problems (Aster and Phragmites)

# therefore try with only Sarcocornoia, Sporobolus and Triglochin
reprod_unique_H_res2 <- reprod_unique_H_res %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin"))

# make data longer with one row for reproduction type and another for presence/absence
reprod2_long <- reprod_unique_H_res2 %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# transform this to wide format with a column for each species' reproduction. 
reprod2_wide <- reprod2_long %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, YSR, rest_status, reprod_type, DomSpecies, DomSpeciesSimp, DomSpeciesSuperSimp), names_from = Species, values_from = Reproduction)

# set up mvabund with reproduction columns - these are 12-14
reprod2_mvabund <- mvabund(reprod2_wide[,12:14])

reprod_mod2 <- manyglm(reprod2_mvabund ~ YSR * Elevation + DomSpeciesSuperSimp + reprod_type, data = reprod2_wide, family = "binomial", na.rm = TRUE)




# check model assumptions
plot(reprod_mod2) 

# use model to test hypotheses
anova(reprod_mod2)

# get more specifics
anova(reprod_mod2, p.uni = "adjusted")
```


```{r Reproduction - explore data}
# explore - only seeds
seeds <- reprod_long %>% subset(reprod_type == "Seeds")

M3 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + DomSpeciesSuperSimp + rr(Species+0|Combo, d = 2), family = "binomial", data = seeds)
# warnings

M4 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + (1|Combo), family = "binomial", data = seeds)

ggplot(data = seeds, aes(x = Reproduction, y = Species)) +
  geom_boxplot() +
  facet_wrap(~Site)
# bolboschoenus has almost no data; sporobolus, sarcocornia and triglochin have the most data

seeds.s <- seeds %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin"))

M5 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + (1|Combo), family = "binomial", data = seeds.s)
# no warnings

seeds.no.b <- seeds %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin", "Aster", "Phragmites"))

M6 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + (1|Combo), family = "binomial", data = seeds.no.b)
# warning


# explore - only flowers
flowers <- reprod_long %>% subset(reprod_type == "Flowers")

ggplot(data = flowers, aes(x = Reproduction, y = Species)) +
  geom_boxplot() +
  facet_wrap(~Site)
# bolboschoenus and phragmites have no useable data.


# explore - only buds
buds <- reprod_long %>% subset(reprod_type == "Buds")

ggplot(data = buds, aes(x = Reproduction, y = Species)) +
  geom_boxplot() +
  facet_wrap(~Site)
# there are only bud data for triglochin and aster. zeroes for the rest.

# explore - general reproduction
ggplot(data = reprod_long, aes(x = Reproduction, y = Species)) +
  geom_boxplot() +
  facet_wrap(~Site)

# maybe we just can't include reprod_type as a factor since (particularly) buds are no good.








# what is the proportion of each species at each site with each reproduction type?

reprod_proportions <- reprod_long %>% 
  group_by(Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), 
            #se = sd(Reproduction)/sqrt(n()), 
            YSR = mean(YSR)) %>% 
  ungroup()

reprod_proportions <- reprod_proportions %>% mutate(Site = factor(Site, levels = c("AE", "TB", "HS", "TA", "CF", "CC")))

# By YSR
ggplot(data = reprod_proportions, aes(x = YSR, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  #geom_errorbar() + # can't use error bars! error is simply proportional to how close to 0/1 or 0.5 the values are.. 
  facet_wrap(~Species)

# By species
ggplot(data = reprod_proportions, aes(x = Site, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species)


# with just sporobolus, sarcocornia, triglochin and just flowers, buds
# USE THIS PLOT

# By YSR
reprod_proportions %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(reprod_type != "Buds") %>% 
  ggplot(aes(x = YSR, y = avg, group = reprod_type, color = reprod_type)) +
  geom_point(size = 4) +
  facet_wrap(~Species) +
  ylab("Proportion of quadrats with reproduction") +
  xlab("Years since restoration") +
  labs(color = "Reproduction type") +
  theme_bw() +
  theme(axis.title = element_text(size = 28), axis.text = element_text(size = 24), legend.title = element_blank(), legend.text = element_text(size = 24), strip.text = element_text(size = 24)) +
  scale_color_viridis(discrete = TRUE, begin = 0.4, end = 0.8, option = "A") 
# print at 1500 x 789
```



```{r Reproduction - try long data approach in glmmTMB}
# remove NAs
reprod_long <- reprod_long %>% subset(!is.na(Reproduction))

# not sure this is going to work as we have two grouping variables, Species and reprod_type
M1 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + YSR * Species * reprod_type +  rr(Species+0|Combo, d = 2), family = "binomial", data = reprod_long)
# do we need to add + (1|Combo) when that's already involved in the covariate structure?
# remove DomSp.. for now
# warning message

# do separately or do summary of reproduction?

# check model assumptions
residuals(M1)
predict(M1)
plot(predict(M1), residuals(M1))

resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1)) # scaled residuals plot - there are three outliers with large negative predicted values. are these ok? how do I know which they are and if I should remove them?
resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1), ylim = c(-20,20)) # looks pretty good without the outliers.
plotQQunif(M1) # looks great

summary(M1)







M2 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + YSR * Species * reprod_type +  (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_long)

M2 <- glmmTMB(Reproduction ~ YSR * reprod_type +  (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_long)




reprod.s <- reprod_long %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin"))

M7 <- glmmTMB(Reproduction ~ YSR * reprod_type +  (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s)



# try without reproduction type as a factor - just general presence and absence of reproduction.

M8 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + (1|Combo), family = "binomial", data = reprod_long)
# model convergence problem

M9 <- glmmTMB(Reproduction ~ YSR * Elevation * Species + (1|Combo), family = "binomial", data = reprod.s)
# fine

residuals(M9)
predict(M9)
plot(predict(M9), residuals(M9))

resid <- residuals(simulateResiduals(M9), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M9)) # scaled residuals plot - consistent spread but there are more high values than low values.

plotQQunif(M9) # looks great

summary(M9) # no sig. possibly the model is oversimplified with all reproduction types being lumped together though.




# USE THIS MODEL:
# try with just seeds and flowers as it was just buds that had a lack of data

reprod.s_sf <- reprod.s %>% subset(reprod_type %in% c("Flowers", "Seeds"))

M10 <- glmmTMB(Reproduction ~ YSR * reprod_type + (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

# it worked!! woo. 

resid <- residuals(simulateResiduals(M10), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M10)) # scaled residuals plot - looks great. just a bit larger spread in large values. but should be fine

plotQQunif(M10) # looks great

summary(M10) # 
# YSR is significant, but when you add elevation to the model, it's not


# not sure if this is the right combo of predictors though. Shouldn't species also be a fixed effect? and we should add elevation to the model

M11 <- glmmTMB(Reproduction ~ YSR * reprod_type * Species + Elevation + (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

resid <- residuals(simulateResiduals(M11), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11,re.form = NA), resid) # scaled residuals plot - looks great.

plotQQunif(M11) # looks great

summary(M11) # 



# set up with Species properly 
M12 <- glmmTMB(Reproduction ~ Species:(YSR * reprod_type) + YSR * reprod_type + Elevation + (1+reprod_type|Species) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

resid <- residuals(simulateResiduals(M12), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M12,re.form = NA), resid) # scaled residuals plot - looks great.

plotQQunif(M12) # amazing

summary(M12) # why isn't sarcocornia mentioned throughout? is it just captured in the intercept?



```




Stem traits

# 4d. Stem height and diameter

```{r Stem height and diameter - prep data}
# check number of non-NA rows for each Species (so we can exclude species with <5 values - insufficient data to analyse)
Stem_ht_count <- 
  salt_H_rest %>% 
  group_by(Species, Quadrat.f) %>% # should only count 1 per quadrat.. independent observations. therefore grouping by Quadrat.f as well.
  summarise(total_non_na = sum(!is.na(Stem_ht_mm)))
print(Stem_ht_count, n = 21)

Stem_ht_quadrats <-
  Stem_ht_count %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(total_non_na)))
print(Stem_ht_quadrats, n = 21)

# species to retain (at least 5 quadrats): Aster, Bolboschoenus, Phragmites, Pneumatophores, Sarcocornia, Sporobolus, Triglochin
# also exclude Pneumatophores as they only exist at one level of YSR so cause issues in the model.
# stem diameters were measured at the same time as stem heights so these would also be the suitable species for stem diameter.

salt_H_rest_stems <- salt_H_rest %>% subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))


# visualise relationships between traits for each species
scatterplotMatrix(~ Stem_ht_mm + Stem_dia_mm | Species, data=salt_H_rest_stems,smooth=FALSE,regLine=FALSE,ellipse=TRUE, by.groups=TRUE,diagonal=FALSE,legend=list(coords="bottomleft")) # this does not need to be a matrix as there are only two factors! Interesting to look at though.

# visualise boxplots for each factor
boxplot(salt_H_rest_stems$Stem_ht_mm ~ salt_H_rest_stems$Species)
boxplot(salt_H_rest_stems$Stem_dia_mm ~ salt_H_rest_stems$Species)

# recode characters as factors?
salt_H_rest_stems$DomSpeciesSimp <- as.factor(salt_H_rest_stems$DomSpeciesSimp)
salt_H_rest_stems$DomSpeciesSuperSimp <- as.factor(salt_H_rest_stems$DomSpeciesSuperSimp)
salt_H_rest_stems$Species <- as.factor(salt_H_rest_stems$Species)
```



```{r Stem diameter - try models and explore assumptions}
# remove NAs
salt_H_rest_stems_dia <- salt_H_rest_stems %>% subset(!is.na(Stem_dia_mm))

# explore distribution
hist(salt_H_rest_stems_dia$Stem_dia_mm) # highly right skewed
hist(log(salt_H_rest_stems_dia$Stem_dia_mm)) # better
hist(sqrt(salt_H_rest_stems_dia$Stem_dia_mm)) # better but worse than log

# explore relationship between dependent and predictor variables
plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$YSR) # not clearly non-linear
plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$Elevation) # not clearly non-linear

M1 <- glmmTMB(Stem_dia_mm ~ Species:(YSR * Elevation + DomSpeciesSuperSimp + sp_prop) + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)
# warning about rank deficiency with the Species: format (otherwise just multiply it by YSR and Elevation and it works)

plot(predict(M1, re.form = NA), residuals(M1)) # not that even
plotQQunif(M1) # not very good

# log model
M2 <- glmmTMB(log(Stem_dia_mm) ~ Species:(YSR * Elevation + DomSpeciesSuperSimp + sp_prop) + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)
# warning about rank deficiency with the Species: format (otherwise just multiply it by YSR and Elevation and it works)

plot(predict(M2, re.form = NA), residuals(M2)) # not that even
plotQQunif(M2) # not good

# sqrt model
M3 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species* YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M3, re.form = NA), residuals(M3)) # looks weird with two distinct clumps. but no trend per se and fairly equal distribution either side of zero so I think it's good
plotQQunif(M3) # not great

# therefore use M3
summary(M3)
# YSR is not significant except in interaction with both elevation and speciesBolboschoenus


# can we try a different distribution type?
# gamma distribution since it's right skewed?

M4 <- glmmTMB(Stem_dia_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = Gamma(link = "inverse"), data = salt_H_rest_stems_dia)
# not working properly (errors and terrible assumptions graphs below)

plot(predict(M4), residuals(M4, re.form = NA)) # not that even
plotQQunif(M4)



# play around with variables with the sqrt model
M5 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species:(YSR * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)
# works without DomSpecies inside the bracket (or without it completely)

plot(predict(M5), residuals(M5)) # looks weird with two distinct clumps. but no trend per se and fairly equal distribution either side of zero so I think it's good
plotQQunif(M5) # not great

summary(M5)

resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5,re.form = NA), resid)



# without elevation/YSR interaction

M6 <- glmmTMB(Stem_dia_mm ~ Species:(YSR + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)
# fixed effects are rank deficient if DomSpeciesSuperSimp is in the brackets (would be highly correlated with Species)

plot(predict(M6, re.form = NA), residuals(M6)) # looks weird with two distinct clumps. but maybe ok
plotQQunif(M6) # terrible

M7 <- glmmTMB(log(Stem_dia_mm) ~ Species:(YSR + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M7, re.form = NA), residuals(M7)) # looks weird with two distinct clumps. but maybe ok
plotQQunif(M7) # better but not good

M8 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species:(YSR + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M8, re.form = NA), residuals(M8)) # looks good
plotQQunif(M8) # not great - but these models are robust to deviations from normality for this sample size so it's totally fine.

summary(M8)
```

```{r Stem diameter - interpreting effects}
plot_model(M8, type = "pred", terms = c("YSR", "Species", "Elevation"))
plot_model(M8, type = "int", terms = c("Species", "YSR", "Elevation"))


# code modified from https://osf.io/28mpv

# Describe the interaction effect based on estimated marginal means and errors
# get and plot estimated marginal means, standard errors, and confidence intervals.

# Get estimated marginal means and errors
emm = as.data.frame(emmeans(M3, specs=c("YSR", "Species")))

# Prepare plot with stimated marginal means and CIs (this code doesn't work)
mm = ggplot(data=salt_H_rest_stems_dia, aes(x=YSR, y=Stem_dia_mm, fill=Species)) + 
  #ylim(ylim) +
  geom_line(data=emm, linewidth=1.3, linetype=1,
            aes(x=YSR, y=emmean, group=Species, colour=Species)) + 
  geom_point(data=emm, size=3, shape=18, 
             aes(x=YSR, y=emmean, group=Species, colour=Species)) + 
  geom_errorbar(data=emm, size=1, width=.1,
                aes(x=YSR, y=emmean, group=Species, colour=Species, ymin=lower.CL, ymax=upper.CL)) +
  scale_colour_brewer(palette="Dark2") + scale_fill_brewer(palette="Dark2") + 
  ggtitle("Model estimated \n marginal means ") + 
  theme_bw() + 
  theme(plot.title=element_text(hjust=0.5, size=27), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        legend.position=c(.2,.85),
        legend.title=element_text(size=25), 
        legend.text=element_text(size=25),
        axis.title.x=element_text(size=27),
        axis.text.x=element_text(size=27),
        axis.title.y=element_text(size=25),
        axis.text.y=element_text(size=25),
        panel.border = element_blank(),
        axis.line.x = element_line(linewidth = 0.5, linetype = "solid", colour = "black"),
        axis.line.y = element_line(linewidth = 0.5, linetype = "solid", colour = "black"))
mm


ggplot(data = salt_H_rest_stems_dia, aes(x = YSR, y = Stem_dia_mm, group = YSR, fill = Species)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~Species)
```


```{r Stem height - try models and explore assumptions}
# remove NAs
salt_H_rest_stems_ht <- salt_H_rest_stems %>% subset(!is.na(Stem_ht_mm))

# explore distribution
hist(salt_H_rest_stems_ht$Stem_ht_mm) # highly right skewed
hist(log(salt_H_rest_stems_ht$Stem_ht_mm)) # pretty good
hist(sqrt(salt_H_rest_stems_ht$Stem_ht_mm)) # still right skewed

# explore relationship between dependent and predictor variables
plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$YSR) # not clearly non-linear
plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$Elevation) # not clearly non-linear

M0 <- glmmTMB(Stem_ht_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# iteration limit warning - try changing iteration limit
M1 <- glmmTMB(Stem_ht_mm ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)), data = salt_H_rest_stems_ht)
# now have another error..

# try with no YSR/species interaction
M1 <- glmmTMB(Stem_ht_mm ~ Species + YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# no error - therefore a problem with Species again

plot(predict(M0), residuals(M0)) # not good
plotQQunif(M0) # not good
# therefore the non-transformed model doesn't meet assumptions anyway, so see if transformed models are better for assumptions

# log model
M2 <- glmmTMB(log(Stem_ht_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# no error with log model

plot(predict(M2), residuals(M2)) # decent but some more extreme lower values, probably ok though
plotQQunif(M2) # pretty good

# sqrt model
M3 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species * YSR * Elevation + DomSpeciesSuperSimp + sp_prop * Species + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# no warnings

plot(predict(M3), residuals(M3)) # ok but more clumped than log
plotQQunif(M3) # pretty good

# therefore use M2
summary(M2)

# build model properly with Species interacting with everything

# log model
M4 <- glmmTMB(log(Stem_ht_mm) ~ Species:(YSR * Elevation + sp_prop) + (1|Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# have to exclude DomSpecies
plot(predict(M4), residuals(M4)) # ok?
plotQQunif(M4) # not amazing..

# sqrt model
M5 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species:(YSR * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
# have to exclude DomSpecies
plot(predict(M5), residuals(M5)) # clumped, and a couple outliers, but ok...
plotQQunif(M5) # pretty good

resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5,re.form = NA), resid) # decent

summary(M5)



# remove YSR/Elevation interaction

M6 <- glmmTMB(log(Stem_ht_mm) ~ Species:(YSR + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M6), residuals(M6)) # a few outliers but probably ok?
plotQQunif(M6) # looks good 

M7 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species:(YSR + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M7), residuals(M7)) # a couple outliers but probably ok
plotQQunif(M7) # not great


# therefore use M6
summary(M6)

# M6 is now coming up with a warning..

M8 <- glmmTMB(log(Stem_ht_mm) ~ Species * YSR + Species * Elevation + Species * sp_prop + DomSpeciesSuperSimp + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M8), residuals(M8)) # looks good
plotQQunif(M8) # not great but probably ok?

# 
summary(M8)
```


```{r Stem height - YSR - plot}
ggplot(data = salt_H_rest_stems_ht, aes(x = YSR, y = Stem_ht_mm, group = YSR, fill = Species)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~Species)
```


#5. Restored vs natural models

Let's try these with all the data from both estuaries.

```{r look at interaction between rest_status and elevation?}
plot(salt_comm$Elevation ~ salt_comm$rest_status)
# natural sites have elevations ~0.4-0.8
# restoring sites have elevations ~0-0.8
# therefore can include interactions but can only interpret results for 0.4-0.8m elevations
# although restoring sites don't have a lot of data between 0.6 and 0.8 which is where the majority of natural sites' data is, so might be safer to leave out the interaction. it's not our study question anyway.

# for different species?
ggplot(data = salt_comm_comp_long_less %>% subset(Sp_cover != 0), aes(x = rest_status, y = Elevation)) +
  geom_point() +
  facet_wrap(~Species)
# with this subset of species, it looks like species other than Sporobolus don't really have a sufficient range of elevations to be able to look at the interaction between elevation and restoration status by species
```


# 5.1 Community composition

```{r Community composition - nat vs rest - model}
# only include species with at least 5 occurrences.
# check occurrences of each species
colSums(salt_comm_comp != 0) # species with less than 5 values are Mangrove_seedling, Suaeda, Ambrosia, Pasture_grass, Cotula, GSG, Grass_sp_1, Grass_sp_2, Lobelia, Alternanthera, Watsonia, Grass_B, Grass_C, Juncus_acutus, Juncus_sp1, Juncus_sp2, Mangrove_saplings_river
salt_comm_comp <- salt_comm_comp %>% dplyr::select(-c("Mangrove_seedling", "Suaeda", "Ambrosia", "Pasture_grass", "Cotula", "GSG", "Grass_sp_1", "Grass_sp_2", "Lobelia", "Alternanthera", "Watsonia", "Grass_B", "Grass_C", "Juncus_acutus", "Juncus_sp1", "Juncus_sp2", "Mangrove_saplings_river")) # subset to remove those species with too few observations

# can't use mvabund here as it can't handle random effects

# therefore use the long data approach in glmmTMB?

# convert to long data
salt_comm_comp_long <- salt_comm_comp %>% 
  dplyr::select(-Juncus_kraussii) %>%  # can't include Juncus_kraussii as this didn't have enough data for Hunter restored sites so can't create a crossed model
  pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites), names_to = "Species", values_to = "Sp_cover") %>% 
  mutate(Sp_cover_prop = 
           case_when(Sp_cover == 0 ~ 0, # keep zeroes as zeroes
                     .default = Sp_cover/100 - 0.00001), # convert other values to proportions. Can't have values of 1 so offset slightly 
         Combo = paste0(Site, Quadrat))  


# visualise
hist(salt_comm_comp_long$Sp_cover_prop) # highly zero-inflated given we've included an extra row for each time a species wasn't present..
hist(log(salt_comm_comp_long$Sp_cover_prop)) # becomes left skewed
hist(sqrt(salt_comm_comp_long$Sp_cover_prop)) # still zero inflated of course

salt_comm_comp_long %>% subset(rest_status == 1) %>% 
  ggplot(aes(x = Sp_cover_prop, group = Species)) +
  geom_histogram() +
  facet_wrap(~Species) # view distribution of values for each species in restored sites
# pneumatophores looks like it's only zeroes, but observing the data, you can see there are also some very small proportions

salt_comm_comp_long %>% subset(rest_status == 0) %>% 
  ggplot(aes(x = Sp_cover_prop, group = Species)) +
  geom_histogram() +
  facet_wrap(~Species) # view distribution of values for each species in natural sites
# pneumatophores, aster, bolboschoenus and phragmites look like they're only zeroes
# aster and bolboschoenus and phragmites are all zeroes for natural sites, there are some pneumatophores
# community composition should be able to be modelled with zeroes, but it might not work with glmmtmb approach
# so let's try without these species

salt_comm_comp_long_less <- salt_comm_comp_long %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin", "Pneumatophores"))


 # try a zero-inflated beta model because data are highly zero-inflated and it's proportion data so beta distribution makes sense

# need to add covariance structure, because each species' proportion is correlated with the other species in that quadrat.

M1 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status * Elevation) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1, re.form = NA), resid) # good, two outliers but fine
# there is an increasing trend though.. will address this in M3 onwards below

# make a dataset of predicted points
predicted <- predict(M1, re.form = NA)
# bind this and the residuals to the initial dataframe
with_predict <- bind_cols(salt_comm_comp_long_less, predicted = predicted, resid = resid)
# can identify extreme values and test the effect of removing them
# these are rows 330 and 434
with_predict <- with_predict[-c(330,434),]

# test if model is different without these points - how much leverage they have
M2 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status * Elevation) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = with_predict)
resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2, re.form = NA), resid) # now there is one new outlier

# regardless, let's see if results are very different between the two models
summary(M1)
summary(M2)
# similar results but some slight differences in how significant they are


# see if we can make the residuals plot look better (no trend)
M3 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status * Elevation) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3, re.form = NA), resid) # probably worse than M1

M4 <- glmmTMB(Sp_cover_prop ~ Species:rest_status + rest_status * Elevation + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4, re.form = NA), resid) # becomes very clustered and still has a slight trend

M5 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status + Elevation) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5, re.form = NA), resid) # still a trend but slightly better than M1 and hopefully good enough. 2 outliers too

# check if these 2 outliers have a significant impact on the results
# make a dataset of predicted points
predicted <- predict(M5, re.form = NA)
# bind this and the residuals to the initial dataframe
with_predict <- bind_cols(salt_comm_comp_long_less, predicted = predicted, resid = resid)
# can identify extreme values and test the effect of removing them
# these are rows 74 and 434
with_predict <- with_predict[-c(74,434),]

# test if model is different without these points - how much leverage they have
M6 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status + Elevation) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = with_predict)
resid <- residuals(simulateResiduals(M6), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6, re.form = NA), resid) # now there is one new outlier

# regardless, let's see if results are very different between the two models
summary(M5)
summary(M6)
# pretty similar, therefore the outliers aren't having a massive impact and we can use M5


# Species needs to be connected to everything as species cover doesn't mean anything when looked at across species
M7 <- glmmTMB(Sp_cover_prop ~ Species:(rest_status + Elevation) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)
resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7, re.form = NA), resid) # not ideal

summary(M7)
```


```{r Community composition - nat vs rest - plot}

ggplot(data = salt_comm_comp_long_less, aes(x = Estuary, y = Sp_cover + 0.0001, fill = as.factor(rest_status))) +
  geom_boxplot() +
  facet_wrap(~Species) +
  scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 1, option = "A",
                     name="",
                     breaks=c("0", "1"),
                     labels=c("Natural", "Restoring")) +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Species percent cover") +
  theme(strip.text = element_text(size = 24)) +
  scale_y_continuous(trans='log10', breaks = c(0,1,10,100))
# print at 

# natural only

```


# 5.2 Total cover


```{r Total cover - explore}
# histogram
hist(salt_comm$total_cover_prop) # highly left skewed
hist(log(salt_comm$total_cover_prop)) # highly left skewed
hist(sqrt(salt_comm$total_cover_prop)) # highly left skewed
hist(log(1 - salt_comm$total_cover_prop)) # looks closer to normal, still inflated with large negatives now
hist(log(1.025 - salt_comm$total_cover_prop)) # looks a bit better, but I'm not sure if it's ok to randomly choose a number for an offset

# plot relationships between variables
plot(salt_comm$total_cover_prop ~ salt_comm$rest_status)
plot(salt_comm$total_cover_prop ~ salt_comm$Elevation) # not obviously non-linear
```

```{r Total cover - model}
M1 <- lmer(salt_comm$total_cover_prop ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm, na.action = na.exclude)
plot(M1) # looks terrible
plotQQunif(M1) # not good

M2 <- lmer(log(1-salt_comm$total_cover_prop) ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm, na.action = na.exclude)
plot(M2) # looks ok
plotQQunif(M2) # not great

M3 <- lmer(log(1.025-salt_comm$total_cover_prop) ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm, na.action = na.exclude)
plot(M3) # better, but not sure if it's ok to choose a random number for an offset
plotQQunif(M3) # great


summary(M3)

# try different distribution types

M4 <- glmer(salt_comm$total_cover_prop ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), family = "nbinom2", data = salt_comm, na.action = na.exclude)
plot(M4) # not good

M5 <- glmer(salt_comm$total_cover_prop ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), family = "Gamma", data = salt_comm, na.action = na.exclude)
plot(M5) # not good



# with estuary as a random factor

M6 <- lmer(log(1-salt_comm$total_cover_prop) ~ rest_status * Elevation +  DomSpeciesSuperSimp + (1|Estuary/Site), data = salt_comm, na.action = na.exclude)
plot(M6) # looks great
plotQQunif(M6) # ok - works with estuary as a random and not fixed effect

summary(M6)


# don't need an interaction with elevation

M7 <- lmer(log(1-salt_comm$total_cover_prop) ~ rest_status * Estuary + Elevation +  DomSpeciesSuperSimp + (1|Site), data = salt_comm, na.action = na.exclude)
plot(M7) # looks great
plotQQunif(M7) # ok

summary(M7)
```

```{r Total cover - natural vs restoring - plot}
ggplot(salt_comm, aes(x=Estuary, y=total_cover_prop*100, fill = as.factor(rest_status))) +
    geom_boxplot() +
  geom_jitter(size = 3)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A",
                      name="",
                      breaks=c("0", "1"),
                      labels=c("Natural", "Restoring")) +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          legend.text = element_text(size = 20)) +
  xlab("Estuary") +
  ylab("Saltmarsh cover (%)") +
  ylim(0,100) 
```


# 5.3 Burrows


```{r Burrows - Exploration and data prep}
# histogram of burrows per site
ggplot(data = salt_comm, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)

hist(salt_comm$Burrows_0.5x0.5) # highly right skewed
hist(log(salt_comm$Burrows_0.5x0.5)) # roughly normal
hist(sqrt(salt_comm$Burrows_0.5x0.5)) # right skewed

# plot relationships between variables
plot(salt_comm$Burrows_0.5x0.5 ~ salt_comm$rest_status) 
plot(salt_comm$Burrows_0.5x0.5 ~ salt_comm$Elevation) # relatively linear


# remove NA data
salt_comm_burrows <- salt_comm %>% subset(!is.na(Burrows_0.5x0.5))

```

```{r Zero-inflation testing and model approach}
# test for zero-inflation

100*sum(salt_comm_burrows$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm_burrows)
# 48% of our data are zeroes

# try negative binomial in glmmTMB - might be ok without zero inflation
M1 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + (1|Estuary/Site), data = salt_comm_burrows, family = "nbinom2")
resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1, re.form = NA), resid) # not great but ok

# try zero inflated negative binomial model in glmmTMB
M2 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + Estuary + (1|Site), data = salt_comm_burrows, family = "nbinom2", ziformula =~1)
resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2, re.form = NA), resid) # not great but ok
# didn't work with estuary as part of the random factor

# try poisson?
M3 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + Estuary + (1|Site), data = salt_comm_burrows, family = "poisson")
resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3, re.form = NA), resid) # one outlier, otherwise mostly ok
# didn't work with estuary as part of the random factor

M4 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + (1|Estuary/Site), data = salt_comm_burrows, family = "poisson", ziformula =~1)
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4, re.form = NA), resid) # slight trend


# try with different interactions...
M5 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation +  DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm_burrows, family = "nbinom2")
resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5, re.form = NA), resid) # not great

# try zero inflated negative binomial model in glmmTMB
M6 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm_burrows, family = "nbinom2", ziformula =~1)
resid <- residuals(simulateResiduals(M6), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6, re.form = NA), resid) # not great

# try poisson?
M7 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm_burrows, family = "poisson")
resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7, re.form = NA), resid) # ok, just two outliers

M8 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status * Elevation + DomSpeciesSuperSimp + Estuary * rest_status + (1|Site), data = salt_comm_burrows, family = "poisson", ziformula =~1)
resid <- residuals(simulateResiduals(M8), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8, re.form = NA), resid) # ok

summary(M8)


# no interaction with elevation
M9 <- glmmTMB(Burrows_0.5x0.5 ~ Estuary * rest_status + Elevation + DomSpeciesSuperSimp + (1|Site), data = salt_comm_burrows, family = "poisson", ziformula =~1)
resid <- residuals(simulateResiduals(M9), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9, re.form = NA), resid) # pretty good

summary(M9)
```



# 5.4 Stem density

```{r Stem density - nat vs rest - prepare and explore}
# first of all need to create a dataset with one stem density row per species/quadrat
# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32,35,36)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 



hist(stem_dens_unique$total_stems) # highly right skewed
hist(log(stem_dens_unique$total_stems)) # weird but better
hist(sqrt(stem_dens_unique$total_stems)) # still right skewed

hist(stem_dens_unique$Stems) #  right skewed
hist(log(stem_dens_unique$Stems)) # left skewed
hist(sqrt(stem_dens_unique$Stems)) # pretty good
```

```{r Stem density - nat vs rest - model}


stem_dens_unique_less <- stem_dens_unique %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin", "Pneumatophores")) %>% 
  subset(!is.na(Stems)) # remove NA data

M1 <- glmmTMB(Stems ~ Species:(rest_status * Elevation) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "nbinom2", data = stem_dens_unique_less)
resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1, re.form = NA), resid)
# this has a trend
plotQQunif(M1) # good

# try a gaussian distribution with sqrt transformed data?
M2 <- glmmTMB(sqrt(Stems) ~ Species:(rest_status * Elevation) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less) # now coming up with an error
resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2, re.form = NA), resid) # ok, but three outliers
plotQQunif(M2) #ok

# try a gaussian distribution with log transformed data?
M3 <- glmmTMB(log(Stems) ~ Species:(rest_status * Elevation) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)
resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3, re.form = NA), resid) # this has a trend
plotQQunif(M3) # not great but ok..?

summary(M2)

# why does this have completely different results to M2?
M4 <- glmmTMB(sqrt(Stems) ~ Species * rest_status * Elevation + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4, re.form = NA), resid) # ok, but three outliers
plotQQunif(M4)

summary(M4)
# probably because it's additionally testing for differences between species, which we don't care about, and these additional comparisons would reduce others' significance
# so don't use M4


M5 <- glmmTMB(sqrt(Stems) ~ Species : rest_status + Elevation + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)
resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5, re.form = NA), resid) # ok 1 outlier
plotQQunif(M5) # great

summary(M5)

```

```{r Stem density - natural vs restored - plot}
# dataframe for only natural data, sporobolus
stem_dens_unique_less_nat <- stem_dens_unique_less %>% subset(rest_status == 0) %>% subset(Species == "Sporobolus")
# dataframe for only restored data, sporobolus
stem_dens_unique_less_rest <- stem_dens_unique_less %>% subset(rest_status == 1) %>% subset(Species == "Sporobolus")

# plot natural sites - box plot
S_Dens_nat <- ggplot(stem_dens_unique_less_nat, aes(x=Site, y=total_stems, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  + 
  ylim(0,8000)
S_Dens_nat
# print at 700 x 789

# plot restoring sites  - box plot
S_Dens_rest <- ggplot(stem_dens_unique_less_rest, aes(x=YSR, y=total_stems, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density") +
  xlim(0,35) + 
  ylim(0,8000) 
S_Dens_rest
# print at 1500 x 789
# export at 2200 x 800 for preso, 1500 x 800 for paper

# plot natural and restored together
ggarrange(S_Dens_rest,S_Dens_nat,ncol =2,nrow=1,widths = c(4,2))
# print at 1500 x 800


# just natural vs restored
ggplot(stem_dens_unique_less, aes(x=as.factor(rest_status), y=total_stems + 0.0001, fill = Estuary)) +
    geom_boxplot() +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          strip.text = element_text(size = 28),
          legend.title = element_text(size = 20),
          legend.text = element_text(size = 20))+
  xlab("Restoration status")  + 
  ylab("Number of stems per m2") +
  facet_wrap(~Species) +
  scale_y_continuous(trans = "log10") + 
  scale_x_discrete(labels = c('Natural','Restoring'))
# print at 1200 x 800
```


# 5.5 Stem diameter

```{r Stem diameter - prep and explore}
# first, only include Sporobolus, Sarcocornia, Pneumatophores and Triglochin as these are the only species that exist in both natural and restored sites.

salt_less <- salt %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Pneumatophores", "Triglochin"))

# explore - histograms
hist(salt_less$Stem_dia_mm) # highly right skewed
hist(log(salt_less$Stem_dia_mm)) # weird but more similar to normal
hist(sqrt(salt_less$Stem_dia_mm)) # worse than log
hist(log(salt_less$Stem_dia_mm+0.2)) # more similar to normal but not sure if this sort of offset is ok

# relationship with elevation
plot(salt_less$Stem_dia_mm ~ salt_less$Elevation) # no evidence of a non-linear relationship
```

```{r Stem diameter - natural vs restored - model}
M1 <- glmmTMB(Stem_dia_mm ~ Species:(rest_status * Elevation + DomSpeciesSuperSimp + sp_prop) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# rank deficient and model convergence problem

M2 <- glmmTMB(Stem_dia_mm ~ Species:(rest_status * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# works without DomSpeciesSuperSimp in brackets
resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2, re.form = NA), resid) # extremely clumped and outliers
plotQQunif(M2) # terrible

# log
M3 <- glmmTMB(log(Stem_dia_mm) ~ Species:(rest_status * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3, re.form = NA), resid) # very clumped (likely due to the nature of the data) and lots of outliers 
plotQQunif(M3) # terrible

# sqrt
M4 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species:(rest_status * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4, re.form = NA), resid) # slightly better but not good
plotQQunif(M4) # not very good

# try different distribution type?
M7 <- glmmTMB(Stem_dia_mm ~ Species:(rest_status * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = Gamma(link = "inverse"), data = salt_less)
# 44 warnings
resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7, re.form = NA), resid) # errors
plotQQunif(M7)
# apparently infinite residuals values have been created

# no elevation interaction ,log, estuary out of brackets
M10 <- glmmTMB(log(Stem_dia_mm) ~ Species:(rest_status + Elevation + sp_prop) + DomSpeciesSuperSimp + rest_status : Estuary + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M10), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10, re.form = NA), resid) # pretty decent, still lots of outliers
plotQQunif(M10) # not good



M11 <- glmmTMB(log(Stem_dia_mm+0.2) ~ Species:(rest_status + Elevation + sp_prop) + rest_status * Estuary + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M11), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11, re.form = NA), resid) # pretty decent
plotQQunif(M11) # not good

M12 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species:(rest_status + Elevation + sp_prop) + DomSpeciesSuperSimp +(1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less) # now has an error
resid <- residuals(simulateResiduals(M12), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M12, re.form = NA), resid) # ok
plotQQunif(M12) # not terrible



M13 <- glmmTMB(log(Stem_dia_mm) ~ Species:rest_status + Elevation + Estuary * rest_status + sp_prop + DomSpeciesSuperSimp  + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M13), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13, re.form = NA), resid) # not really good
plotQQunif(M13) # not great


#M10 is probably the best we have

summary(M10)
```


```{r Stem diameter - natural vs rest - plot}
ggplot(salt_less, aes(x=as.factor(rest_status), y=Stem_dia_mm, fill = Estuary)) +
    geom_boxplot() +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          strip.text = element_text(size = 28),
          legend.title = element_text(size = 20),
          legend.text = element_text(size = 20))+
  xlab("Restoration status")  + 
  ylab("Stem diameter (mm)") +
  facet_wrap(~Species) +
  scale_x_discrete(labels = c('Natural','Restoring'))
# print at 1200 x 800
# warning about rows removed is because these are NAs (12)
```


# 5.6 Stem height

```{r Stem height - natural vs restored - prep and explore data}
# first, only include Sporobolus, Sarcocornia, Pneumatophores and Triglochin as these are the only species that exist in both natural and restored sites.

salt_less <- salt %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Pneumatophores", "Triglochin"))

# explore - histograms
hist(salt_less$Stem_ht_mm) # somewhat right skewed
hist(log(salt_less$Stem_ht_mm)) # somewhat left skewed
hist(sqrt(salt_less$Stem_ht_mm)) # normal!

# relationship with elevation
plot(salt_less$Stem_ht_mm ~ salt_less$Elevation) # could be non-linear
```

```{r Stem height - natural vs restored - model}
M1 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status * poly(Elevation,2) + DomSpeciesSuperSimp + sp_prop) + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# rank deficient and model convergence problems

M2 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status * poly(Elevation,2) + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# model convergence problems

M3 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status * poly(Elevation,2)) + sp_prop + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# model convergence problem

M4 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status * Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4, re.form = NA), resid) # pretty good, but a few outliers
plotQQunif(M4) # a little weird but ok



M5 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status + Elevation + sp_prop) + DomSpeciesSuperSimp + (1|Estuary/Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5, re.form = NA), resid) # very similar to above
plotQQunif(M5)

M6 <- glmmTMB(Stem_ht_mm ~ Species:(rest_status + Elevation + sp_prop) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# works with Estuary not a random variable and not in brackets with Species, and no interactions between variables
resid <- residuals(simulateResiduals(M6), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M6)) # ok but has a trend
plotQQunif(M6) # pretty good

# try sqrt
M7 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species:(rest_status + Elevation + sp_prop) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7, re.form = NA), resid) # fine but some outliers
plotQQunif(M7) # perfect

# try other sqrt models that have a better residuals plot?
M8 <- glmmTMB(sqrt(Stem_ht_mm) ~ Species:(rest_status + poly(Elevation,2) + sp_prop) + Estuary * rest_status + (1|Site/Site) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
# this now has a model convergence problem?
resid <- residuals(simulateResiduals(M8), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8, re.form = NA), resid) # still has a trend
plotQQunif(M8) # perfect

# log model
M9 <- glmmTMB(log(Stem_ht_mm) ~ Species:(rest_status + poly(Elevation,2) + sp_prop) + Estuary * rest_status + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)
resid <- residuals(simulateResiduals(M9), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M9)) # trend + uneven spread
plotQQunif(M9) # not good

# therefore M7 is closest to ok

summary(M7)
```


# 5.7 Reproduction


```{r Reproduction - natural vs restored - prep and explore}
# use reprod_unique created in the Reproduction YSR section above

# create a new dataframe with only Sporobolus, Sarcocornia and Triglochin (only sp. with enough data)
reprod_unique_less <- reprod_unique %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin"))

# make data longer with one row for reproduction type and another for presence/absence
reprod_all_long <- reprod_unique_less %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# now subset for only flowers and seeds since there are not enough bud data
# and remove NAs
reprod_all_long <- reprod_all_long %>% subset(!is.na(Reproduction)) %>% 
  subset(reprod_type %in% c("Flowers", "Seeds"))

# explore reproduction of different species and reproduction types in each restoration status
ggplot(data = reprod_all_long, aes(x = Reproduction, y = Species)) +
  geom_boxplot() +
  facet_wrap(~Site)
```

```{r Reproduction - natural vs restored - model}
M1 <- glmmTMB(Reproduction ~ Species:(rest_status * reprod_type + Elevation) + (1+reprod_type|Species) + (1|Estuary/Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_long)

resid <- residuals(simulateResiduals(M1), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M1)) # great
plotQQunif(M1) # great

summary(M1)

# however, when visualising the data below it's evident that there are insufficient data for natural sites for sarcocornia (only 2 quadrats, both in the same site, that have sarcocornia)

reprod_all_nosarc <- reprod_all_long %>% subset(Species %in% c("Sporobolus", "Triglochin"))

M2 <- glmmTMB(Reproduction ~ Species:(rest_status * reprod_type + Elevation) + (1|Estuary/Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_nosarc)
# it wasn't working with the additional random effect. and do we need the random effect of reproduction type|Species if these are included as fixed effects?
resid <- residuals(simulateResiduals(M2), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M2)) # not good - there are points that are far from the line
plotQQunif(M2) # good
```

```{r Reproduction - natural sites - graph}
# what is the proportion of each species at each site with each reproduction type?

reprod_all_proportions <- reprod_all_long %>% 
  group_by(Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), se = sd(Reproduction)/sqrt(n()), rest_status = mean(rest_status)) %>% 
  ungroup()

# By species
reprod_all_proportions %>%  
  subset(rest_status == 0) %>% 
  ggplot(aes(x = Site, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species)

```




#--------------

```{r Elevation rescaling makes a difference?}
salt_elev_test <- salt_H_rest_stems[,c(5:7,11,20,25,30:33,35,36)]

M1 <- lmer(sqrt(Stem_dia_mm) ~ Species * YSR * Elevation + DomSpeciesSimp + sp_prop + (1|Quadrat.f), data = salt_elev_test, na.action = na.exclude)

summary(M1)

# rescale elevation
salt_elev_test <- salt_elev_test %>% 
  mutate(Elev_rescale = scale(Elevation, center = TRUE, scale = TRUE))

M2 <- lmer(sqrt(Stem_dia_mm) ~ Species * YSR * Elev_rescale + DomSpeciesSimp + sp_prop + (1|Quadrat.f), data = salt_elev_test, na.action = na.exclude)

summary(M2)
```




The following model formats are suggested by Jamil et al. (2012) for a simple model with one trait "z" and one fixed environmental vaiable "x":

M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link=logit), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link=logit), data)

However, "y" is species presence/absence or species abundance, which is not the focus of my analysis. I want to shift the focus to the trait value and have species proportions as a driver for that.

The first model includes the interaction between trait and environment and the second model is run without the interaction term so that we can compare the two models using an ANOVA to test the trait-environment interaction:

ANOVA(M0,M1)

```{r Test - log canopy height and elevation}
M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link="logit"), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link="logit"), data)

ANOVA(M0,M1)
```

