---
title: "Saltmarsh mixed modelling"
author: "Dana Lanceman"
date: "2023-10-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R script tests different types of modelling that can be applied to our saltmarsh functional traits dataset.

# 1. Set up


```{r Load packages}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")
#install.packages("ggeffects")
#install.packages("emmeans")
#install.packages("robustlmm")
#install.packages("mvabund")
#install.packages("plyr")
#install.packages("ecostats")
#install.packages("viridis")
#install.packages("betareg")
#install.packages("ggpubr")
#install.packages("countreg", repos="http://R-Forge.R-project.org", type = "binary")

library(plyr)
library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(glmmTMB)
library(bbmle)
library(GLMMadaptive)
library(ggeffects)
library(emmeans)
library(robustlmm)
library(mvabund)
require(tweedie)
require(statmod)
library(ecostats)
library(viridis)
library(betareg)
library(ggpubr)
library(countreg)
```


```{r Get data}
# set working directory
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

# input saltmarsh data
salt <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Saltmarsh") %>% 
  arrange(Date, Time) %>% 
  mutate(Quadrat_area = Quad_length_cm^2, # add a column for quadrat area to use as an offset
    total_stems = round(Stems * 10000/Quad_length_cm^2), # add column for total stem count per 1m2 for each species to standardise stem counts for plots. Round makes it an integer.
         Buds = case_when(  # reassign Buds as a numeric variable
           Buds == "Yes" ~ 1,
           Buds == "No" ~ 0,
           Buds == "Unknown" ~ NA,
           Buds == "NA" ~ NA
         ),
         Flowers = case_when(  # reassign Flowers as a numeric variable
           Flowers == "Yes" ~ 1,
           Flowers == "No" ~ 0,
           Flowers == "Unknown" ~ NA,
           Flowers == "NA" ~ NA
         ),
        Seeds = case_when( # standardise Seeds wording
          Seeds == "Yes" ~ "Yes",
          Seeds == "Seeds" ~ "Yes",
          Seeds == "No" ~ "No",
          Seeds == "Lots" ~ "Lots",
          Seeds == "Some" ~ "Some",
          Seeds == "some" ~ "Some",
          Seeds == "Few" ~ "Few",
          Seeds == "Very few" ~ "Very few",
          Seeds == "NA" ~ NA,
          Seeds == "Unknown" ~ NA
          ),
         rest_status = case_when(
           Site == "AE" ~ as.numeric("1"),
           Site == "HS" ~ as.numeric("1"),
           Site == "TA" ~ as.numeric("1"),
           Site == "TB" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           .default = as.numeric("0"), # add a column for restoration status where 1 = restored and 0 = natural
         ),
         rest_year = case_when(
           Site == "AE" ~ as.numeric("2017"),
           Site == "HS" ~ as.numeric("2011"),
           Site == "TA" ~ as.numeric("2007"),
           Site == "TB" ~ as.numeric("2012"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "AE" ~ as.numeric("6"),
           Site == "HS" ~ as.numeric("12"),
           Site == "TA" ~ as.numeric("16"),
           Site == "TB" ~ as.numeric("11"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9") #,
           #Site == "AI" ~ as.numeric("NA"), # figure out how best to include natural sites in model when they don't have a restoration age
           #Site == "SI" ~ as.numeric("NA"),
           #Site == "VSR" ~ as.numeric("NA"),
           #Site == "MWS" ~ as.numeric("NA"),
         ))  # add a column for years since restoration
# double check with Will years for each

# Create a column for the Dominant Species in each quadrat
salt <- salt %>%
  group_by(Combo) %>% 
  mutate(
    MaxSpeciesCover = max(`Sp_cover_%`),
    DomSpecies = ifelse(100 - `Total_cover_%` > MaxSpeciesCover, "unvegetated", 
                        paste(unique(Species[`Sp_cover_%` == MaxSpeciesCover]), collapse = ", "))) %>% # Calculate the species with maximum cover for each Quadrat, and list multiple if it's a tie
  ungroup() %>%
  dplyr::select(-MaxSpeciesCover) # Remove MaxSpeciesCover colummn


# For quadrats that have ended up listing two species as jointly dominant, manually edit these to include whichever of these species is "bulkier" as dominant
# i.e. Juncus > Triglochin, Sarcocornia > GSG, Juncus > Sporobolus

salt <- salt %>% mutate(
  DomSpecies = case_when(
    DomSpecies == "Juncus_kraussii, Sporobolus" ~ "Juncus_kraussii",
    DomSpecies == "Juncus_kraussii, Triglochin" ~ "Juncus_kraussii",
    DomSpecies == "GSG, Sarcocornia" ~ "Sarcocornia",
    .default = DomSpecies
  )
)

# create a column for proportion cover of each species (species cover/overall cover)
salt <- salt %>% mutate(sp_prop = `Sp_cover_%`/`Total_cover_%`)

# reassign Quadrat as an explictly nested variable within Site
salt$Quadrat <- as.character(salt$Quadrat)
salt$Quadrat.f <- factor(interaction(salt$Site, salt$Quadrat, sep = ":"))
salt$Quadrat.f <- as.character(salt$Quadrat.f)


# load saltmarsh community composition data
salt_comm_comp <- read_excel("Data/salt_comm_comp.xlsx", sheet = "alldata")
```


```{r Create species-specific dataframes}
spor <- salt %>%
  filter(Species == "Sporobolus")

sarc <- salt %>%
  filter(Species == "Sarcocornia")

trig <- salt %>%
  filter(Species == "Triglochin")

pneu <- salt %>%
  filter(Species == "Pneumatophores")

```


Outlier removal - these were checked in the Saltmarsh_fn_traits script.

```{r Remove unrealistic outliers}
salt[443,20] <- NA # remove triglochin measurement with unrealistic stem diameter >4mm
salt[c(738:744), 20] <- NA # remove triglochin measurements with unrealistic stem diameter >4mm
salt[802,19] <- NA # remove triglochin measurement with unrealistic stem height 556mm
salt[1271,19] <- NA # remove triglochin measurement with unrealistic stem height 860mm
salt[112,20] <- NA # remove pneumatophore measurement with unrealistic diameter 1mm
salt[c(862,917),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm

trig[121,19] <- NA # this value had stem height of 556mm
trig[240,19] <- NA # this value had stem height of 860mm
trig[c(98:104),20] <- NA # these had stem diameters > 4mm
trig[78,20] <- NA # stem diameter was > 4mm
pneu[40,20] <- NA # this had stem diameter of 1mm
spor[c(283,313),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm
```


Data transformations - need to check whether these are required for these models. If so, need to check across-species assumptions.
```{r Data transformations}
# overall saltmarsh
salt$ln.canopy.ht <- log(salt$Canopy_ht_cm)

# sporobolus
spor$ln.stem.ht <- log(spor$Stem_ht_mm)
spor$sq.stem.ht <- sqrt(spor$Stem_ht_mm)
spor$ln.stem.dia <- log(spor$Stem_dia_mm + 0.01)
spor$sq.stem.dia <- sqrt(spor$Stem_dia_mm)
spor$sq.stem.dens <- sqrt(spor$total_stems)

# sarcocornia
sarc$sq.stem.dia <- sqrt(sarc$Stem_dia_mm)
sarc$sq.stem.dens <- sqrt(sarc$total_stems)

# triglochin
trig$ln.sp.cover <- log(trig$`Sp_cover_%` + 0.01)
trig$sq.stem.dia <- sqrt(trig$Stem_dia_mm)
trig$ln.stem.dens <- log(trig$total_stems)

# pneumatophores
pneu$sq.sp.cover <- sqrt(pneu$`Sp_cover_%`)
pneu$sq.stem.dens <- sqrt(pneu$total_stems)
```

Check distribution of explanatory variables
```{r Check distribution of explanatory variables}
hist(salt$YSR)
hist(log(salt$YSR))
```


Also not sure if this is needed for this particular model, but it can be useful to rescale explanatory variables so they have a constant mean of 0 and standard deviation of 1.
```{r Rescale/standardise explanatory variables}
salt$Elevation <- scale(salt$Elevation, center = TRUE, scale = TRUE)
spor$Elevation <- scale(spor$Elevation, center = TRUE, scale = TRUE)
sarc$Elevation <- scale(sarc$Elevation, center = TRUE, scale = TRUE)
trig$Elevation <- scale(trig$Elevation, center = TRUE, scale = TRUE)
pneu$Elevation <- scale(pneu$Elevation, center = TRUE, scale = TRUE)

```


Duplicate deletion - for community-level variables, there are several rows for each quadrat that are all identical. We need to remove these duplicate rows

```{r Duplicate deletion - community-level variables}
salt_comm <- salt %>% distinct(Combo, .keep_all = TRUE) 
salt_comm <- salt_comm[,-c(11:20,22,26,27,34)] # remove irrelevant rows
# turn total cover into a proportion between 0 and 1 instead of between 0 and 100
salt_comm <- salt_comm %>% mutate(total_cover_prop = `Total_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.

spor_comm <- spor %>% distinct(Combo, .keep_all = TRUE) 
spor_comm <- spor_comm[,-c(19,20,34:37)] # remove irrelevant rows

sarc_comm <- sarc %>% distinct(Combo, .keep_all = TRUE) 
sarc_comm <- sarc_comm[,-c(19,20,34)] # remove irrelevant rows

trig_comm <- trig %>% distinct(Combo, .keep_all = TRUE) 
trig_comm <- trig_comm[,-c(19,20,35)] # remove irrelevant rows

pneu_comm <- pneu %>% distinct(Combo, .keep_all = TRUE) 
pneu_comm <- pneu_comm[,-c(19,20)] # remove irrelevant rows
  
```

```{r New variables}
# turn species cover into a proportion between 0 and 1 instead of between 0 and 100
spor_comm <- spor_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.
sarc_comm <- sarc_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
trig_comm <- trig_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)

# make a simplified DomSpecies variable where rare DomSpecies are grouped together in class "other"
salt_comm <- salt_comm %>% mutate(DomSpeciesSimp = case_when(
  DomSpecies == "Sporobolus" ~ "Sporobolus",
  DomSpecies == "Sarcocornia" ~ "Sarcocornia",
  DomSpecies == "Bolboschoenus" ~ "Bolboschoenus",
  DomSpecies == "Phragmites" ~ "Phragmites",
  DomSpecies == "unvegetated" ~ "Other",
  DomSpecies == "Juncus_kraussii" ~ "Other",
  DomSpecies == "Aster" ~ "Other",
  DomSpecies == "Triglochin" ~ "Other",
  DomSpecies == "Suaeda" ~ "Other",
  DomSpecies == "Juncus_sp1" ~ "Other",
  DomSpecies == "Juncus_sp2" ~ "Other"
))


# try even simpler with DomSpeciesSuperSimp - only Sporobolus, Sarcocornia or Other
salt_comm <- salt_comm %>% mutate(DomSpeciesSuperSimp = case_when(
  DomSpeciesSimp == "Sporobolus" ~ "Sporobolus",
  DomSpeciesSimp == "Sarcocornia" ~ "Sarcocornia",
  DomSpeciesSimp == "Bolboschoenus" ~ "Other",
  DomSpeciesSimp == "Phragmites" ~ "Other",
  DomSpeciesSimp == "Other" ~ "Other"
))


```


Create datasets for just restored data and just natural data
```{r Subsetting dataframes}
salt_H <- salt %>% subset(Estuary == "Hunter")
spor_H <- spor %>% subset(Estuary == "Hunter")
sarc_H <- sarc %>% subset(Estuary == "Hunter")
trig_H <- trig %>% subset(Estuary == "Hunter")
pneu_H <- pneu %>% subset(Estuary == "Hunter")

spor_H_rest <- spor_H %>% subset(rest_status == 1)
sarc_H_rest <- sarc_H %>% subset(rest_status == 1)
trig_H_rest <- trig_H %>% subset(rest_status == 1)
pneu_H_rest <- pneu_H %>% subset(rest_status == 1)

spor_H_nat <- spor_H %>% subset(rest_status == 0)
sarc_H_nat <- sarc_H %>% subset(rest_status == 0)
trig_H_nat <- trig_H %>% subset(rest_status == 0)
pneu_H_nat <- pneu_H %>% subset(rest_status == 0)

salt_comm_rest <- salt_comm %>% subset(salt_comm$rest_status == 1)
salt_comm_nat <- salt_comm %>% subset(salt_comm$rest_status == 0)
salt_comm_rest_H <- salt_comm_rest %>% subset(salt_comm_rest$Estuary == "Hunter")
salt_comm_nat_H <- salt_comm_nat %>% subset(salt_comm_nat$Estuary == "Hunter")
salt_comm_H <- salt_comm %>% subset(salt_comm$Estuary == "Hunter")

spor_comm_H <- spor_comm %>% subset(Estuary == "Hunter")
sarc_comm_H <- sarc_comm %>% subset(Estuary == "Hunter")
trig_comm_H <- trig_comm %>% subset(Estuary == "Hunter")
pneu_comm_H <- pneu_comm %>% subset(Estuary == "Hunter")

# Hunter only, restored only 
spor_comm_H_res <- spor_comm_H %>% subset(rest_status == "1")
sarc_comm_H_res <- sarc_comm_H %>% subset(rest_status == "1")
trig_comm_H_res <- trig_comm_H %>% subset(rest_status == "1")
pneu_comm_H_res <- pneu_comm_H %>% subset(rest_status == "1")

# Hunter only, natural only 
spor_comm_H_nat <- spor_comm_H %>% subset(rest_status == "0")
sarc_comm_H_nat <- sarc_comm_H %>% subset(rest_status == "0")
trig_comm_H_nat <- trig_comm_H %>% subset(rest_status == "0")
pneu_comm_H_nat <- pneu_comm_H %>% subset(rest_status == "0")

# community composition
salt_comm_comp_H <- salt_comm_comp %>% subset(Estuary == "Hunter")
salt_comm_comp_H_res <- salt_comm_comp_H %>% subset(rest_status == "1")
salt_comm_comp_H_nat <- salt_comm_comp_H %>% subset(rest_status == "0")
```

Before running models, we need to make sure none of our dependent variables are strongly correlated. If so, we cannot include all variables in analysis.

Our dependent variables of interest are:
- 	Community composition (multivariate) (can't really test for relationships here as it's a matrix)
-   Total cover (univariate)
-   Stem density
-   Stem diameter
-   Stem height
-   Reproduction (presence/absence) (can't really test for relationships here as they're binary variables?)

Exclude variables if their correlation coefficient is >0.8 (is this correct? and what can I cite for this?)

```{r Test for correlations between dependent variables}
# correlation matrix of correlation coefficients
cor(salt[,c(9,10,19,20,27)], use = "pairwise.complete.obs") # all correlation coefficients are >0.8, therefore retain all variables

# plot correlations between variables
# plot a bunch of correlation plots at once
salt_numeric <- salt[,c(9,10,19,20,27)]
plot(salt_numeric)
```


# A. Hunter only

# 2. Simple trial models - community level

First, let's create univariate models for our community-level variables (tallest canopy height, total cover and burrows).


# 2a Tallest canopy height

Tallest canopy height
- Canopy height ~ YSR + DomSpecies + Elevation + (1|Site)

First assumption: linear relationship between predictors and response variable

```{r Tallest canopy height - check assumptions - linear relationship }
# numeric predictors are YSR and elevation
plot(salt_comm_rest_H$Canopy_ht_cm ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$Canopy_ht_cm ~ salt_comm_rest_H$Elevation) # possibly non-linear
```


```{r Tallest canopy height - model}
# try a model with polynomial variables
M1 <- lmer(Canopy_ht_cm ~ poly(YSR,2) + DomSpecies + poly(Elevation,2) + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M1)

# estimate > st error for 2nd order polynomial YSR & 1st order polynomial
# 1st order elevation is significant here, but 2nd order isn't, so remove it

M2 <- lmer(Canopy_ht_cm ~ poly(YSR,2) + DomSpecies + Elevation + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M2)

# try a model with polynomial variables and log transform
M3 <- lmer(ln.canopy.ht ~ poly(YSR,2) + DomSpecies + poly(Elevation,2) + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M3)

# remove non-significant factors - polynomial elevation

M4 <- lmer(ln.canopy.ht ~ poly(YSR,2) + DomSpecies + Elevation + (1|Site), data = salt_comm_rest_H, na.action = na.exclude)
summary(M4)
```

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Tallest canopy height - check residuals assumptions}
# try M1 
# check for collinearity between predictors
check_collinearity(M1) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M1) # roughly equal variances
qqnorm(resid(M1)) 
qqline(resid(M1)) # not great (high values diverge)

# try M2
# check for collinearity between predictors
check_collinearity(M2) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M2) # roughly equal variances 
qqnorm(resid(M2)) 
qqline(resid(M2)) # not great - similar to before

# try M3 
# check for collinearity between predictors
check_collinearity(M3) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M3) # roughly equal variances 
qqnorm(resid(M3)) 
qqline(resid(M3)) # high and low values diverge but somewhat better than non-transformed

# use log transformed rather than non-transformed
# confirm if this is good enough

# try M4
# check for collinearity between predictors
check_collinearity(M4) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M4) # good
qqnorm(resid(M4)) 
qqline(resid(M4)) # same as M3
```

```{r Tallest canopy height - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = ln.canopy.ht)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(span = 10) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
    labs(y = "Canopy height (cm)", x = "Years since restoration") +
      theme_classic()

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M4, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
  labs(y = "Tallest stem height (cm)", x = "Years since restoration") +
  theme_classic()

# natural sites boxplot
ggplot(salt_comm_nat_H, aes(x = Site, y = ln.canopy.ht)) +
  geom_boxplot() +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht)))   +
  geom_point() +
    labs(y = "Canopy height (cm)") +
  theme_classic()

# Elevation
ggplot(salt_comm_rest_H, aes(x = Elevation, y = ln.canopy.ht)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = lm) +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht))) +
    labs(y = "Canopy height (cm)", x = "Elevation (standardised)") +
      theme_classic() 
# ideally back-transform the elevation axis

# Dominant species
salt_comm_rest_H %>% 
  subset(DomSpecies %in% c("Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin")) %>% 
  ggplot(., aes(x = DomSpecies, y = ln.canopy.ht)) +
  geom_boxplot() +
    scale_y_continuous(breaks = log(pretty(exp(salt_comm$ln.canopy.ht))), labels = pretty(exp(salt_comm$ln.canopy.ht)))   +
  geom_point() +
    labs(y = "Canopy height (cm)") +
  theme_classic()
# aster, juncus, suaeda and unvegetated only have one value each so should be excluded from the plot and (maybe) model.
```


# 2b - Total cover 

Total cover
- Total cover ~ YSR + DomSpecies + Elevation 
- beta distribution (proportional data with 2 categories - cover and non cover)
- not a mixed model

```{r Total cover - Plot relationships between variables}
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$Elevation) # possibly non-linear
```


```{r Total cover - model}
# use glm with tweedie distrubution as tweedie is similar to beta distrubtion
M <- glm(total_cover_prop ~ poly(YSR,2) * DomSpecies * poly(Elevation,2), data = salt_comm_rest_H, family = tweedie(var.power=1.5, link = 0), na.action = na.exclude)
plot(M) # does not look good. regardless of var.power value. or whether YSR and elevation are included as polynomial or linear variables. or whether interactions are included or not.

# try binomial? although I don't think this is appropriate for non-integer data.
M1 <- glm(total_cover_prop ~ poly(YSR,2) * DomSpecies * poly(Elevation,2), data = salt_comm_rest_H, family = binomial(link = "logit"), na.action = na.exclude)
plot(M1) # better fit. normality still not amazing but probably ok and equal variances better.
summary(M1) # no significance throughout.

# try beta regression
M2 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) * DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
# error here - because of DomSpecies interaction

# beta regression with DomSpecies non-interacting
M3 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpecies, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M3) # crazy large cooks distance for 7, 42 and 60. This is because these plots have unusual DomSpecies. Need to discuss.

# beta regression without DomSpecies
M4 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M4) # plots generally look good, except some relatively large cook's distance values (point 7 and 69) - not sure why 69 is large as it has the same total cover as other values. 7 has extremely low total cover but it's realistic.
summary(M4)

# check whether exclusion of influential points changes parameter estimates
M5 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2), data = salt_comm_rest_H[-c(7,69),], link = "logit", na.action = na.exclude)
plot(M5) 
summary(M5)
# not massive differences in parameter estimates. Therefore hopefully OK to retain more influential values



# try DomSpeciesSimp instead that clumps rare DomSpecies into "Other"
# DomSpecies interaction is still not ok

# beta regression with DomSpecies non-interacting
M8 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M8) # now point 41 has very high cook's distnace and 7 and 69 are still high...

# try DomSpeciesSuperSimp
M9 <- betareg(total_cover_prop ~ poly(YSR,2) * poly(Elevation,2) + DomSpeciesSuperSimp, data = salt_comm_rest_H, link = "logit", na.action = na.exclude)
plot(M9) # still large cook's distance at 7, 41 and 69 but a bit better than before

```

Other assumptions (??)

```{r Total cover - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = total_cover_prop)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 10) +
    labs(y = "Total cover (proportion)", x = "Years since restoration") +
      theme_classic()
# all look very similar

# plot restoring sites  - violin plot
ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (proportion)") +
  xlim(0,35) + 
  ylim(0,1)
# print at 1500 x 789

# plot restoring sites  - box plot
S_Cov_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (proportion)") +
  xlim(0,35) + 
  ylim(0,1)
S_Cov_rest
# print at 1500 x 789
# export at 2200 x 800 for preso, 1500 x 800 for paper

# plot natural sites - violin plot
ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,1)
# print at 700 x 789

# plot natural sites - box plot
S_Cov_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=total_cover_prop, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,1)
S_Cov_nat
# print at 700 x 789

# plot natural and restored together
ggarrange(S_Cov_rest,S_Cov_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# Elevation
ggplot(salt_comm_rest_H, aes(x = Elevation, y = total_cover_prop)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = lm) +
    labs(y = "Total cover (proportion)", x = "Elevation (standardised)") +
      theme_classic() 
# looks very similar
# ideally back-transform the elevation axis
```


#2c - burrows

```{r Burrows - Plot relationships between variables}
ggplot(data = salt_comm_rest_H, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)


plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$YSR) # relatively linear
plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$Elevation) # relatively linear
```

```{r Zero-inflation testing and model approach}
# test for zero-inflation

100*sum(salt_comm_rest_H$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm_rest_H)
# 58% of our data are zeroes

# check if this number of zeroes can be predicted under a poisson model
M1 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + DomSpecies + Elevation,
          family = 'poisson',
          data = salt_comm_rest_H)
plot(M1) # plot doesn't look good

# check if this number of zeroes can be predicted under a negative binomial model
# without restoration status for now

M2 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          family = 'nbinom1',
          data = salt_comm_rest_H)
plot(M2) # plot doesn't look good

M3 <- glm(Burrows_0.5x0.5 ~ poly(YSR,2) + Elevation + DomSpecies,
          family = 'nbinom2',
          data = salt_comm_rest_H)
plot(M3) # plot doesn't look good

# try zero inflated poisson with the package pscl
M4 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H, dist = "poisson", na.action = na.exclude)
# DomSpecies is not working as an interaction so just including as a separate predictor
rootogram(M4, main = "ZIP", ylim = c(-5, 15), max = 50)
qqrplot(M4, main = "ZIP")


# also try zero-inflated negative binomial model
M5 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H, dist = "negbin", na.action = na.exclude)
rootogram(M5, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M5, main = "ZINB")


# try hurdle negative binomial model
M6 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpecies, data = salt_comm_rest_H, dist = "negbin", na.action = na.exclude)

rootogram(M6, main = "HNB", ylim = c(-5, 15), max = 50) # smooth curve indicates good fit
qqrplot(M6, main = "HNB")


# zero-inflated negative binomial model (M5) looks like the best fit.
# however https://rpubs.com/kaz_yos/pscl-2 seems to think this sort of model is best when both structural zeroes (must be zero) and sampling zeroes (could have been other numbers) are present - not sure if this is the case for my data or if it matters?
# seems like the count part of the model is most relevant for me as my quadrats have a chance of having crabs, they just didn't, whereas the zero-inflated model models what factors contribute to definitely having no crabs, which isn't really ecologically relevant.

summary(M5)
# not computing standard errors...

# try without DomSpecies to see if that's what's causing the problem.
M7 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation , data = salt_comm_rest_H, dist = "negbin", na.action = na.exclude)
rootogram(M7, main = "ZINB", ylim = c(-5, 15), max = 50)
qqrplot(M7, main = "ZINB")

summary(M7) # standard errors are produced, therefore looks like DomSpecies is causing the issue. Probably because some values of DomSpecies only have one occurrence. Should we group these into an "other vege" or something?

# interpreting model with coefficients
expCoef <- exp(coef((M7)))
expCoef <- matrix(expCoef, ncol = 2)

rownames(expCoef) <- c("(intercept)","poly(YSR,2)1","poly(YSR,2)2","Elevation","poly(YSR,2)1:Elev", "poly(YSR,2)2:Elev")
colnames(expCoef) <- c("Count_model","Zero_inflation_model")
expCoef

# trying to interpret the count model. 
# - the baseline number of crabs is 0.68.
# - one unit increase in the first "arm" of YSR polynomial corresponds to 282523 x more crabs (???)
# - one unit increase in the second "arm" of YSR polynomial corresponds to 5.2 x more crabs (non significant)
# - one unit increase in elevation corresponds to 0.2 less crabs
# - there is a positive interaction between the first "arm" of YSR and elevation
# - there is a negative interaction between the second "arm" of YSR and elevation



# try a version of M5 with DomSpeciesSimp instead

M8 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSimp, data = salt_comm_rest_H, dist = "negbin", na.action = na.exclude)
summary(M8) # still comes up with error

# Try DomSpeciesSuperSimp
M9 <- zeroinfl(Burrows_0.5x0.5 ~ poly(YSR,2)* Elevation + DomSpeciesSuperSimp, data = salt_comm_rest_H, dist = "negbin", na.action = na.exclude)
summary(M9) # now no error.
```

```{r Burrows - plot}
# Years since restoration
ggplot(salt_comm_rest_H, aes(x = YSR, y = Burrows_0.5x0.5)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(span = 10)  +
    labs(y = "Burrows", x = "Years since restoration") +
      theme_classic()

# natural only
ggplot(salt_comm_nat_H, aes(x = Site, y = Burrows_0.5x0.5)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Burrows") +
  theme_classic()

salt_comm_rest_H$Burrows_ln <- log(salt_comm_rest_H$Burrows_0.5x0.5 + 0.001)

# boxplots - restored sites
S_Bur_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=Burrows_0.5x0.5, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of burrows") +
  xlim(0,35)  + ylim(0,62)
S_Bur_rest

# boxplots - natural sites
S_Bur_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=Burrows_0.5x0.5, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,62)
S_Bur_nat

# plot natural and restored together
ggarrange(S_Bur_rest,S_Bur_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800

# predict effects of YSR when controlling for the other factors
# this plot needs work - not sure what the y axis is??
predict_YSR <- ggemmeans(M3, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T) +
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Burrows", x = "Years since restoration") +
  theme_classic() 
```


```{r Also need to test restoration status}
M4 <- glmmTMB(Burrows_0.5x0.5 ~ rest_status + Elevation + DomSpecies + (1|Site),
          family = 'nbinom2',
          data = salt_comm_H)

summary(M4)

# check dispersion issues for this model
E2 <- resid(M4, type = "pearson")
N  <- nrow(salt_comm_rest_H)
p  <- length(coef(M4))   
sum(E2^2) / (N - p)

# 1.62 = overdispersed but not too bad?
```


# 3. Simple trial models - species level

# 3a - Sporobolus

Sporobolus stem density, height and diameter

Explanatory variables:
- restoration status (binary) OR YSR (continuous), depending on the model
- Elevation (continuous)
- Site (random, nested in restoration status)
- Quadrat (for stem height and diameter, unless we average them) (random, nested in Site in restoration status)
- Dominant species (categorical)
- species proportional cover (continuous)


```{r Sporobolus continuous depedent variables - check correlations}
plot(spor_H$total_stems ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$Stem_ht_mm ~ spor_H$Stem_dia_mm) # not correlated
plot(spor_H$total_stems ~ spor_H$Stem_ht_mm) # not correlated

# therefore can model all three variables, as none are correlated
```

Should we only include Dominant Species of interest?

# 3ai. Sporobolus stem height

```{r Sporobolus stem height - initial assumptions}
hist(spor_H$Stem_ht_mm)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_ht_mm ~ spor_H$sp_prop) # potentially slightly non-linear, and clearly species proportion is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.
ggplot(spor_H, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 1) 

plot(spor_H$Stem_ht_mm ~ spor_H$Elevation) # looks non-linear
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.5)
# therefore try including these variables as non-linear predictor variables. Maybe a quadratic and cubic function respectively?

plot(spor_H$Stem_ht_mm ~ spor_H$YSR) # not sure
ggplot(spor_H, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(span = 0.8) # maybe non-linear
```


```{r Sporobolus stem height - restoration status - Model building}
# create model
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_ht)

# 3rd order polynomial elevation was non-significant, so include as a 2nd order polynomial
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M_spor_H_stem_ht)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_ht) # VIF ~ 6 (moderate collinearity) 
# species proportions and dominance are correlated here - drop one.

# drop DomSpecies predictor variable as it has the highest VIF
M <- lmer(Stem_ht_mm ~ rest_status + poly(Elevation,2) + poly(sp_prop, 2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # VIF are all <5 (low collinearity)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # not great



# try using log-transformed stem height data given that assumptions are not ok
M <- lmer(ln.stem.ht ~ rest_status + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# drop elevation 2 and 3 - only 1 is significant
M <- lmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # some VIF are >5 (moderate collinearity)

# drop species proportion as it has the highest VIF
M <- lmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

check_collinearity(M) # all VIF are <5 (low collinearity)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # not good


# try square-root transformed?
M <- lmer(sq.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # good
qqnorm(resid(M)) 
qqline(resid(M)) # still not very good. could be due to 1-inflation. try a different model type?


# try robust lmer
M2 <- rlmer(ln.stem.ht ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)

# residuals plots
plot(M2) # 
qqnorm(resid(M2)) 
qqline(resid(M2))
# still not good. Looks similar to plots made with normal lmer rather than rlmer.
```


```{r Sporobolus stem height - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  #geom_smooth(span = 1)
  stat_smooth(method="lm", se=TRUE, fill=NA,
                formula=y ~ poly(x, 2, raw=TRUE))

boxplot(spor_H$Stem_ht_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_ht_mm ~ spor_H$DomSpecies)
```




```{r Sporobolus stem height - YSR - Model building}
# create model
M_spor_H_stem_ht <- lmer(Stem_ht_mm ~ poly(YSR,2) + poly(Elevation,3) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M_spor_H_stem_ht)

# drop elevation poly 3 and YSR poly 2
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# check for collinearity between predictors
check_collinearity(M) # some VIF are >5 (moderate collinearity)

# drop DomSpecies, which has the highest VIF
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# now sp prop poly 2 is non-significant, drop it
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # looks good
qqnorm(resid(M)) 
qqline(resid(M)) # mostly ok but high values diverge.. need to decide if OK

# try log-transformed data
M <- lmer(ln.stem.ht ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # not great- high and low values diverge

# try sqrt-transformed data
M <- lmer(sq.stem.ht ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances / just one outlier/low value
qqnorm(resid(M)) 
qqline(resid(M)) # similar to log-transformed

# try robust lmer
M <- rlmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # worse than original
```


```{r Sporobolus stem height - YSR - plot}
# best model - need to see if any model is good enough though
M <- lmer(Stem_ht_mm ~ YSR + poly(Elevation,2) + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M)

ggplot(spor_H_rest, aes(x = YSR, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Sporobolus stem height", x = "Years since restoration") +
  theme_classic()

# plot predicted values of Elevation with ggeffects ggemmeans
predict_YSR <- ggemmeans(M, terms = c("Elevation [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  labs(y = "Sporobolus stem height", x = "Elevation") +
  theme_classic()
# need to de-standardise elevation scale

ggplot(spor_H_rest, aes(x = sp_prop, y = Stem_ht_mm)) +
  geom_point() +
  geom_smooth(method = lm)
```



# 3aii. Stem diameter

```{r Sporobolus stem diameter - initial assumptions}
hist(spor_H$Stem_dia_mm)
hist(spor_H$sp_prop)

# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_H$Stem_dia_mm ~ spor_H$sp_prop) # linearity is fine, but clearly sp. proportions is 1-inflated. Need to figure out if this is an issue and if there's anything I can do about it.

plot(spor_H$Stem_dia_mm ~ spor_H$Elevation) # looks fine

plot(spor_H$Stem_dia_mm ~ spor_H$YSR) # fine
```


```{r Sporobolus stem diameter - restoration status - Model building}
# create model
M <- lmer(Stem_dia_mm ~ rest_status + Elevation + DomSpecies + sp_prop + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# sp prop is clearly non-significant, drop it first
M <- lmer(Stem_dia_mm ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M) # all VIF < 5 (low collinearity)

# residuals plots
plot(M) # not equal variances / a couple outliers
qqnorm(resid(M)) 
qqline(resid(M)) # not good - high values diverge


# try using log-transformed stem diameter data given that assumptions are not ok
M <- lmer(ln.stem.dia ~ rest_status + Elevation + DomSpecies+ (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # roughly equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # still not good - probably best option though


# try square-root transformed?
M <- lmer(sq.stem.dia ~ rest_status + Elevation + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H, na.action = na.exclude)
summary(M)

# residuals plots
plot(M) # good
qqnorm(resid(M)) 
qqline(resid(M)) # still not very good. could be due to inflation. try a different model type?
```


```{r Sporobolus stem diameter - restoration status - plot}
# plot
ggplot(spor_H, aes(x = Elevation, y = Stem_dia_mm)) +
  geom_point() +
  stat_smooth(method="lm")

boxplot(spor_H$Stem_dia_mm ~ spor_H$rest_status)

boxplot(spor_H$Stem_dia_mm ~ spor_H$DomSpecies)

boxplot(spor_H$Stem_dia_mm ~ spor_H$Site)
```




```{r Sporobolus stem diameter - YSR - Model building}
# create model
M1 <- lmer(Stem_dia_mm ~ YSR + poly(Elevation,2) + DomSpecies + poly(sp_prop,2) + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M1)

# check for collinearity between predictors
check_collinearity(M1) # some VIF are >5 (moderate collinearity)

# sp_prop has slightly higher VIF, drop sp_prop
M2 <- lmer(Stem_dia_mm ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M2)

# residuals plots
plot(M2) # roughly equal variances
qqnorm(resid(M2)) 
qqline(resid(M2)) # mostly ok but high values diverge.. not great

# try log-transformed data
M3 <- lmer(ln.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M3)

# residuals plots
plot(M3) # roughly equal variances 
qqnorm(resid(M3)) 
qqline(resid(M3)) # terrible

# try sqrt-transformed data
M4 <- lmer(sq.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M4)

# residuals plots
plot(M4) # roughly equal variances
qqnorm(resid(M4)) 
qqline(resid(M4)) # not great, ok..
```


```{r Sporobolus stem diameter - YSR - plot}
# best model? but not good...
M4 <- lmer(sq.stem.dia ~ YSR + poly(Elevation,2) + DomSpecies + (1|Site) + (1|Quadrat.f), data = spor_H_rest, na.action = na.exclude)
summary(M4)

ggplot(spor_H_rest, aes(x = YSR, y = sq.stem.dia)) +
  geom_point() +
  geom_smooth(method = lm)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M4, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T,add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2) +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$ln.stem.dia)^2)), labels = pretty((spor_H_rest$ln.stem.dia)^2)) +
  labs(y = "Sporobolus stem diameter (mm)", x = "Years since restoration") +
  theme_classic()

# plot natural stem diameters
ggplot(spor_H_nat, aes(x = Site, y = ln.stem.dia)) +
  geom_boxplot() +
  geom_jitter(width=0.1) +
    scale_y_continuous(breaks = log(pretty(exp(spor_H_nat$ln.stem.dia))), labels = pretty(exp(spor_H_nat$ln.stem.dia))) +
    labs(y = "Sporobolus stem diameter (mm)", x = "Site") +
  theme_classic() 

# elevation
ggplot(spor_H_rest, aes(x = Elevation, y = ln.stem.dia)) +
  geom_point() +
  geom_smooth(span = 1)

# dominant species
ggplot(spor_H_rest, aes(x = DomSpecies, y = ln.stem.dia)) +
  geom_boxplot()  +
  geom_point() +
    labs(y = "Log stem diameter") +
  theme_classic()

# need to back-transform and label these properly
```


# 3aiii. Sporobolus stem density 
- Stem density ~ YSR + Elevation + DomSpecies + SpeciesProportion + (1|Site)
- stem density is a positive integer value so should be able to conform to a roughly normal distribution

First assumption: linear relationship between predictors and response variable

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Sporoblus stem density - initial assumptions}
# test assumptions - linear relationship between predictors and response
# numeric predictors are species proportional cover and elevation
plot(spor_comm_H$total_stems ~ spor_comm_H$sp_prop) # potentially non-linear
ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 1) +
  geom_smooth(method = lm) # polynomial is a better fit, try that first

plot(spor_comm_H$total_stems ~ spor_comm_H$Elevation) # not obviously non-linear

plot(spor_comm_H$total_stems ~ spor_comm_H$YSR) # looks potentially non-linear
ggplot(spor_comm_H, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(span = 2) +
  geom_smooth(method = lm) # non-linear is a better fit
```


```{r Sporoblus stem density - restoration status - model}
# create model
M_spor_H_stem_dens <- lmer(total_stems ~ rest_status + Elevation + DomSpecies + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_dens)

# looks like elevation and species proportion influence Sporobolus stem density, but not restoration status (exploratory plots looked like restoration status did have an influence, but older sites were similar to natural sites, so wouldn't necessarily show up in this binary model)

# create a simplified model with only the significant factors
M_spor_H_stem_dens <- lmer(total_stems ~ Elevation + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
summary(M_spor_H_stem_dens)
# elevation is no longer significant?


# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_dens) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M_spor_H_stem_dens) # equal variances assumption is not ok
qqnorm(resid(M_spor_H_stem_dens)) 
qqline(resid(M_spor_H_stem_dens)) # not great but not terrible


# try with sq stem density
M_spor_H_stem_dens <- lmer(sq.stem.dens ~ Elevation + sp_prop + (1|Site), data = spor_comm_H, na.action = na.exclude)
summary(M_spor_H_stem_dens)
# elevation is no longer significant?


# check more model assumptions
# check for collinearity between predictors
check_collinearity(M_spor_H_stem_dens) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M_spor_H_stem_dens) # not good
qqnorm(resid(M_spor_H_stem_dens)) 
qqline(resid(M_spor_H_stem_dens)) # great


# remove sp_prop from model? as it's logically correlated with stem density
M_spor_H_stem_dens <- lmer(total_stems ~ rest_status + Elevation + DomSpecies + (1|Site), data = spor_comm_H, na.action = na.exclude)
# do I need to specify nesting here or will the model figure out due to the unique labelling of factors?
summary(M_spor_H_stem_dens)

# only DomSpecies sporobolus is significant - which again makes sense as there will be more stems when it's dominant
# not really happy with any of these models..
```


```{r Sporoblus stem density - restoration status - plot}
# plot
ggplot(spor_comm_H, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$total_stems ~ spor_comm_H$rest_status)
```


```{r Sporoblus stem density - YSR - model}
M <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + poly(sp_prop,2) + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M)

# everything except DomSpecies is significant. But sp_prop should probably be excluded.

M2 <- lmer(total_stems ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M2)

# check more model assumptions
# check for collinearity between predictors
check_collinearity(M2) # all VIF are <5 (low collinearity)

# residuals plots
plot(M2) # not equal variances
qqnorm(resid(M2)) 
qqline(resid(M2)) # normality is great!

# try sqrt transform
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

plot(M3) # good
qqnorm(resid(M3)) 
qqline(resid(M3)) # a couple diverging values, but good enough
```


```{r Sporoblus stem density - YSR - plot}
# final model
M3 <- lmer(sq.stem.dens ~ poly(YSR,2) + Elevation + DomSpecies + (1|Site), data = spor_comm_H_res, na.action = na.exclude)
summary(M3)

# plot - YSR
ggplot(spor_comm_H_res, aes(x = YSR, y = sq.stem.dens)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      stat_smooth(span = 2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
      theme_classic() +
  xlim(0,35)

# plot predicted values with ggeffects ggemmeans
predict_YSR <- ggemmeans(M3, terms = c("YSR [all]"))
# view this result
print(predict_YSR)
# visualise this result
plot(predict_YSR, ci = T, add.data = TRUE, dot.alpha = 0.5,  jitter = 0.2)+
  ggtitle("") +  geom_line(size = 1.2)  +
  scale_y_continuous(breaks = sqrt(pretty((spor_H_rest$sq.stem.dens)^2)), labels = pretty((spor_H_rest$sq.stem.dens)^2)) +
  labs(y = "Sporobolus stems per square metre", x = "Years since restoration") +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

# plot restoring sites  - box plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sq.stem.dens, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 1.5) +
  geom_jitter() +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_res$sq.stem.dens)^2)), labels = pretty((spor_comm_H_res$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus stem density (stems/m2)") +
  xlim(0,35) 
# print at 1500 x 789
# export at 2200 x 800

# plot natural sites - box plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sq.stem.dens, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1) +
     scale_y_continuous(breaks = sqrt(pretty((spor_comm_H_nat$sq.stem.dens)^2)), labels = pretty((spor_comm_H_nat$sq.stem.dens)^2), limits = c(0,90)) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
# print at 700 x 789

ggplot(spor_comm_H_res, aes(x = Elevation, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = sp_prop, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)

ggplot(spor_comm_H_res, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth(method = lm)
```


# 3aiv - Sporobolus quantitative variables (multivariate)


Need to standardise these variables (centred on 0 with SD of 1) in order to model them together?

Need to account for the fact that stem density is measured at a quadrat level and stem height and diameter are measured at stem level.

```{r Sporobolus stem height diameter and density - Multivariate model}

```



# 3av - Sporobolus % species cover

Sporobolus % species cover
- Total cover ~ rest_status*YSR + Elevation + (1|Estuary) + (1|Site)
- beta distribution (proportional data with 2 categories - cover and non cover)

```{r Sporobolus species cover - model}
# when YSR has NA values, this model comes up with an error
M <- glmmTMB(sp_cover_prop ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)

# excluding restoration status (and therefore natural sites) from the model removes the error
M <- glmmTMB(sp_cover_prop ~ YSR + Elevation + Estuary + (1|YSR), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)
```


```{r sporobolus % cover univariate}
ggplot(spor_comm_H, aes(x = YSR, y = `Sp_cover_%`)) +
  geom_point() +
  geom_smooth(method = lm)

boxplot(spor_comm_H$`Sp_cover_%` ~ spor_comm_H$rest_status)
```


Other assumptions (??)


```{r Sporobolus species cover - plot}
ggplot(spor_comm_H, aes(x = YSR, y = sp_cover_prop)) +   
      geom_point(alpha = 0.5) +
    geom_smooth() + # meaningless
      theme_classic()
# older sites have consistently higher cover, compared with more varied cover at younger sites

spor_comm_H %>% subset(rest_status == "0") %>% 
  ggplot(., aes(x = Site, y=sp_cover_prop)) +
  geom_boxplot() +
  theme_classic()

# plot restoring sites  - violin plot
ggplot(spor_comm_H_res, aes(x=YSR, y=sp_cover_prop, group = YSR, fill = Estuary)) +
    geom_violin(width=1.4) +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Sporobolus species cover (proportion)") +
  xlim(0,35) +
  ylim(0,1)
# print at 1500 x 789

# plot natural sites - violin plot
ggplot(spor_comm_H_nat, aes(x=Site, y=sp_cover_prop, fill=Estuary, group = Site)) +
    geom_violin(width=0.2) +
  geom_jitter(width = 0.1)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,1)
# print at 700 x 789
```


# 3avi - Sporobous buds and flowers

Sporobolus buds and flowers - binary response variables

```{r Sporobolus buds and flowers - visualise distributions}
hist(spor_comm$Buds) # all zeroes - nothing to model
hist(spor_comm$Flowers) # almost all zeroes (only 5 quadrats with flowers) - not enough data to model
```

# 3avii - Sporobolus seeding

Sporobolus seeding - ordinal categorical response variable

```{r Sporobolus seeding - Data manipulation}
# make seeds into an ordinal variable
spor_comm$Seeds <- factor(spor_comm$Seeds, order = TRUE, levels = c("No", "Very few", "Few", "Some", "Lots"))
```

We can use the GLMMadaptive package to create a mixed model with an ordinal response variable.

Need to explore data to decide which family is most appropriate.

```{r Sporobolus seeding - model}
m_spor_seeds <- mixed_model(fixed = Seeds ~ YSR + Elevation + Estuary, random = ~ 1 | Site, 
                  data = spor_comm, family = binomial())
summary(m_spor_seeds)
```






# 3b - Sarcocornia



Sarcocornia reproduction

```{r Sarcocornia reproduction - Visualise distributions}
hist(sarc_comm$Buds) # no buds
hist(sarc_comm$Flowers) # there are occurrences of both flowers and no flowers

# make seeds a binary variable
sarc_comm <- sarc_comm %>% mutate(
  Seeds = case_when(
    Seeds == "Yes" ~ 1,
    Seeds == "No" ~ 0,
    Seeds == "Unknown" ~ NA,
    Seeds == "NA" ~ NA  
  )
)
hist(sarc_comm$Seeds) # there are occurrences of both seeds and no seeds

# are Flower and Seed presence correlated?
# see if there is a more formal way of testing this
sarc_comm$Seeds[sarc_comm$Flowers == 1] # there are 25 cases when Flowers are present. Seeds are present in 15 of these and no seeds in 8 of these.
sarc_comm$Seeds[sarc_comm$Flowers == 0] # there are 11 cases when Flowers are not present. Seeds are present in 5 of these and not present in 4 of these.
# therefore it seems like they aren't well correlated and can both be analysed
```

Need to decide whether we want to include these in a multivariate model together or have two separate models.

```{r Sarcocornia flowers - model}
m_sarc_flow <- glmmTMB(Flowers ~ YSR + Elevation + (1|Site), 
                  data = sarc_comm, family = binomial(), na.action = na.exclude)
# can't include estuary in the model as this species was only surveyed at Hunter
summary(m_sarc_flow)
```


```{r Sarcocornia seeds - model}
m_sarc_seeds <- glmmTMB(Seeds ~ YSR + Elevation + (1|Site), 
                  data = sarc_comm, family = binomial(), na.action = na.exclude)
# can't include estuary in the model as this species was only surveyed at Hunter
summary(m_sarc_seeds)
```




# 3c - Triglochin

Triglochin reproduction

```{r Triglochin reproduction - Visualise distributions}
hist(trig_comm$Buds) # there are occurrences of buds and no buds
hist(trig_comm$Flowers) # there are occurrences of both flowers and no flowers, but only about 2 occurrences of no flowers, which is not enough to analyse

# make seeds a binary variable
trig_comm <- trig_comm %>% mutate(
  Seeds = case_when(
    Seeds == "Yes" ~ 1,
    Seeds == "No" ~ 0,
    Seeds == "Unknown" ~ NA,
    Seeds == "NA" ~ NA  
  )
)
hist(trig_comm$Seeds) # there are occurrences of both seeds and no seeds

# are Bud and Seed presence correlated?
# see if there is a more formal way of testing this
trig_comm$Buds[trig_comm$Seeds == 1] # there are 12 cases when seeds are present. Buds are present in 7 of these and not present in 5 of these
trig_comm$Buds[trig_comm$Seeds == 0] # there are 21 cases when seeds are not present. Buds are present in 3 of these and not present in 18 of these.
trig_comm$Seeds[trig_comm$Buds == 1] # there are 10 cases when Buds are present. Seeds are present in 7 of these and not present in 3 of these
trig_comm$Seeds[trig_comm$Buds == 0] # there are 23 cases when Buds are not present. Seeds are present in 5 of these and not present in 18 of these.
# therefore I'm not sure if they're too correlated or not..
```




# 3d - pneumatophores




# 4. Multivariate models

Community traits

```{r Community composition}
# remove columns that only have zeroes
salt_comm_comp_H_res[,1:25] %>% colSums() # the last four columns are all zeroes
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:21,26:31)]

SaltComm <- mvabund(salt_comm_comp_H_res[,1:21])

# check out spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(salt_comm_comp_H_res[,1:21], horizontal = TRUE, las = 2, main = "Percent cover")
# large differences in variance, therefore check out mean-variance relationship

# check out mean-variance relationship
meanvar.plot(SaltComm)
# strong mean-variance relationship (close to linear but slightly curved like a negative quadratic function), therefore use a model that appropriately accounts for this

# roughly visualise data
plot(SaltComm ~ as.factor(salt_comm_comp_H_res$YSR))

# fit a tweedie model for percentage cover data
fit_cover <- manyany(SaltComm ~ YSR + Elevation, "glm", data = salt_comm_comp_H_res, family=tweedie(link = 0, var.power=1.1), var.power = 1.1)
# errors
```

Species traits

```{r Stem density}
# note, currently: STEM DENSITY MULTIPLIED OUT - NO OFFSETS
# also can't currently included species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just stem density data
stem_dens <- salt[,c(5,6,7,11,13,14,24:32)]

# remove replicates from measuring multiple stems for each species per quadrat (but only one stem density measurement)
# first create a column for every unique site/quadrat/species combination
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

# transform this to wide format with a column for each species' stem density. Not sure how this works with offsets. Let's start without and then figure out there
stem_dens_wide <- stem_dens_unique %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, rest_status, YSR, DomSpecies), names_from = Species, values_from = total_stems)

# fill NA values with zeroes
stem_dens_wide[,9:33] <- stem_dens_wide[,9:33] %>% replace(is.na(.), 0)

# subset for only Hunter and only restored
stem_dens_wide_H_res <- stem_dens_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes
stem_dens_wide_H_res[,9:33] %>% colSums() # the last four columns are all zeroes
stem_dens_wide_H_res <- stem_dens_wide_H_res[,1:29]

# set up mvabund with stem density columns - these are 9-29
stemdens_mvabund <- mvabund(stem_dens_wide_H_res[,9:29])

# look at spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(stem_dens_wide_H_res[,9:29], horizontal = TRUE, las = 2, main = "Stem density")

# look at mean-variance relationship
meanvar.plot(stemdens_mvabund) # strong linear relationship

# explore visually
plot(stemdens_mvabund ~ as.factor(stem_dens_wide_H_res$YSR), cex.axis = 0.8, cex = 0.8)

# count data so model with poisson or negative binomial distribution
stemdens_mod1 <- manyglm(stemdens_mvabund ~ YSR + Elevation + DomSpecies, data = stem_dens_wide_H_res, family = "poisson")

# check model assumptions
plot(stemdens_mod1) # NOT OK!! there is a big trend...

# try a negative binomial model
stemdens_mod2 <- manyglm(stemdens_mvabund ~ YSR + Elevation + DomSpecies, data = stem_dens_wide_H_res) # default family is negative binomial

# check model assumptions
plot(stemdens_mod2) # zero inflated but much much better!

# use model to test hypotheses
anova(stemdens_mod2)

# get more specifics
anova(stemdens_mod2, p.uni = "adjusted")

# also do I keep all the Species even though I don't care about most of them or should I subset just for the species I care about?
```


```{r Reproduction (presence/absence)}
# note: can't currently include species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just reproduction data
reprod <- salt[,c(5,6,7,11,16:18,24,25,28,30:32)]

# recode seeds as a binary presence/absence variable
reprod$Seeds %>% unique() # view unique values
reprod <- reprod %>% mutate(Seeds = case_when(
  Seeds == "No" ~ 0,
  Seeds == "Yes" ~ 1,
  Seeds == "Lots" ~ 1,
  Seeds == "Some" ~ 1,
  Seeds == "Few" ~ 1,
  Seeds == "Very few" ~ 1,
  Seeds == "NA" ~ NA
))

# only keep species that I care about (saltmarsh species)
reprod$Species %>% unique() # get list of Species
reprod <- reprod %>% filter(Species == "Sarcocornia" | Species == "Sporobolus" | Species == 
                              "Triglochin" | Species == "Suaeda" | Species == "Bolboschoenus" | Species == "Phragmites" | Species == "Juncus_kraussii" | Species == "Juncus acutus" | Species == "Juncus_sp1" | Species == "Juncus_sp2")


# remove replicates from measuring multiple stems for each species per quadrat (but only one reproduction value)
# first create a column for every unique site/quadrat/species combination
reprod$unique <- factor(interaction(reprod$Combo, reprod$Species, sep = ":"))
reprod_unique <- reprod %>% distinct(unique, .keep_all = TRUE) 

# make data longer with one row for reproduction type and another for presence/absence
reprod_long <- reprod_unique %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

# transform this to wide format with a column for each species' reproduction. 
reprod_wide <- reprod_long %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, YSR, rest_status, reprod_type, DomSpecies), names_from = Species, values_from = Reproduction)

# subset for only Hunter and only restored
reprod_wide_H_res <- reprod_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes
reprod_wide_H_res[,10:18] %>% colSums(na.rm = TRUE) # the last two columns are zeroes
reprod_wide_H_res <- reprod_wide_H_res[,1:16]

# set up mvabund with stem density columns - these are 9-29
reprod_mvabund <- mvabund(reprod_wide_H_res[,10:16])

# look at spread of data - boxplots are not ideal for binary data...
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(reprod_wide_H_res[,10:16], horizontal = TRUE, las = 2, main = "Reproduction")

# look at mean-variance relationship - not sure this is relevant for binary data...
#meanvar.plot(reprod_mvabund) 

# explore visually - hard to interpret with binary data
plot(reprod_mvabund ~ as.factor(reprod_wide_H_res$YSR), cex.axis = 0.8, cex = 0.8)

# count data so model with poisson or negative binomial distribution
# This is coming up with errors, even though all categorical variables have multiple levels. Coming up with fatal errors when I experiment removing variables.

#reprod_mod1 <- manyglm(reprod_mvabund ~ YSR + Elevation + DomSpecies + reprod_type, data = reprod_wide_H_res, family = "binomial", na.rm = TRUE)




# check model assumptions
plot(reprod_mod1) 

# use model to test hypotheses
anova(reprod_mod1)

# get more specifics
anova(reprod_mod1, p.uni = "adjusted")
```


Stem traits

Stem height - need a multivariate model so the below (half finished) code shouldn't be used
```{r Stem height}
# note: can't currently included species proportions as a predictor because you would need one row for each species.

# create a new dataframe with just stem height data
stem_height <- salt[,c(5,6,7,11,19,24,25,28,30:32,34)]

# transform this to wide format with a column for each species' stem density. Not sure how this works with offsets. Let's start without and then figure out there
stem_ht_wide <- stem_ht_unique %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Elevation, rest_status, YSR, DomSpecies), names_from = Species, values_from = Stem_ht_mm)

# don't fill NA values with zeroes - doesn't make sense for stem heights!
#stem_ht_wide[,9:33] <- stem_ht_wide[,9:33] %>% replace(is.na(.), 0)

# subset for only Hunter and only restored
stem_ht_wide_H_res <- stem_ht_wide %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

# remove columns that only have zeroes
stem_ht_wide_H_res[,9:33] %>% colSums() # the last four columns are all zeroes
stem_ht_wide_H_res <- stem_ht_wide_H_res[,1:29]

# set up mvabund with stem density columns - these are 9-29
stemht_mvabund <- mvabund(stem_ht_wide_H_res[,9:29])

# look at spread of data
par(mar = c(2, 10, 2, 2)) # adjusts the margins
boxplot(stem_ht_wide_H_res[,9:29], horizontal = TRUE, las = 2, main = "Stem height")

# look at mean-variance relationship
meanvar.plot(stemht_mvabund, na.rm = TRUE) # not working

# explore visually
plot(stemht_mvabund ~ as.factor(stem_ht_wide_H_res$YSR), cex.axis = 0.8, cex = 0.8)

# count data so model with poisson or negative binomial distribution
stemht_mod1 <- manyglm(stemht_mvabund ~ YSR + Elevation + DomSpecies, data = stem_ht_wide_H_res, family = "poisson")

# check model assumptions
plot(stemdens_mod1) # NOT OK!! there is a big trend...

# try a negative binomial model
stemdens_mod2 <- manyglm(stemht_mvabund ~ YSR + Elevation + DomSpecies, data = stem_ht_wide_H_res) # default family is negative binomial

# check model assumptions
plot(stemdens_mod2) # zero inflated but much much better!

# use model to test hypotheses
anova(stemdens_mod2)

# get more specifics
anova(stemdens_mod2, p.uni = "adjusted")
```

```{r Stem diameter}

```



--------------

The following model formats are suggested by Jamil et al. (2012) for a simple model with one trait "z" and one fixed environmental vaiable "x":

M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link=logit), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link=logit), data)

However, "y" is species presence/absence or species abundance, which is not the focus of my analysis. I want to shift the focus to the trait value and have species proportions as a driver for that.

The first model includes the interaction between trait and environment and the second model is run without the interaction term so that we can compare the two models using an ANOVA to test the trait-environment interaction:

ANOVA(M0,M1)

```{r Test - log canopy height and elevation}
M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link="logit"), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link="logit"), data)

ANOVA(M0,M1)
```

