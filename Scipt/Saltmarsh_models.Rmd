---
title: "Saltmarsh mixed modelling"
author: "Dana Lanceman"
date: "2023-10-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R script tests different types of modelling that can be applied to our saltmarsh functional traits dataset.

# 1. Set up


```{r Load packages}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")

library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(glmmTMB)
library(bbmle)
library(GLMMadaptive)
```


```{r Get data}
# set working directory
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

# input saltmarsh data
salt <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Saltmarsh") %>% 
  arrange(Date, Time) %>% 
  mutate(total_stems = Stems * 10000/Quad_length_cm^2, # add column for total stem count per 1m2 for each species to standardise stem counts
         rest_status = case_when(
           Site == "AE" ~ as.numeric("1"),
           Site == "HS" ~ as.numeric("1"),
           Site == "TA" ~ as.numeric("1"),
           Site == "TB" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           .default = as.numeric("0"), # add a column for restoration status where 1 = restored and 0 = natural
         ),
         rest_year = case_when(
           Site == "AE" ~ as.numeric("2017"),
           Site == "HS" ~ as.numeric("2008"),
           Site == "TA" ~ as.numeric("2007"),
           Site == "TB" ~ as.numeric("2012"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "AE" ~ as.numeric("6"),
           Site == "HS" ~ as.numeric("15"),
           Site == "TA" ~ as.numeric("16"),
           Site == "TB" ~ as.numeric("11"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9") #,
           #Site == "AI" ~ as.numeric("NA"), # figure out how best to include natural sites in model when they don't have a restoration age
           #Site == "SI" ~ as.numeric("NA"),
           #Site == "VSR" ~ as.numeric("NA"),
           #Site == "MWS" ~ as.numeric("NA"),
         ))  # add a column for years since restoration
# double check with Will years for each

# reassign Quadrat as an explictly nested variable within Site
salt$Quadrat <- as.character(salt$Quadrat)
salt$Quadrat.f <- factor(interaction(salt$Site, salt$Quadrat, sep = ":"))
salt$Quadrat.f <- as.character(salt$Quadrat.f)
```


```{r Create species-specific dataframes}
spor <- salt %>%
  filter(Species == "Sporobolus")

sarc <- salt %>%
  filter(Species == "Sarcocornia")

trig <- salt %>%
  filter(Species == "Triglochin")

pneu <- salt %>%
  filter(Species == "Pneumatophores")

```


Outlier removal - these were checked in the Saltmarsh_fn_traits script.

```{r Remove unrealistic outliers}
salt[443,20] <- NA # remove triglochin measurement with unrealistic stem diameter >4mm
salt[c(738-744), 20] <- NA # remove triglochin measurements with unrealistic stem diameter >4mm
salt[802,19] <- NA # remove triglochin measurement with unrealistic stem height 556mm
salt[1271,19] <- NA # remove triglochin measurement with unrealistic stem height 860mm
salt[112,20] <- NA # remove pneumatophore measurement with unrealistic diameter 1mm

trig[121,19] <- NA # this value had stem height of 556mm
trig[240,19] <- NA # this value had stem height of 860mm
trig[c(98:104),20] <- NA # these had stem diameters > 4mm
trig[78,20] <- NA # stem diameter was > 4mm
pneu[40,20] <- NA # this had stem diameter of 1mm
```


Data transformations - need to check whether these are required for these models. If so, need to check across-species assumptions.
```{r Data transformations}
# overall saltmarsh
salt$ln.canopy.ht <- log(salt$Canopy_ht_cm)

# sporobolus
spor$ln.stem.ht <- log(spor$Stem_ht_mm)
spor$ln.stem.dia <- log(spor$Stem_dia_mm + 1)
spor$sq.stem.dens <- sqrt(spor$total_stems)

# sarcocornia
sarc$sq.stem.dia <- sqrt(sarc$Stem_dia_mm)
sarc$sq.stem.dens <- sqrt(sarc$total_stems)

# triglochin
trig$ln.sp.cover <- log(trig$`Sp_cover_%` + 1)
trig$sq.stem.dia <- sqrt(trig$Stem_dia_mm)
trig$ln.stem.dens <- log(trig$total_stems)

# pneumatophores
pneu$sq.sp.cover <- sqrt(pneu$`Sp_cover_%`)
pneu$sq.stem.dens <- sqrt(pneu$total_stems)
```


Also not sure if this is needed for this particular model, but it can be useful to rescale explanatory variables so they have a constant mean of 0 and standard deviation of 1.
```{r Rescale/standardise explanatory variables}
salt$Elevation <- scale(salt$Elevation, center = TRUE, scale = TRUE)
spor$Elevation <- scale(spor$Elevation, center = TRUE, scale = TRUE)
sarc$Elevation <- scale(sarc$Elevation, center = TRUE, scale = TRUE)
trig$Elevation <- scale(trig$Elevation, center = TRUE, scale = TRUE)
pneu$Elevation <- scale(pneu$Elevation, center = TRUE, scale = TRUE)

```


Duplicate deletion - for community-level variables, there are several rows for each quadrat that are all identical. We need to remove these duplicate rows

```{r Duplicate deletion - community-level variables}
salt_comm <- salt %>% distinct(Combo, .keep_all = TRUE) 
salt_comm <- salt_comm[,-c(11:20,22,26)] # remove irrelevant rows

spor_comm <- spor %>% distinct(Combo, .keep_all = TRUE) 
spor_comm <- spor_comm[,-c(19,20,31,32)] # remove irrelevant rows

sarc_comm <- sarc %>% distinct(Combo, .keep_all = TRUE) 
sarc_comm <- sarc_comm[,-c(19,20,31)] # remove irrelevant rows

trig_comm <- trig %>% distinct(Combo, .keep_all = TRUE) 
trig_comm <- trig_comm[,-c(19,20,32)] # remove irrelevant rows

pneu_comm <- pneu %>% distinct(Combo, .keep_all = TRUE) 
pneu_comm <- pneu_comm[,-c(19,20)] # remove irrelevant rows
  
```




# 2. Simple trial models - community level

First, let's create univariate models for our community-level variables (tallest canopy height, total cover and burrows).

For now, we'll run these models without a species presence/proportions variable for simplicity. If we decide that species composition is likely affecting these variables, we could try running modified models later.


# 2a Tallest canopy height

Tallest canopy height
- Canopy height ~ YSR + Elevation + (1|Estuary) + (1|Site)

First assumption: linear relationship between predictors and response variable

```{r Tallest canopy height - check assumptions - linear relationship }
# numeric predictors are YSR and elevation
plot(salt_comm$Canopy_ht_cm ~ salt_comm$YSR) # not obviously non-linear
plot(salt_comm$Canopy_ht_cm ~ salt_comm$Elevation) # not obviously non-linear

# therefore linear relationship assumption is OK
```


```{r Tallest canopy height - model}
M <- lmer(Canopy_ht_cm ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = salt_comm, na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
# this model gives a warning message about dropping a variable unless we assign "restoration ages" to the natural sites
summary(M)

M1 <- lmer(ln.canopy.ht ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = salt_comm, na.action = na.exclude)
# check whether this model makes sense and whether rest_status:rest_year is the correct way to add rest_year as a fixed factor nested within rest_status
# this model gives a warning message about dropping a variable unless we assign "restoration ages" to the natural sites
summary(M1)
```

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Tallest canopy height - check residuals assumptions}
# check for collinearity between predictors
check_collinearity(M) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M) # doesn't look like equal variances
qqnorm(resid(M)) 
qqline(resid(M)) # not normal

# check for collinearity between predictors
check_collinearity(M1) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M1) # looks like equal variances
qqnorm(resid(M1)) 
qqline(resid(M1)) # closer to normal, but not great (high values diverge)

# confirm if this is good enough
# use log transformed rather than non-transformed
```

```{r Tallest canopy height - plot}
# plot elevation against log canopy height at each site
(mm_plot <- ggplot(salt_comm, aes(x = Elevation, y = ln.canopy.ht, colour = Estuary)) +
      facet_wrap(~Site, nrow=2) +   # a panel for each mountain range
      geom_point(alpha = 0.5) +
      theme_classic() +
      geom_line(data = cbind(salt_comm, pred = predict(M1)), aes(y = pred), size = 1) +  # adding predicted line from mixed model 
      theme(legend.position = "none",
            panel.spacing = unit(2, "lines"))  # adding space between panels
)
# looks like no relationships

(mm_plot <- ggplot(salt_comm, aes(x = Elevation, y = ln.canopy.ht, colour = Site)) +   
      geom_point(alpha = 0.5) +
      theme_classic() +
      geom_line(data = cbind(salt_comm, pred = predict(M1)), aes(y = pred), size = 1)) 
# plot elevation against log canopy height across sites - looks like no effect

(mm_plot <- ggplot(salt_comm, aes(x = YSR, y = ln.canopy.ht, colour = Estuary)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = "lm", na.rm = TRUE) +
      theme_classic()) 
# plot years since restoration against log canopy height 
```


# 2b - Total cover 

Total cover
- Total cover ~ YSR + Elevation + (1|Estuary) + (1|Site)
- beta distribution (proportional data with 2 categories - cover and non cover)


```{r Total cover - model}
# turn total cover into a proportion between 0 and 1 instead of between 0 and 100
salt_comm <- salt_comm %>% mutate(total_cover_prop = `Total_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.

# with restoration status - gives an error when YSR has NAs
M <- glmmTMB(total_cover_prop ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = salt_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)

# without restoration status - no error
M1 <- glmmTMB(total_cover_prop ~ YSR + Elevation + Estuary + (1|Site), data = salt_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M1)
```

Other assumptions (??)


```{r Total cover - plot}
(mm_plot <- ggplot(salt_comm, aes(x = Elevation, y = total_cover_prop, colour = Estuary)) +
      facet_wrap(~Site, nrow=2) +   # a panel for each mountain range
      geom_point(alpha = 0.5) +
      theme_classic() +
      geom_line(data = cbind(salt_comm, pred = predict(M)), aes(y = pred), size = 1) +  # adding predicted line from mixed model 
      theme(legend.position = "none",
            panel.spacing = unit(2, "lines"))  # adding space between panels
)

(mm_plot <- ggplot(salt_comm, aes(x = Elevation, y = total_cover_prop, colour = Site)) +   
      geom_point(alpha = 0.5) +
      theme_classic() +
      geom_line(data = cbind(salt_comm, pred = predict(M)), aes(y = pred), size = 1)) 

(mm_plot <- ggplot(salt_comm, aes(x = YSR, y = total_cover_prop)) +   
      geom_point(alpha = 0.5) +
    geom_smooth() + # meaningless
      theme_classic()) 
```

#2a - burrows

```{r Zero-inflation testing and model approach}
# test for zero-inflation

100*sum(salt_comm$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm)
# 44% of our data are zeroes

# check if this number of zeroes can be predicted under a poisson model
# without restoration status for now until we figure that out
M1 <- glmmTMB(Burrows_0.5x0.5 ~ YSR + Elevation + Estuary + (1|Site),
          family = 'poisson',
          data = salt_comm)

summary(M1)

## Check for over/underdispersion in the model
E2 <- resid(M1, type = "pearson")
N  <- nrow(salt_comm)
p  <- length(coef(M1))   
sum(E2^2) / (N - p)

# 3.79 > 1 - evidence of overdispersion

# check if this number of zeroes can be predicted under a negative binomial model
# without restoration status for now

## Check which type of negative binomial to use!!

M2 <- glmmTMB(Burrows_0.5x0.5 ~ YSR + Elevation + Estuary + (1|Site),
          family = 'nbinom1',
          data = salt_comm)

summary(M2)

## Check for over/underdispersion in the model
E2 <- resid(M2, type = "pearson")
N  <- nrow(salt_comm)
p  <- length(coef(M1))   
sum(E2^2) / (N - p)

# 0.93 < 1 therefore minor underdispersion 

M3 <- glmmTMB(Burrows_0.5x0.5 ~ YSR + Elevation + Estuary + (1|Site),
          family = 'nbinom2',
          data = salt_comm)

summary(M3)

## Check for over/underdispersion in the model
E2 <- resid(M3, type = "pearson")
N  <- nrow(salt_comm)
p  <- length(coef(M1))   
sum(E2^2) / (N - p)

# 0.82 therefore more underdispersed than the last model

# try zeroinflated poisson model
M_poisson_z <- glmmTMB(Burrows_0.5x0.5 ~ YSR + Elevation + Estuary + (1|YSR), data=salt_comm, ziformula=~1, family=poisson)
summary(M_poisson_z)

# compare the different models
AICtab(M_poisson_z, M1, M2, M3)
# lower values indicate a better model fit. M2 (negative binomial 1) has the best fit. It also had a value close to even dispersion.
```

```{r M2 - negative binomial 1 model}
M2 <- glmmTMB(Burrows_0.5x0.5 ~ YSR + Elevation + Estuary + (1|Site),
          family = 'nbinom1',
          data = salt_comm)

summary(M2)
```

Not sure how to best plot this.

```{r Also need to test restoration status}
# ideally combine within the same model, but otherwise could do a separate test like a t-test or ANOVA - make sure we test assumptions first though.

t.test(salt_comm$Burrows_0.5x0.5 ~ salt_comm$rest_status)
```


# 3. Simple trial models - species level

# 3a - Sporobolus

Sporobolus stem density 
- Stem density ~ rest_status + rest_status/YSR + Elevation + Estuary + (1|Site)
- stem density is a positive integer value so should be able to conform to a roughly normal distribution

First assumption: linear relationship between predictors and response variable

```{r Sporobolus stem density - check assumptions - linear relationship }
# numeric predictors are YSR and elevation
plot(spor_comm$total_stems ~ spor_comm$YSR) # not obviously non-linear
plot(spor_comm$total_stems ~ spor_comm$Elevation) # not obviously non-linear

# therefore linear relationship assumption is OK
```


```{r Sporobolus stem density - model}
M <- lmer(total_stems ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
# this model gives a warning message about dropping a variable unless we assign "restoration ages" to the natural sites
summary(M)

M1 <- lmer(sq.stem.dens ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, na.action = na.exclude)
# check whether this model makes sense and whether rest_status:rest_year is the correct way to add rest_year as a fixed factor nested within rest_status
# this model gives a warning message about dropping a variable unless we assign "restoration ages" to the natural sites
summary(M1)

# Hunter only
spor_comm_H <- spor_comm %>% subset(Estuary == "Hunter")

M2 <- lmer(sq.stem.dens ~ rest_status/YSR + Elevation + (1|Site), data = spor_comm_H, na.action = na.exclude)
# check whether this model makes sense and whether rest_status:rest_year is the correct way to add rest_year as a fixed factor nested within rest_status
# this model gives a warning message about dropping a variable unless we assign "restoration ages" to the natural sites
summary(M2)

# Hunter only, restored only 
spor_comm_H_res <- spor_comm_H %>% subset(rest_status == "1")

M3 <- lmer(sq.stem.dens ~ YSR + Elevation + (1|YSR), data = spor_comm_H_res, na.action = na.exclude)
# I've included YSR as a fixed and random factor as we are interested in it as a fixed numeric factor but it also represents random differences between sites. I've excluded site because it's correlated with YSR, particularly here where there are no natural sites
summary(M3)

# not sure if I can do restored only including both estuaries given that there is only one restoration site in the Maroochy estuary
```

Other assumptions:
- model residuals are normally distributed
- model residuals have equal variances
- model residuals are independent

```{r Tallest canopy height - check residuals assumptions}
# check for collinearity between predictors
check_collinearity(M) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M) # equal variances assumption is OK
qqnorm(resid(M)) 
qqline(resid(M)) # not great but not terrible

# check for collinearity between predictors
check_collinearity(M1) # VIF < 5 (low collinearity) - good.

# residuals plots
plot(M1) # looks like equal variances
qqnorm(resid(M1)) 
qqline(resid(M1)) # pretty close to normal

# confirm if this is good enough
# use sqrt transformed rather than non-transformed
```

```{r Sporobolus stem density - plot}
# plot elevation against stem density at each estuary
(mm_plot <- ggplot(spor_comm, aes(x = Elevation, y = sq.stem.dens, colour = Estuary)) +
      facet_wrap(~Estuary, nrow=2) +   # a panel for each mountain range
      geom_point(alpha = 0.5) +
      theme_classic() +
      #geom_line(data = cbind(spor, pred = predict(M1)), aes(y = pred), size = 1) +  # adding predicted line from mixed model 
      theme(legend.position = "none",
            panel.spacing = unit(2, "lines"))  # adding space between panels
)
# looks like a trend in Hunter but not Maroochy


(mm_plot <- ggplot(spor_comm, aes(x = YSR, y = sq.stem.dens, colour = Estuary)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = "lm", na.rm = TRUE) +
      theme_classic()) 
# plot years since restoration against log canopy height 


(mm_plot <- ggplot(spor_comm_H, aes(x = YSR, y = sq.stem.dens)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = "lm", na.rm = TRUE) +
      theme_classic()) 

(mm_plot <- ggplot(spor_comm_H_res, aes(x = YSR, y = sq.stem.dens)) +   
      geom_point(alpha = 0.5, na.rm = TRUE) +
      geom_smooth(method = "lm", na.rm = TRUE) +
      theme_classic()) 

spor_comm_H %>% subset(rest_status == "0") %>% 
  ggplot(., aes(x = Site, y=sq.stem.dens)) +
  geom_boxplot() +
  theme_classic()
```


Sporobolus % species cover
- Total cover ~ rest_status*YSR + Elevation + (1|Estuary) + (1|Site)
- beta distribution (proportional data with 2 categories - cover and non cover)

```{r Sporobolus species cover - model}
# turn species cover into a proportion between 0 and 1 instead of between 0 and 100
spor_comm <- spor_comm %>% mutate(sp_cover_prop = `Sp_cover_%`/100 -0.001)
# also included a tiny offset since it doesn't like values of exactly 1 - must be below 1.

# when YSR has NA values, this model comes up with an error
M <- glmmTMB(sp_cover_prop ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)

# excluding restoration status (and therefore natural sites) from the model removes the error
M <- glmmTMB(sp_cover_prop ~ YSR + Elevation + Estuary + (1|YSR), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)
```

```{r Sporobolus species cover/overall cover model}
spor_comm <- spor_comm %>% mutate(sp_cov_tot_prop = (`Sp_cover_%`/`Total_cover_%`) - 0.001 )

# when YSR has NA values, this model comes up with an error
M <- glmmTMB(sp_cov_tot_prop ~ rest_status/YSR + Elevation + Estuary + (1|Site), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)

# excluding restoration status (and therefore natural sites) from the model removes the error
M <- glmmTMB(sp_cov_tot_prop ~ YSR + Elevation + Estuary + (1|YSR), data = spor_comm, family = beta_family(link = "logit"), na.action = na.exclude)
# check whether this model makes sense and the correct way to include YSR as a fixed factor nested within rest_status
summary(M)
```


Other assumptions (??)


```{r Sporobolus species cover - plot}
(mm_plot <- ggplot(spor_comm, aes(x = YSR, y = sp_cover_prop)) +   
      geom_point(alpha = 0.5) +
    geom_smooth() + # meaningless
      theme_classic()) 
# older sites have consistently higher cover, compared with more varied cover at younger sites

spor_comm %>% subset(rest_status == "0") %>% 
  ggplot(., aes(x = Site, y=sp_cover_prop)) +
  geom_boxplot() +
  theme_classic()
```


Sporobolus seeding - ordinal categorical response variable

```{r Data manipulation}
# make seeds into an ordinal variable
spor_comm$Seeds <- factor(spor_comm$Seeds, order = TRUE, levels = c("No", "Very few", "Few", "Some", "Lots"))
```

We can use the GLMMadaptive package to create a mixed model with an ordinal response variable.

Need to explore data to decide which family is most appropriate.

```{r Sporobolus seeding - model}
m_seeds <- mixed_model(fixed = Seeds ~ YSR + Elevation + Estuary, random = ~ 1 | Site, 
                  data = spor_comm, family = binomial())
summary(m_seeds)
```


















--------------

The following model formats are suggested by Jamil et al. (2012) for a simple model with one trait "z" and one fixed environmental vaiable "x":

M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link=“logit”), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link=“logit”), data)

However, "y" is species presence/absence or species abundance, which is not the focus of my analysis. I want to shift the focus to the trait value and have species proportions as a driver for that.

The first model includes the interaction between trait and environment and the second model is run without the interaction term so that we can compare the two models using an ANOVA to test the trait-environment interaction:

ANOVA(M0,M1)

```{r Test - log canopy height and elevation}
M1 <- glmer(y ~ z + x + z:x + (1 + x|species) + (1|site), family=binomial(link="logit"), data)

M0 <- glmer(y ~ z + x +(1 + x|species) + (1|site), family=binomial(link="logit"), data)

ANOVA(M0,M1)
```

