---
title: "Mangrove models neat"
author: "Dana Lanceman"
format: html
editor: visual
---

## Mangrove functional trait modelling

This code is for analysis of mangrove functional traits analysis, analysing for associations between functional traits and time since restoration and between restoring and natural sites.

# 1. Set up

First, **load packages**.

```{r Packages}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")
#install.packages("ggeffects")
#install.packages("emmeans")
#install.packages("robustlmm")
#install.packages("viridis")
#install.packages("DHARMa)
#install.packages("lmerTest)
#install.packages("ggpubr")

library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(glmmTMB)
library(bbmle)
library(GLMMadaptive)
library(ggeffects)
library(emmeans)
library(robustlmm)
library(viridis)
library(DHARMa)
library(lmerTest)
library(ggpubr)
```

### Load and prepare data

-   using setwd() to set the working directory where the data are stored

-   "mantree" is the main mangrove dataset - for **overall quadrat and tree data**

    -   create additional columns "total_trees", "total_saplings" and "total_hollows" that take into account sampling size for visualisation purposes (standardise to 100m2)

    -   reassign Buds, Flowers_live, Flowers_dead and Fruits as numeric variables

    -   create a rest_status column that codes for the restoration status of each site (1 = restored, 0 = natural)

    -   create a rest_year column that codes for the restoration year of each restoration site

    -   create a YSR (years since restoration) column that codes for the number of years since restoration (as of 2023 when sampling was undertaken) for each restoration site

```{r Data_mangrove_tree}
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

mantree <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Mangrove_tree") %>% 
  arrange(Date, Time) %>% 
  mutate(total_trees = Trees * 100/Quadrat_size_m2, 
         total_saplings = Saplings * 100/Quadrat_size_m2,
         total_hollows = Hollows * 100/Quadrat_size_m2,
         Buds = case_when(  
           Buds == "Yes" ~ 1,
           Buds == "No" ~ 0
         ),
         Flowers_live = case_when(  
           Flowers_live == "Yes" ~ 1,
           Flowers_live == "No" ~ 0
         ),
         Flowers_dead = case_when(  
           Flowers_dead == "Yes" ~ 1,
           Flowers_dead == "No" ~ 0
         ),
         Fruits = case_when(  
           Fruits == "Yes" ~ 1,
           Fruits == "No" ~ 0
         ),
         rest_status = case_when(
           Site == "HS" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           Site == "YCW" ~ as.numeric("1"),
           Site == "CCW" ~ as.numeric("1"),
           .default = as.numeric("0"),
         ),
         rest_year = case_when(
           Site == "HS" ~ as.numeric("2011"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014"),
           Site == "CCW" ~ as.numeric("2007"),
           Site == "YCW" ~ as.numeric("2018")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "HS" ~ as.numeric("12"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9"),
           Site == "CCW" ~ as.numeric("16"),
           Site == "YCW" ~ as.numeric("5")))


mantree <- mantree %>% mutate(ln_total_trees = log(total_trees),
                              sq_total_trees = sqrt(total_trees),
                              ln_total_sap = log(total_saplings + 0.01),
                              sq_total_sap = sqrt(total_saplings))

mantree_comm <- mantree %>% distinct(Combo, .keep_all = TRUE)
mantree_comm <- mantree_comm[,-c(18:22,24)]
```

Also load **mangrove subquadrat data** - these are data from two 1 x 1 m subquadrats that were sampled within each larger 10 x 10 m or 5 x 5 m quadrat.

-   Mangrove subquadrat data are stored in the "manq" dataframe

-   create a rest_status column that codes for the restoration status of each site (1 = restored, 0 = natural)

-   create a rest_year column that codes for the restoration year of each restoration site

-   create a YSR (years since restoration) column that codes for the number of years since restoration (as of 2023 when sampling was undertaken) for each restoration site

-   create a variable for the relationship between pneumatophore height and diameter ("pneu_h_d")

-   create a subquadrat variable to label subquadrat 1 and 2 in each quadrat

```{r Data_mangrove_quadrat}
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

manq <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Mangrove_quadrat") %>% 
  arrange(Date, Time) %>% 
  filter(Pneu_dia_mm > 2.5) %>% # excluding unrealistic data point
  mutate(rest_status = case_when(
           Site == "HS" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           Site == "YCW" ~ as.numeric("1"),
           Site == "CCW" ~ as.numeric("1"),
           .default = as.numeric("0"), 
         ),
         rest_year = case_when(
           Site == "HS" ~ as.numeric("2011"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014"),
           Site == "CCW" ~ as.numeric("2007"), 
           Site == "YCW" ~ as.numeric("2018")
         ),  
         YSR = case_when(
           Site == "HS" ~ as.numeric("12"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9"),
           Site == "CCW" ~ as.numeric("16"),
           Site == "YCW" ~ as.numeric("5")),
         pneu_h_d = Pneu_ht_mm/Pneu_dia_mm, 
         Subquadrat = paste0(Combo, match(`Pneu_0.5x0.5`, unique(`Pneu_0.5x0.5`)))
         ) 
```

Also import mangrove leaf data - leaf morphology and herbivory measurements:

-   "manherb" is the mangrove leaf herbivory dataframe

    -   convert this to long format

    -   add a YSR (years since restoration) column

    -   add a rest_status (restoration status - 1 = restored and 0 = natural) column

-   "manleaf" contains leaf area and weight (dry and fresh) data

    -   add a YSR (years since restoration) column

    -   add a rest_status (restoration status - 1 = restored and 0 = natural) column

-   "manleafAI" contains additional mangrove leaf area data that was generated via a machine learning approach

    -   add a YSR (years since restoration) column

    -   add a rest_status (restoration status - 1 = restored and 0 = natural) column

    -   set up in the same format as the rest of the leaf area data

        -   rename leaf number column

        -   add additional columns corresponding to the other leaf dataframe

            -   all leaves in this dataset were measured on trees (not sapling) so code for "Tree_sapling" is "tree" for all

        -   edit Method and Measurer for rows where they included manual components

-   merge both "manleaf" and "manleafAI" datasets together into "manleaf_all"

    -   make this dataframe longer with one row per leaf

    -   then make this dataframe wider with one column per variable (area, dry weight or fresh weight)

    -   note, CC1-2 has missing data (area and fresh weight) but all other columns are complete (not including many of the Maroochy leaves, which only have areas)

-   merge manleaf_all and manherb_long to make one leaf dataset

    -   also, add elevation data (from mantree) to this dataset

```{r Data_mangrove_leaf}
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

manherb <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Mangrove_herb") 

manherb_long <- manherb %>% 
  pivot_longer(cols = c(Leaf_1, Leaf_2, Leaf_3, Leaf_4, Leaf_5), names_prefix = "Leaf_", names_to = "Leaf", values_to = "Herb_%") %>% 
  mutate(Leaf = as.double(Leaf),
         YSR = case_when(
           Site == "HS" ~ as.numeric("12"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "YCW" ~ as.numeric("5"),
           Site == "DLW" ~ as.numeric("9"),
           Site == "CCW" ~ as.numeric("16"),
         ),
         rest_status = case_when(
           Site == "AI" ~ 0,
           Site == "SI" ~ 0,
           Site == "VSR" ~ 0,
           Site == "MWS" ~ 0,
           .default = 1
         ))

manleaf <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Mangrove_leaf") %>% 
  rowwise() %>% 
  mutate(YSR = case_when(
           Site == "HS" ~ as.numeric("12"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "YCW" ~ as.numeric("5"),
           Site == "DLW" ~ as.numeric("9"),
           Site == "CCW" ~ as.numeric("16"),
         ),
         rest_status = case_when(
           Site == "AI" ~ 0,
           Site == "SI" ~ 0,
           Site == "VSR" ~ 0,
           Site == "MWS" ~ 0,
           .default = 1
         )) %>% subset(select = -Quadrat_full)

manleafAI <- read_excel("Data/leafarea_machinelearning.xlsx", sheet = "refined") %>%
  mutate(YSR = case_when(
           Site == "HS" ~ as.numeric("12"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "YCW" ~ as.numeric("5"),
           Site == "DLW" ~ as.numeric("9"),
           Site == "CCW" ~ as.numeric("16"),
         ),
         rest_status = case_when(
           Site == "AI" ~ 0,
           Site == "SI" ~ 0,
           Site == "VSR" ~ 0,
           Site == "MWS" ~ 0,
           .default = 1
         ))

manleafAIwide <- manleafAI %>% pivot_wider(id_cols = c(Estuary, Site, Quadrat, Combo, Species, Tree, YSR, rest_status), names_from = "leaf_number", values_from = "area_mm2") %>% 
  rename("Leaf_1" = "1", 
         "Leaf_2" = "2",
         "Leaf_3" = "3",
         "Leaf_4" = "4",
         "Leaf_5" = "5") %>% 
  mutate(Method = "Machine_learning",
         Measurer = "AI",
         Measure = "Area",
         Notes = "",
         Tree_sapling = "Tree") # need to specify if any of these are saplings

manleafAIwide$Measurer[c(2,9,10,15,16,21,23,25,26,29,31,34)] <- "AI + Dana"
manleafAIwide$Method[c(2,9,10,15,16,21,23,25,26,29,31,34)] <- "Machine_Learning + Scan_Manual"

manleafall <- merge(manleaf, manleafAIwide, all = TRUE)

# first, make dataset longer so there is one row for each leaf
manleafall_long <- manleafall %>% 
  pivot_longer(cols = c(Leaf_1, Leaf_2, Leaf_3, Leaf_4, Leaf_5), names_prefix = "Leaf_", names_to = "Leaf", values_to = "value")

# make dataset wider - dataset with every value
manleafall_wide <- manleafall_long %>% 
  pivot_wider(id_cols = c(Site, Combo, Quadrat, Tree, Leaf, Tree_sapling, Species, Estuary, YSR, rest_status), names_from = "Measure", values_from = "value") # column for each dry and fresh weight and area
manleafall_wide <- manleafall_wide %>% 
  mutate(dfratio = Dry_weight/Fresh_weight,
         LMA = Dry_weight/Area,
         Quadrat = as.double(Quadrat),
         Tree = as.double(Tree),
         Leaf = as.double(Leaf))

# combine with leaf herbivory dataframe

manleafandherb <- full_join(x = manleafall_wide, y = manherb_long, by = c("Estuary","Site","YSR","rest_status", "Quadrat", "Species", "Tree", "Leaf")) %>% 
  mutate(Combo = paste0(Site, Quadrat))

manleafandherb <- merge(manleafandherb, mantree_comm[,c("Combo","Elevation")], by = c("Combo"), no.dups = TRUE) %>%
  mutate(Tree_ID = paste0(Combo,Tree))

```

### Outliers

Check for outliers that are ecologically unrealistic and would have resulted from errors in the data.

Set up a function for visualising outliers:

```{r Outlier_function}
cleveland_plot <- function(vector,axislab){
  par(mfrow= c(1,2), mar = c(5,4,2,1)) # set some parameters for the plot
  boxplot(vector,  ylab = axislab)
  dotchart(vector, xlab = axislab,
         ylab = "Order of the data") 
}
```

Check outliers in mangrove tree data.

-   All seem ok except one quadrat with a large number of Trees

    -   This number is the same on the raw datasheet and photos show a very high tree density, so this seems realistic. Therefore retain.

```{r Outliers_mangrove_tree}
# mangrove tree data
cleveland_plot(mantree$Trees, "Trees") # fairly even spread, one outlier quadrat with >200 trees
cleveland_plot(mantree$Saplings, "Saplings") # right skewed, no outliers
cleveland_plot(mantree$Hollows, "Hollows") # right skewed, there are some large values but they're realistic
cleveland_plot(mantree$`Canopy_cover_%`, "`Canopy_cover_%`") # fairly even distribution, slightly left skewed
cleveland_plot(mantree$Stems, "Stems") # right skewed, some large values but realistic
cleveland_plot(mantree$DBH_cm, "DBH_cm") # right skewed, one large value but it's realistic
cleveland_plot(mantree$Basal_circ_cm, "Basal_circ_cm") # right skewed, some large values but they're realistic
cleveland_plot(mantree$Height_m, "Height_m") # even spread, no outliers
```

Check outliers in mangrove subquadrat data.

-   Propagules, vege % and algae % are almost entirely zeroes - therefore insufficient data to model, don't model.

-   There are some large pneumatophore diameter values - investigate these:

    -   pneumatophore diameter at AI 5 is 19mm. In my experience this is not a realistic value - therefore remove

    -   pneumatophore diameter at HS 1 is 17.5mm. Also seems unrealistic - remove.

    -   pneumatophore diameter at VSR 5 is 15 mm. The pneumatophores in the photo look quite thick - therefore retain.

```{r Outliers_mangrove_subquadrat}
cleveland_plot(manq$`Seedlings_<30cm_1x1`, "`Seedlings_<30cm_1x1`") # right skewed, some large values but realistic
cleveland_plot(manq$`Seedlings_30-100cm_1x1`, "`Seedlings_30-100cm_1x1`") # right skewed, some large values but realistic
cleveland_plot(manq$`Propagules_1x1`, "`Propagules_1x1`") # highly zero inflated, probably cannot model. one extreme outlier - realistic but would be a challenge
cleveland_plot(manq$`Pneu_0.5x0.5`, "`Pneu_0.5x0.5`") # pretty even spread, no outliers
cleveland_plot(manq$`Bare_%`, "`Bare_%`") # left skewed, all realistic
cleveland_plot(manq$`Litter_%`, "`Litter_%`") # right skewed, all realistic
cleveland_plot(manq$`Algae_%`, "`Algae_%`") # highly zero inflated, probably cannot model
cleveland_plot(manq$`Vege_%`, "`Vege_%`") # highly zero inflated, probably cannot model
cleveland_plot(manq$Pneu_ht_mm, "Pneu_ht_mm") # right skewed, some large values but realistic
cleveland_plot(manq$Pneu_dia_mm, "Pneu_dia_mm") # right skewed, a couple very large values - investigate
```

Check outliers in mangrove leaf data.

-   Check leaf areas:

    -   Largest areas are all for orange and red mangroves, which have bigger leaves, so makes sense.

    -   Remeasured the 15 leaves with the largest leaf areas. Replacing values of leaves where the remeasured value was very different from the original measurement (see below).

-   Check dry:fresh weight ratios to see if any measurements have been input wrong:

    -   no reason to suggest any large values are unrealistic/incorrect except 2 leaf dry weights were in the wrong order - HS2 Tree 7 Leaf 3 and 5 - swap these values as they would have been input in the wrong order, then recalculate dry:fresh ratio.

-   Investigate extreme LMA values:

    -   The large and small data points are realistic - very small LMA values are mostly saplings, and very large LMA values are likely because leaves had dried somewhat before scanning so may have shriveled a little? If there is an issue with analysis later, we can look more into these values and consider removing.

```{r Outliers_mangrove_leaf}
cleveland_plot(manleafandherb$Area, "Area") # right skewed, some large values - should be realistic but check
cleveland_plot(manleafandherb$Dry_weight, "Dry_weight") # fairly even distribution, some large values but realistic
cleveland_plot(manleafandherb$Fresh_weight, "Fresh_weight") # fairly even distribution, some large values but realistic
cleveland_plot(manleafandherb$dfratio, "dfratio") # even spread, with a few outliers on each side - check these out in case there were any mistakes in the order of weight measurements
cleveland_plot(manleafandherb$LMA, "LMA") # even spread but there are outliers - check these out
cleveland_plot(manleafandherb$`Herb_%`, "Herb_%") # right skewed, some large values but realistic
```

Now remove ecologically unrealistic outliers and replace leaf areas with recalculated areas.

```{r Outliers_remove}
# AI5 pneumatophore diameter of 19mm
manq$Pneu_dia_mm[854] <- NA
# HS1 pneumatophore diameter of 17.5mm
manq$Pneu_dia_mm[51] <- NA

#- CCW4 Orange 1 Leaf 1
manleafandherb$Area[274] <- 7952
#- CCW3 Orange1 Leaf 3, 4, 5
manleafandherb$Area[268] <- 5679
manleafandherb$Area[269] <- 6447
manleafandherb$Area[270] <- 5459
#- VSR 5 Orange 3 Leaf 4
manleafandherb$Area[967] <- 5198
#- CCW 2 Orange 1 Leaf 2, 4
manleafandherb$Area[252] <- 5334
manleafandherb$Area[254] <- 6039
#- VSR 1 Orange 2 Leaf 3, 4
manleafandherb$Area[873] <- 4925
manleafandherb$Area[874] <- 5940

manleafandherb$Dry_weight[543] # dry weight 0.311
manleafandherb$Dry_weight[550] # dry weight 0.484
# these two entries were swapped - swap these 
manleafandherb$Dry_weight[543] <- 0.484
manleafandherb$Dry_weight[550] <- 0.311
# recalculate dfratio
manleafandherb <- manleafandherb %>% mutate(dfratio = Dry_weight/Fresh_weight)
```

### Data manipulation and subsetting

Fix a couple mistakes identified in the data:

-   upon inspection of the DEM, it looks like the original RTK value (1.096) of CF3 is not accurate. Adopt the DEM value (0.732) for elevation of CF3 instead. This is probably also an overestimate due to tree cover but it's the best we have to work with.

-   there is a grey mangrove height measurement listed as 1m, which is too short to be a tree so must be a transcription error. Removing this data cell.

Create some transformed (log and sqrt) variables.

```{r Manipulation}
mantree$Elevation[11:15] <- 0.732
manq$Elevation[31:50] <- 0.732

mantree$Height_m[15] <- NA 

manq <- manq %>% mutate(ln_seedling = log(`Seedlings_30-100cm_1x1` + 0.01),
                        sq_seedling = sqrt(`Seedlings_30-100cm_1x1`))
```

Also, subset data:

-   Delete duplicate columns to create community-level dataframes: "mantree_comm" and "manq_comm"

-   Create Hunter only, grey mangrove only, restored only and natural only dataframes

-   Create trees-only dataframes for mangrove leaves

```{r Subset}

manq_comm <- manq %>% distinct(Combo,Pneu_0.5x0.5, .keep_all = TRUE)

# Hunter only
mantree_H <- mantree %>% subset(mantree$Estuary == "Hunter")
mantree_comm_H <- mantree_comm %>% subset(mantree_comm$Estuary == "Hunter")
manq_H <- manq %>% subset(manq$Estuary == "Hunter")
manq_comm_H <- manq_comm %>% subset(manq_comm$Estuary == "Hunter")
manleaf_wide_H <- manleafandherb %>% subset(manleafandherb$Estuary == "Hunter")

# Grey mangroves only
mantree_grey <- mantree %>% subset(mantree$Species == "Grey")
mantree_grey_comm <- mantree_grey %>% distinct(Combo, .keep_all = TRUE)
mantree_grey_comm <- mantree_grey_comm[,-c(18:22,24)]
mantree_grey_comm_rest <- mantree_grey_comm %>% subset(rest_status == 1)
manleaf_wide_grey <- manleafandherb %>% subset(Species == "Grey")

# restored sites only
mantree_rest <- mantree %>% subset(mantree$rest_status == 1)
mantree_comm_rest <- mantree_comm %>% subset(mantree_comm$rest_status == 1)
mantree_H_rest <- mantree_H %>% subset(mantree_H$rest_status == 1)
mantree_comm_H_rest <- mantree_comm_H %>% subset(mantree_comm_H$rest_status == 1)
manq_rest <- manq %>% subset(manq$rest_status == 1)
manq_comm_rest <- manq_comm %>% subset(manq_comm$rest_status == 1)
manq_H_rest <- manq_H %>% subset(manq_H$rest_status == 1)
manq_comm_H_rest <- manq_comm_H %>% subset(manq_comm_H$rest_status == 1)
mantree_grey_rest <- mantree_grey %>% subset(mantree_grey$rest_status == 1)
manleaf_wide_rest <- manleafandherb %>% subset(manleafandherb$rest_status == 1)
manleaf_wide_H_rest <- manleaf_wide_H %>% subset(manleaf_wide_H$rest_status == 1)
manleaf_wide_grey_rest <- manleaf_wide_grey %>% subset(rest_status == 1)

# natural sites only
mantree_nat <- mantree %>% subset(mantree$rest_status == 0)
mantree_comm_nat <- mantree_comm %>% subset(mantree_comm$rest_status == 0)
mantree_H_nat <- mantree_H %>% subset(mantree_H$rest_status == 0)
mantree_comm_H_nat <- mantree_comm_H %>% subset(mantree_comm_H$rest_status == 0)
manq_nat <- manq %>% subset(manq$rest_status == 0)
manq_comm_nat <- manq_comm %>% subset(manq_comm$rest_status == 0)
manq_H_nat <- manq_H %>% subset(manq_H$rest_status == 0)
manq_comm_H_nat <- manq_comm_H %>% subset(manq_comm_H$rest_status == 0)
mantree_grey_nat <- mantree_grey %>% subset(mantree_grey$rest_status == 0)
manleaf_wide_nat <- manleafandherb %>% subset(manleafandherb$rest_status == 0)
manleaf_wide_grey_nat <- manleaf_wide_grey %>% subset(rest_status == 0)

# mangrove leaves - trees only
manleaf_wide_t <- manleafandherb %>% subset(manleafandherb$Tree_sapling == "Tree")
manleaf_wide_H_t <- manleaf_wide_H %>% subset(manleaf_wide_H$Tree_sapling == "Tree")
manleaf_wide_rest_t <- manleaf_wide_rest %>% subset(manleaf_wide_rest$Tree_sapling == "Tree")
manleaf_wide_nat_t <- manleaf_wide_nat %>% subset(manleaf_wide_nat$Tree_sapling == "Tree")
manleaf_wide_H_rest_t <- manleaf_wide_H_rest %>% subset(manleaf_wide_H_rest$Tree_sapling == "Tree")
manleaf_wide_grey_rest_t <- manleaf_wide_grey_rest %>% subset(manleaf_wide_H_rest$Tree_sapling == "Tree") 
```

### Correlation checks

Before running models, we need to make sure none of our dependent variables are strongly correlated. If so, we cannot include all variables in analysis.

Our dependent variables of interest are:

-   Mantree variables

    -   Number of trees

    -   Number of saplings

    -   Number of hollows

    -   Canopy cover

    -   Number of stems

    -   Tree DBH

    -   Tree height

    -   Reproduction (can't test for relationships here as it's presence/absence)

-   Subquadrat variables

    -   Number of pneumatophores

    -   Pneumatophore height

    -   Pneumatophore diameter

    -   Number of seedlings

    -   Groundcover (% bare and % litter)

-   Leaf variables (note that herbivory was measured on different leaves to area, so any correlation would be at the tree level rather than the leaf level)

    -   Leaf dry matter content

    -   Leaf mass per area

    -   Leaf area

    -   Leaf herbivory

Check for correlations using a correlation matrix of correlation coefficients and by creating correlation plots.

Exclude variables if their correlation coefficient is very large (e.g. \>0.7).

-   All man_tree variables have low to moderate correlations and plots don't look very correlated except DBH and Tree height, which are correlated and have a correlation 0.68. This is just below the arbitrary threshold, so model them both for now.

-   All manq variables have low to moderate correlations except Litter and Bare which are almost completely negatively correlated - only use one of these

-   All manleaf variables have low to moderate correlations except LMA and dfratio which have a correlation of 0.71. This is somewhat high but ok to retain both.

```{r Correlations}
t <- cor(mantree[,c(13,19,20,22,27,28,29)], use = "pairwise.complete.obs") 
t

mantree_numeric <- mantree[,c(13,19,20,22,27,28,29)]
plot(mantree_numeric)

u <- cor(manq[,c(8,9,11,12,13,16,17)], use = "pairwise.complete.obs")
u

manq_numeric <- manq[,c(8,9,11,12,13,16,17)]
plot(manq_numeric)

v <- cor(manleafandherb[,c(11,14,15,17)], use = "pairwise.complete.obs")
v

manleaf_numeric <- manleafandherb[,c(11,14,15,17)]
plot(manleaf_numeric)
```

# 2. Years since restoration models

Before we create any of these models, let's inspect the data space we're working with:

-   relationship between YSR and Elevation (numeric predictors)
    -   These variables are correlated (polynomial relationship)
    -   Therefore we can't model their interaction
    -   However, given there is variability in their relationship, we can still include both terms in models.
-   relationship between YSR and Estuary
    -   don't include, as there are only 3 data points for each estuary? and the range for each estuary does not overlap much
-   relationship between Elevation and Estuary
    -   These are quite overlapping, so can include an interaction if we think it's relevant. The effect of elevation could depend on estuary so I think leave interaction in where the model runs.

```{r Predictor_association}
plot(mantree_comm_rest$Elevation ~ mantree_comm_rest$YSR)
boxplot(mantree_comm_rest$Elevation ~ mantree_comm_rest$YSR)

cor(mantree_comm_rest$YSR, mantree_comm_rest$Elevation)

boxplot(mantree_comm_rest$YSR ~ mantree_comm_rest$Estuary) 

boxplot(mantree_comm_rest$Elevation ~ mantree_comm_rest$Estuary) 

ggplot(mantree_comm_rest, aes(y = Elevation, x = YSR, color = Estuary)) +
  geom_point() 
```

The plotted association between YSR and Elevation is interesting, let's model this. We would expect that with restoration age, mangroves would accumulate sediments and therefore increase in elevation.

-   Create a model with YSR as a polynomial predictor, also controlling for Estuary and the random effect of Site

-   Check assumptions using resid and scatter.smooth and plotQQunif

    -   look fine for this dataset size

-   Test the importance of YSR by comparing models without the polynomial term and without YSR altogether using anova

-   Calculate parameter estimates and confidence intervals using emmeans

```{r Elevation_model}
M1 <- glmmTMB(Elevation ~ Estuary + poly(YSR,2) + (1|Site), data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1,re.form = NA), resid) 
plotQQunif(M1)

M <- glmmTMB(Elevation ~ Estuary + YSR + (1|Site), data = mantree_comm_rest)
M0 <- glmmTMB(Elevation ~ Estuary + (1|Site), data = mantree_comm_rest)

anova(M1,M,M0)

em <- emmeans(M1, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)))

em

plot(em)

joint_tests(M1)
```

Plot this elevation relationship.

```{r Elevation_plot}
# restoring sites YSR
m_elev_rest <- ggplot(mantree_comm_rest, aes(x=YSR, y=Elevation, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter() +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 16),
          axis.title = element_text(size = 18)) +
  xlab("Years since restoration") +
  ylab("Elevation (m)") +
  xlim(0,35) +
  scale_y_continuous(limits = c(-0.45,0.9), breaks = scales::pretty_breaks(n = 6))
m_elev_rest
# print 1500 x 729

# natural sites
m_elev_nat <- ggplot(mantree_comm_nat, aes(x=Site, y=Elevation, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(width = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = c(.5, .15),
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16),
          axis.text = element_text(size = 16),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 18)) +
  xlab("Site") +
  ylab("") +
  scale_y_continuous(limits = c(-0.45,0.9), breaks = scales::pretty_breaks(n = 6))
m_elev_nat
# print at 700 x 789

# plot natural and restored together
ggarrange(m_elev_rest,m_elev_nat,ncol =2,nrow=1,widths = c(1.3,1))
# print at 1500 x 1200 or 2400 x 800 for preso

#ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Mangrove_elev_doc.jpg", width = 2400, height = 1500, units = "px")
```

Also, investigate the occurrence of each species at restoration sites.

-   There are only 2 sites with River mangroves and 2 sites with orange mangroves - therefore insufficient data to analyse the effect of time since restoration on either of these species - therefore only model the effect of YSR on grey mangroves. This affects the following traits:

    -   number of stems

    -   DBH

    -   height

    -   reproduction

    -   leaf traits

```{r Species}
mantree_rest %>% group_by(Site) %>% count(Species)
```

## 2a. Number of trees

First, prepare and explore the data (note, use total_trees for visualisation and Trees with the offset for quadrat area for modelling):

-   Use a histogram to visualise the distribution of total_trees

-   Plot relationships between total trees and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(mantree_comm_rest$total_trees) #  right skewed

ggplot(mantree_comm_rest, aes(x = YSR, y = total_trees, color = Estuary)) +
  geom_smooth(method = "lm") +
  geom_point() # not obviously non-linear

plot(mantree_comm_rest$total_trees ~ mantree_comm_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   It's count data, so first try a poisson distribution, and if this isn't good, can also try a negative binomial distribution.

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Include an offset for Quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M2.1 <- glmmTMB(Trees ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M2.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2.1,re.form = NA), resid) 
scatter.smooth(predict(M2.1,re.form = NA), abs(resid)) 
plotQQunif(M2.1)

# this model is actually ok for the residuals plot, just a low number of points. QQ plot doesn't look good though

M2.2 <- glmmTMB(Trees ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M2.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2.2,re.form = NA), resid) 
scatter.smooth(predict(M2.2,re.form = NA), abs(resid)) 
plotQQunif(M2.2)

# these residuals are also probably ok, the potential trends are just because of the low number of data points. QQ plot looks good this time. So this model looks better than the poisson

M <- glmmTMB(Trees ~ Elevation + Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
check_collinearity(M) # all low

anova(M2.1,M2.2) # negative binomial is a much better fit

# without elevation
M2.3 <- glmmTMB(Trees ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M2.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2.3,re.form = NA), resid) 
scatter.smooth(predict(M2.3,re.form = NA), abs(resid)) 
plotQQunif(M2.3)
# I think the residuals are fine despite the weird looking curve..

M2.4 <- glmmTMB(Trees ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M2.4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2.4,re.form = NA), resid) 
scatter.smooth(predict(M2.4,re.form = NA), abs(resid)) 
plotQQunif(M2.4)
# worse
```

Next, test the model:

-   use anova to test the model against a null model without YSR to test the importance of YSR

```{r Model_testing}
M2.2 <- glmmTMB(Trees ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
M0 <- glmmTMB(Trees ~ Elevation * Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

anova(M0,M2.2)

M2.3 <- glmmTMB(Trees ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
M0 <- glmmTMB(Trees ~ Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

anova(M0,M2.3)

em <- emmeans(M2.2, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")

em

plot(em)

joint_tests(M2.2)
```

Finally, plot the results.

```{r Plot}
emmip(M2.2, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of trees per 10m2", offset = log(100))

emmip(M2.3, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of trees per 10m2", offset = log(100))

# restoring sites YSR
m_tree_rest <- ggplot(mantree_comm_rest, aes(x=YSR, y=total_trees, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter() +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of trees per 100m2") +
  xlim(0,35) 
m_tree_rest
# print 1500 x 729

# natural sites
m_tree_nat <- ggplot(mantree_comm_nat, aes(x=Site, y=total_trees, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(width = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.text = element_text(size = 20),
          legend.title = element_text(size = 24),
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") 
m_tree_nat
# print at 700 x 789

# plot natural and restored together
ggarrange(m_tree_rest,m_tree_nat,ncol =2,nrow=1,widths = c(1.3,1))
# print at 1500 x 1200 or 2400 x 800 for preso
```

## 2bi. Number of saplings

First, prepare and explore the data.

-   Use "total_saplings" for plotting purposes and "Saplings" with offset of Quadrat_size_m2 for models

```{r Prep/explore}
ggplot(mantree_comm_rest, aes(x = total_saplings)) +   
  geom_histogram()  # somewhat right skewed (count data)

ggplot(mantree_comm_rest, aes(x = YSR, y = total_saplings)) +
  geom_smooth(method = "lm") +
  geom_point() # looks non-linear

plot(mantree_comm_rest$total_saplings ~ mantree_comm_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   Count data so use a poisson or negative binomial model

-   Include YSR as a polynomial term

-   Include Estuary \* Elevation as additional fixed predictors

-   Include Site as a random factor

-   Include an offset for Quadrat_size_m2

```{r Model_building}

M3.1 <- glmmTMB(total_saplings ~ Estuary * Elevation + poly(YSR, 2) + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson",data = mantree_comm_rest)  

resid <- residuals(simulateResiduals(M3.1), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.1, re.form = NA), resid)  
plotQQunif(M3.1)  # looks weird  

M3.2 <- glmmTMB(total_saplings ~ Estuary * Elevation + poly(YSR, 2) + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)  

resid <- residuals(simulateResiduals(M3.2), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.2, re.form = NA), resid)  
plotQQunif(M3.2)  # looks better  

anova(M3.1,M3.2) # M3.2 looks better and has a singificantly lower AIC, therefore use M3.2 

# check collinearity on model without interactions
M0 <- glmmTMB(total_saplings ~ Estuary + Elevation + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)
check_collinearity(M0)

# try with no elevation
M3.3 <- glmmTMB(total_saplings ~ Estuary + poly(YSR, 2) + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)  

resid <- residuals(simulateResiduals(M3.3), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.3, re.form = NA), resid)  
plotQQunif(M3.3)
```

Next, test the model.

-   Use an anova to test it against two null models that lack the polynomial YSR and lack YSR altogether

```{r Model_testing}
M3.2 <- glmmTMB(Saplings ~ Estuary * Elevation + poly(YSR, 2) + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)

M <- glmmTMB(Saplings ~ Estuary * Elevation + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)

M0 <- glmmTMB(Saplings ~ Estuary * Elevation + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest)

anova(M3.2,M,M0)  

M3.3 <- glmmTMB(total_saplings ~ Estuary + poly(YSR, 2) + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest) 

M1 <- glmmTMB(total_saplings ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest) 

M00 <- glmmTMB(total_saplings ~ Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2",data = mantree_comm_rest) 

anova(M3.3,M1,M00)

joint_tests(M3.2)  

summary(M3.2)  

em <- emmeans(M3.2, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response", offset = log(100))  

em  

plot(em)
```

Finally, plot the results.

```{r Plot}
emmip(M3.2, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, offset = log(100)) +    
  geom_boxplot(data = mantree_comm_rest, aes(x = YSR, y = total_saplings, group = YSR)) 

# restoring sites YSR
m_sap_rest <- ggplot(mantree_comm_rest, aes(x=YSR, y=total_saplings, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter() +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of saplings per 100m2") +
  xlim(0,35) +
  ylim(0,450)
m_sap_rest

# natural sites
m_sap_nat <- ggplot(mantree_comm_nat, aes(x=Site, y=total_saplings, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(width = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = c(0.7,0.9),
          legend.text = element_text(size = 20),
          legend.title = element_text(size = 24),
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,450)
m_sap_nat

# plot natural and restored together
ggarrange(m_sap_rest,m_sap_nat,ncol =2,nrow=1,widths = c(1.2,1))

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Mangrove_saplings.jpg", width = 4000, height = 2500, units = "px")

ggarrange(m_sap_rest,m_sap_nat,ncol =2,nrow=1,widths = c(3,2.2))

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Mangrove_saplings_preso.jpg", width = 4000, height = 2500, units = "px")
```

## 2bii. Number of small seedlings

First, explore the data.

```{r Prep/explore}
ggplot(manq_comm_rest, aes(x = `Seedlings_<30cm_1x1`)) +   
  geom_histogram()  # very right skewed (count data)

ggplot(manq_comm_rest, aes(x = YSR, y = `Seedlings_<30cm_1x1`)) +
  geom_smooth(method = "lm") +
  geom_point() # looks linear

plot(manq_comm_rest$`Seedlings_<30cm_1x1` ~ manq_comm_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   Count data so use a poisson or negative binomial model

-   Include YSR as a linear term

-   Include Estuary \* Elevation as additional fixed predictors

-   Include Quadrat (Combo) within Site as a random factor

```{r Model_building}
M3.3 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "poisson")

resid <- residuals(simulateResiduals(M3.3), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.3, re.form = NA), resid)  
plotQQunif(M3.3)  # looks good  

M3.4 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

resid <- residuals(simulateResiduals(M3.4), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.4, re.form = NA), resid)  
plotQQunif(M3.4)  # looks similar  

anova(M3.3,M3.4) # M3.4 has significantly lower AIC so use it

# check collinearity on model without interactions
M0 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2")
check_collinearity(M0)

# without elevation
M3.5 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

resid <- residuals(simulateResiduals(M3.5), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.5, re.form = NA), resid)  
plotQQunif(M3.5) 
```

Next, test the model.

-   Use an anova to test it against a model that lacks YSR

```{r Model_testing}
M3.4 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

M0 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * Elevation + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

anova(M3.4,M0)  

M3.5 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

M00 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

anova(M3.5,M00)  

joint_tests(M3.4)  

summary(M3.4)  

em <- emmeans(M3.4, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")  

em  

plot(em)
```

Finally, plot the results.

```{r Plot}
emmip(M3.4, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE) +    
  geom_boxplot(data = manq_comm_rest, aes(x = YSR, y = `Seedlings_<30cm_1x1`, group = YSR)) 

# restoring sites YSR
m_sseed_rest <- ggplot(manq_comm_rest, aes(x=YSR, y=`Seedlings_<30cm_1x1`, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter(height = 0) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of small seedlings per m2") +
  xlim(0,35) +
  ylim(0,150)
m_sseed_rest

# natural sites
m_sseed_nat <- ggplot(manq_comm_nat, aes(x=Site, y=`Seedlings_<30cm_1x1`, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(height = 0, width = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.text = element_text(size = 20),
          legend.title = element_text(size = 24),
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,150)
m_sseed_nat

# plot natural and restored together
ggarrange(m_sseed_rest,m_sseed_nat,ncol =2,nrow=1,widths = c(1.2,1))
```

## 2biii. Number of medium seedlings

First, explore the data.

```{r Prep/explore}
ggplot(manq_comm_rest, aes(x = `Seedlings_30-100cm_1x1`)) +   
  geom_histogram()  # very right skewed (count data)

ggplot(manq_comm_rest, aes(x = YSR, y = `Seedlings_30-100cm_1x1`)) +
  geom_smooth(method = "lm") +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2)) +
  geom_point() # looks roughly linear

plot(manq_comm_rest$`Seedlings_30-100cm_1x1` ~ manq_comm_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   Count data so use a poisson or negative binomial model

-   Include YSR as a linear term

-   Include Estuary \* Elevation as additional fixed predictors

-   Include Quadrat (Combo) within Site as a random factor

```{r Model_building}
M3.5 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "poisson")

resid <- residuals(simulateResiduals(M3.5), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.5, re.form = NA), resid)  
plotQQunif(M3.5)  # residuals plot looks a bit weird, qq plot looks good  

M3.6 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

resid <- residuals(simulateResiduals(M3.6), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.6, re.form = NA), resid)  
plotQQunif(M3.6)  # residuals plot looks a bit weird, qq plot looks good

anova(M3.5,M3.6) # M3.6 is better so use that. I think the residuls plot is acceptable.

# check collinearity on model without interactions
M0 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2")
check_collinearity(M0)

# without elevation

M3.7 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

resid <- residuals(simulateResiduals(M3.7), quantileFunction = qnorm, outlierValues = c(-7,7)) 
scatter.smooth(predict(M3.7, re.form = NA), resid)  
plotQQunif(M3.7)
```

Next, test the model.

```{r Model_testing}
M3.6 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

M0 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary * Elevation + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

anova(M3.6,M0) 

M3.7 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

M00 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2") 

anova(M3.7,M00) 

joint_tests(M3.6)  

summary(M3.6)  

em <- emmeans(M3.6, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")  

em  

plot(em)
```

## 2c. Number of hollows

First, prepare and explore the data.

-   histogram to plot distribution of data

-   plot relationship with quantitative variables

-   boxplot to visualise \# hollows at each YSR

```{r Prep/explore}
hist(mantree_comm_rest$total_hollows) # highly right skewed, zero-inflated

plot(mantree_comm_rest$total_hollows ~ mantree_comm_rest$YSR) # not obviously non-linear
plot(mantree_comm_rest$total_hollows ~ mantree_comm_rest$Elevation) # not obviously non-linear

boxplot(mantree_comm_rest$total_hollows ~ mantree_comm_rest$YSR)
```

Next, create a model.

-   count data so use poisson or negative binomial model

    -   or use a zero-inflated model if these can't account for excessive zeroes

-   Include additional fixed predictor Elevation \* Estuary and random factor Site

-   Include offset for quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

    -   residuals plots appear fan-shaped, but I think this is because there are less data on one end, so, for example with one data point, there is guaranteed to be less variability. Either of the negative binomial models look good

```{r Model_building}
M4.1 <- glmmTMB(Hollows ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M4.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4.1,re.form = NA), resid) 
plotQQunif(M4.1)


M4.2 <- glmmTMB(Hollows ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M4.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4.2,re.form = NA), resid) 
plotQQunif(M4.2)

M <- glmmTMB(Hollows ~ Elevation + Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
check_collinearity(M)

M4.3 <- glmmTMB(Hollows ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", ziformula = ~1, data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M4.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4.3,re.form = NA), resid) 
plotQQunif(M4.3)


M4.4 <- glmmTMB(Hollows ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", ziformula = ~1, data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M4.4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4.4,re.form = NA), resid) 
plotQQunif(M4.4)

# negative binomial models look best - check if there is evidence of a difference between these and compared to the poisson models
anova(M4.1,M4.3,M4.2,M4.4)
# this does show the negative binomial models are better than the poisson models
# given there's no difference between the two negative binomial models, use the simpler (non-zero-inflated) model - M4.2

# try without elevation
M4.21 <- glmmTMB(Hollows ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M4.21), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4.21,re.form = NA), resid) 
plotQQunif(M4.21)
# plots look good
```

Next, test the model.

-   Compare model with a null model (without YSR) to test for the importance of YSR

```{r Model_testing}
M4.2 <- glmmTMB(Hollows ~ Elevation * Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
M0 <- glmmTMB(Hollows ~ Elevation * Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

anova(M4.2, M0)

em <- emmeans(M4.2, ~ YSR, at = list(YSR = c(5:33)), type = "response")

em

plot(em) 

joint_tests(M4.2)

# without elevation
M4.21 <- glmmTMB(Hollows ~ Estuary + YSR + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)
M0 <- glmmTMB(Hollows ~ Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm_rest)

anova(M4.21, M0)

em <- emmeans(M4.21, ~ YSR, at = list(YSR = c(5:33)), type = "response")

em

plot(em) 

joint_tests(M4.21)
```

Finally, plot the results.

```{r Plot}
emmip(M4.2, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of hollows per 10m2", offset = log(100)) +
  geom_boxplot(data = mantree_comm_rest, aes(x = YSR, y = total_hollows, group = YSR))
```

## 2d. Canopy cover

First, prepare and explore the data.

-   histogram to plot distribution

-   plot distributions between dependent variable and quantitative predictors

-   create a canopy cover proportion variable by scaling it back to 0-1

```{r Prep/explore}
hist(mantree_comm_rest$`Canopy_cover_%`) # slightly left skewed but ok / kind of close to uniform distribution

plot(mantree_comm_rest$`Canopy_cover_%` ~ mantree_comm_rest$YSR) # could be non-linear
plot(mantree_comm_rest$`Canopy_cover_%` ~ mantree_comm_rest$Elevation) # not obviously non-linear

mantree_comm_rest <- mantree_comm_rest %>% 
  mutate(Canopy_cover_prop = `Canopy_cover_%`/100)
```

Next, create a model.

-   It's proportion data, so use a beta distribution

-   Include other fixed predictors Estuary and Elevation and random factor Site

-   Don't need an offset here because the variable is a percentage rather than a number

-   Check assumptions using resid and scatter.smooth and plotQQunif, and check_collinearity on a model without interactions

    -   residuals plot looks slightly fan shaped, but this is likely due to less data on the RHS, so should be fine

```{r Model_building}
M5 <- glmmTMB(Canopy_cover_prop ~ Estuary * Elevation + poly(YSR, 2) + (1|Site), family = "beta_family", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5,re.form = NA), resid) 
plotQQunif(M5) 

M <- glmmTMB(Canopy_cover_prop ~ Estuary + Elevation + YSR + (1|Site), family = "beta_family", data = mantree_comm_rest)

check_collinearity(M)

# without elevation
M5.2 <- glmmTMB(Canopy_cover_prop ~ Estuary + poly(YSR, 2) + (1|Site), family = "beta_family", data = mantree_comm_rest)

resid <- residuals(simulateResiduals(M5.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5.2,re.form = NA), resid) 
plotQQunif(M5.2) 
```

Next, test the model.

-   compare the model against null models without the polynomial term and without YSR entirely to test the importance of YSR

```{r Model_testing}
M <- glmmTMB(Canopy_cover_prop ~ Estuary * Elevation + YSR + (1|Site), family = "beta_family", data = mantree_comm_rest)
M0 <- glmmTMB(Canopy_cover_prop ~ Estuary * Elevation + (1|Site), family = "beta_family", data = mantree_comm_rest)

anova(M5, M, M0)

M5.2 <- glmmTMB(Canopy_cover_prop ~ Estuary + poly(YSR, 2) + (1|Site), family = "beta_family", data = mantree_comm_rest)
M <- glmmTMB(Canopy_cover_prop ~ Estuary + YSR + (1|Site), family = "beta_family", data = mantree_comm_rest)
M0 <- glmmTMB(Canopy_cover_prop ~ Estuary + (1|Site), family = "beta_family", data = mantree_comm_rest)

anova(M5.2,M,M0)

joint_tests(M5)

summary(M5)

emmeans(M5, ~ YSR | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M5, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Canopy cover (proportion)")

emmip(M5, ~ YSR | Estuary, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Canopy cover  (proportion)")
# note this range of data are not available for both estuaries
```

## 2e. Number of stems

First, prepare and explore the data.

-   histogram for distribution of data

-   plot relationship with quantitative predictors

```{r Prep/explore}
hist(mantree_grey_rest$Stems) # highly right-skewed, 1 inflated

ggplot(mantree_grey_rest, aes(x = YSR, y = Stems)) +
  geom_point() # not obviously non-linear

ggplot(mantree_grey_rest, aes(x = Elevation, y = Stems)) +
  geom_point() # not obviously non-linear
```

Next, create a model.

-   It's count data so use a poisson or negative binomial distribution

-   Include additional fixed predictors Estuary and Elevation

-   Include random effect for quadrat (Combo) nested in Site

-   When comparing the models, there was no significant difference, but M6.1 has lower AIC, so use that

    -   The qq plot looks a little weird, but there is a big enough sample size that the model should be robust to breaches of normality. The residuals plots look fine.

```{r Model_building}
M6.1 <- glmmTMB(Stems ~ Estuary * Elevation + YSR + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M6.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6.1,re.form = NA), resid) 
plotQQunif(M6.1)

M6.2 <- glmmTMB(Stems ~ Estuary * Elevation + YSR + (1|Site/Combo), family = "nbinom2", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M6.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6.2,re.form = NA), resid) 
plotQQunif(M6.2)

anova(M6.1,M6.2)

# check collinearity on model without interactions
M0 <- glmmTMB(Stems ~ Estuary + Elevation + YSR + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)
check_collinearity(M0)

# without elevation
M6.3 <- glmmTMB(Stems ~ Estuary + YSR + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M6.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M6.3,re.form = NA), resid) 
plotQQunif(M6.3)
```

Next, test the model.

```{r Model_testing}
M0 <- glmmTMB(Stems ~ Estuary + Elevation + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)

anova(M6.1, M0)

joint_tests(M6.1)

M6.3 <- glmmTMB(Stems ~ Estuary + YSR + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)
M0 <- glmmTMB(Stems ~ Estuary + (1|Site/Combo), family = "poisson", data = mantree_grey_rest)

anova(M6.3, M0)
```

Finally, plot the results.

```{r Plot}
emmip(M6.1, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of stems")
```

## 2f. Tree DBH

First, prepare and explore the data.

-   histograms to plot distribution of raw and transformed data

-   plot relationships with quantitative predictors

```{r Prep/explore}
hist(mantree_grey_rest$DBH_cm) # right skewed
hist(log(mantree_grey_rest$DBH_cm)) # approx normal
hist(sqrt(mantree_grey_rest$DBH_cm)) # still right skewed

plot(mantree_grey_rest$DBH_cm ~ mantree_grey_rest$YSR) # could be non-linear
plot(mantree_grey_rest$DBH_cm ~ mantree_grey_rest$Elevation) # not obviously non-linear
```

Next, create a model:

-   gaussian model as it's continuous data

-   include YSR as a polynomial variable as it looks potentially non-linear

-   try log transformed dependent variable if assumptions aren't ok without transformation

    -   Looks better with log transformation

-   fixed predictors Estuary \* Elevation

-   random effect quadrat (Combo) nested within Site

-   check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity on a model without interactions

```{r Model_building}
M7 <- glmmTMB(DBH_cm ~ Estuary * Elevation + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7,re.form = NA), resid) 
plotQQunif(M7)

M7 <- glmmTMB(log(DBH_cm) ~ Estuary * Elevation + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7,re.form = NA), resid) 
plotQQunif(M7)

M <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
check_collinearity(M)

# without elevation
M7.1 <- glmmTMB(log(DBH_cm) ~ Estuary + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M7.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M7.1,re.form = NA), resid) 
plotQQunif(M7.1)
```

Next, test the model:

-   Use anova to compare model with null models that lack the polynomial YSR term (M) and lack YSR altogether (M0)

```{r Model_testing}
M <- glmmTMB(log(DBH_cm) ~ Estuary * Elevation + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M0 <- glmmTMB(log(DBH_cm) ~ Estuary * Elevation + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

anova(M7, M, M0)

M <- glmmTMB(log(DBH_cm) ~ Estuary + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M0 <- glmmTMB(log(DBH_cm) ~ Estuary + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

anova(M7.1,M,M0)

joint_tests(M7)
```

Finally, plot the results.

```{r Plot}
emmip(M7, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "DBH")

emmip(M7.1, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "DBH")
```

## 2g. Tree height

First, prepare and explore the data.

-   histograms to plot raw and transformed data

-   plot relationship with quantitative predictors

```{r Prep/explore}
hist(mantree_grey_rest$Height_m) # close to normal, slightly right skewed
hist(sqrt(mantree_grey_rest$Height_m)) # not sure this is an improvement
hist(log(mantree_grey_rest$Height_m)) # becomes slightly left skewed

plot(mantree_grey_rest$Height_m ~ mantree_grey_rest$YSR) # could be non-linear
plot(mantree_grey_rest$Height_m ~ mantree_grey_rest$Elevation)  # could be non-linear
```

Next, create a model.

-   gaussian model as it's continuous data

-   include Elevation as a polynomial variable as it looked potentially non-linear

-   include YSR as a polynomial variable as it looked potentially non-linear

-   additional fixed predictors Estuary, and its interaction with the elevation polynomial

-   test assumptions using resid and scatter.smooth, plotQQunif and check_collinearity on a model without interactions

    -   sqrt and log transformed models looks better than the original and have significantly lower AICs. still somewhat fan-shaped but hopefully ok. log has the lowest AIC (signifcantly) so use that

```{r Model_building}
M8.1 <- glmmTMB(Height_m ~ Estuary * poly(Elevation, 2) + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M8.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8.1,re.form = NA), resid) 
plotQQunif(M8.1)

M8.2 <- glmmTMB(sqrt(Height_m) ~ Estuary * poly(Elevation, 2) + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M8.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8.2,re.form = NA), resid) 
scatter.smooth(predict(M8.2,re.form = NA), abs(resid)) 
plotQQunif(M8.2)

M8.3 <- glmmTMB(log(Height_m) ~ Estuary * poly(Elevation, 2) + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M8.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8.3,re.form = NA), resid) 
scatter.smooth(predict(M8.3,re.form = NA), abs(resid)) 
plotQQunif(M8.3)

anova(M8.1,M8.2,M8.3)

M <- glmmTMB(sqrt(Height_m) ~ Estuary + Estuary + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
check_collinearity(M)

# try without elevation
M8.31 <- glmmTMB(log(Height_m) ~ Estuary + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

resid <- residuals(simulateResiduals(M8.31), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8.31,re.form = NA), resid) 
scatter.smooth(predict(M8.31,re.form = NA), abs(resid)) 
plotQQunif(M8.31)
# residuals plot fine but not great
```

Next, test the model.

```{r Model_testing}
M8.3 <- glmmTMB(log(Height_m) ~ Estuary * poly(Elevation, 2) + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M <- glmmTMB(log(Height_m) ~ Estuary * poly(Elevation, 2) + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M0 <- glmmTMB(log(Height_m) ~ Estuary * poly(Elevation, 2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

anova(M8.3,M,M0)

joint_tests(M8.3)

summary(M8.3)

em <- emtrends(M8.3, var = "YSR")


em

plot(em)

emmeans(M8.3, ~ YSR | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")

# try without elevation

M8.31 <- glmmTMB(log(Height_m) ~ Estuary + poly(YSR,2) + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M <- glmmTMB(log(Height_m) ~ Estuary + YSR + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)
M0 <- glmmTMB(log(Height_m) ~ Estuary + (1|Site/Combo), family = "gaussian", data = mantree_grey_rest)

anova(M8.31,M,M0)

joint_tests(M8.31)

summary(M8.31)

em <- emtrends(M8.31, var = "YSR")


em

plot(em)

emmeans(M8.31, ~ YSR | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M8.3, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height") +
  geom_boxplot(data = mantree_grey_rest, aes(x = YSR, y = Height_m, group = YSR))

emmip(M8.31, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height") +
  geom_boxplot(data = mantree_grey_rest, aes(x = YSR, y = Height_m, group = YSR))
```

## 2i. Number of pneumatophores

First, prepare and explore the data.

```{r Prep/explore}
hist(manq_comm_rest$Pneu_0.5x0.5) # near normal
hist(sqrt(manq_comm_rest$Pneu_0.5x0.5)) # maybe closer to normal

plot(manq_comm_rest$Pneu_0.5x0.5 ~ manq_comm_rest$YSR) # potentially non-linear? but this is only because of one site, so keep it simple (linear)
plot(manq_comm_rest$Pneu_0.5x0.5 ~ manq_comm_rest$Elevation) # not obviously non-linear

ggplot(manq_comm_rest, aes(Pneu_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)
```

Next, create a model.

-   Need a random effect for quadrat (Combo) nested within site
-   It's count data, so could use a poisson or negative binomial distribution, but it's also close to normally distributed, so could use a gaussian distribution
    -   log model isn't working with the estuary \* elevation interaction, so run that without the interaction
    -   All three look good - choose best based on AIC - M9.1 is lowest with the interaction

```{r Model_building}
M9.1 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")

resid <- residuals(simulateResiduals(M9.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9.1,re.form = NA), resid) 
plotQQunif(M9.1)

M9.2 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "poisson")

resid <- residuals(simulateResiduals(M9.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9.2,re.form = NA), resid) 
plotQQunif(M9.2)

M9.3 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "nbinom2")

resid <- residuals(simulateResiduals(M9.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9.3,re.form = NA), resid) 
plotQQunif(M9.3)

anova(M9.1,M9.2,M9.3)

# check collinearity on model without interactions
M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")
check_collinearity(M0)

# try without elevation
M9.11 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")

resid <- residuals(simulateResiduals(M9.11), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9.11,re.form = NA), resid) 
plotQQunif(M9.11) # residuals plots don't look great
```

Next, test the model.

-   Compare it against null models without the polynomial term and without YSR completely using anova

-   Looks like there is evidence of a polynomial effect of YSR

```{r Model_testing}
M9.1 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")
M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")

anova(M9.1,M0)

joint_tests(M9.1)

emmeans(M9.1, ~ YSR | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")

# without elevation

M9.11 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")
M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")

anova(M9.11,M0)

joint_tests(M9.11)

emmeans(M9.11, ~ YSR | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

-   Because there is a complex correlation relationship between YSR, elevation and the response variable, the model tries to control for elevation in plotting and plots as if every YSR had the same elevation, which is not true or realistic. Therfore make a new model for plotting that excludes elevation.

```{r Plot}
M9.4 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + YSR + (1|Site/Combo), data = manq_comm_rest, family = "gaussian")

emmip(M9.4, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of pneumatophores per 0.5 x 0.5 m2") +
  geom_boxplot(data = manq_comm_rest, aes(x = YSR, y = Pneu_0.5x0.5, group = YSR))
```

## 2j. Pneumatophore height

First, prepare and explore the data.

```{r Prep/explore}
hist(manq_rest$Pneu_ht_mm) # right skewed
hist(log(manq_rest$Pneu_ht_mm)) # left skewed
hist(sqrt(manq_rest$Pneu_ht_mm)) # approx normal

plot(manq_rest$Pneu_ht_mm ~ manq_rest$YSR) # looks non linear

plot(manq_rest$Pneu_ht_mm ~ manq_rest$Elevation) # potentially non-linear, investigate
ggplot(manq_rest, aes(x = Elevation, y = Pneu_ht_mm)) +
  geom_point() +
  geom_smooth() +
  geom_smooth(method = "lm") # not far from linear so keep as a linear term
```

Next, create a model.

-   continuous data so use gaussian distribution

-   right skewed so try sqrt transformation

    -   sqrt transformed residuals plots look better, and significant difference when comparing the models

-   random effect of subquadrat nested within quadrat (Combo) nested within Site

```{r Model_building}
M10.1 <- glmmTMB(Pneu_ht_mm ~ Estuary * Elevation + poly(YSR,2) + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")

resid <- residuals(simulateResiduals(M10.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10.1,re.form = NA), resid) 
plotQQunif(M10.1)

M10.2 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * Elevation + poly(YSR,2) + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")

resid <- residuals(simulateResiduals(M10.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10.2,re.form = NA), resid) 
plotQQunif(M10.2)

anova(M10.1,M10.2)

# check collinearity on model without interactions
M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + Elevation + YSR + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")
check_collinearity(M0)

# without elevation
M10.3 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(YSR,2) + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")

resid <- residuals(simulateResiduals(M10.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10.3,re.form = NA), resid) 
plotQQunif(M10.3)
```

Next, test the model.

```{r Model_testing}
M10.2 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * Elevation + poly(YSR,2) + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")
M <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * Elevation + YSR + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")
M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * Elevation + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")

anova(M10.2,M,M0)

M10.3 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(YSR,2) + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")
M <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + YSR + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")
M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + (1|Site/Combo/Subquadrat), data = manq_rest, family = "gaussian")

anova(M10.3,M,M0)

joint_tests(M10.2)

emmeans(M10.2, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M10.2, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Pneumatophore height") +
  geom_boxplot(data = manq_rest, aes(x = YSR, y = Pneu_ht_mm, group = YSR))

emmip(M10.3, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Pneumatophore height") +
  geom_boxplot(data = manq_rest, aes(x = YSR, y = Pneu_ht_mm, group = YSR))

# restoring sites YSR
m_pneu_ht_rest <- ggplot(manq_rest, aes(x=YSR, y=Pneu_ht_mm/10, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter() +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Pneumatophore height (cm)") +
  xlim(0,35) +
  ylim(0,60)
m_pneu_ht_rest

# natural sites
m_pneu_ht_nat <- ggplot(manq_rest, aes(x=Site, y=Pneu_ht_mm/10, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(width = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.text = element_text(size = 20),
          legend.title = element_text(size = 24),
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,60)
m_pneu_ht_nat

# plot natural and restored together
ggarrange(m_pneu_ht_rest,m_pneu_ht_nat,ncol =2,nrow=1,widths = c(1.2,1))

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Pneumatophore_height.jpg", width = 4000, height = 3000, units = "px")
```

## 2k. Pneumatophore diameter

First, prepare and explore the data.

```{r Prep/explore}
hist(manq_rest$Pneu_dia_mm) # right skewed
hist(log(manq_rest$Pneu_dia_mm)) # kind of normal but weird
hist(sqrt(manq_rest$Pneu_dia_mm)) # approx normal

plot(manq_rest$Pneu_dia_mm ~ manq_rest$YSR) # looks potentially non linear?
boxplot(manq_rest$Pneu_dia_mm ~ manq_rest$YSR)

plot(manq_rest$Pneu_dia_mm ~ manq_rest$Elevation) # looks potentially non linear
```

Next, create a model.

-   residuals look better with sqrt transformed data, so use those

```{r Model_building}
M11.1 <- glmmTMB(Pneu_dia_mm ~ Estuary + poly(Elevation,2) + poly(YSR, 2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)

resid <- residuals(simulateResiduals(M11.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11.1,re.form = NA), resid) 
plotQQunif(M11.1)

M11.2 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(Elevation,2) + poly(YSR, 2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)

resid <- residuals(simulateResiduals(M11.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11.2,re.form = NA), resid) 
plotQQunif(M11.2)

anova(M11.1,M11.2)

# check collinearity on model without interactions
M0 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + Elevation + YSR + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)
check_collinearity(M0)

# without elevation

M11.3 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(YSR, 2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)

resid <- residuals(simulateResiduals(M11.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11.3,re.form = NA), resid) 
plotQQunif(M11.3)
```

Next, test the model.

```{r Model_testing}
M11.2 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(Elevation,2) + poly(YSR, 2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)
M <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(Elevation,2) + YSR + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)
M0 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(Elevation,2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)

anova(M11.2,M,M0)

M11.3 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + poly(YSR, 2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)
M <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + YSR + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)
M0 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq_rest)

anova(M11.3,M,M0)

joint_tests(M11.2)

emmeans(M11.2, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M11.2, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Pneumatophore diameter (mm)") +
  geom_boxplot(data = manq_rest, aes(x = YSR, y = Pneu_dia_mm, group = YSR))

emmip(M11.3, ~ YSR, at = list(YSR = c(5:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Pneumatophore diameter (mm)") +
  geom_boxplot(data = manq_rest, aes(x = YSR, y = Pneu_dia_mm, group = YSR))
```

## ?2m. Leaf dry:fresh ratio

First, prepare and explore the data.

-   Important to note here is that we could only collect leaves from 4 restored sites, so it's going to be harder to see any effects. Therefore YSR should be included as a linear factor as a polynomial would be overfitting the model.

```{r Prep/explore}
hist(manleaf_wide_grey_rest$dfratio) # approx normal distribution

plot(manleaf_wide_grey_rest$dfratio ~ manleaf_wide_grey_rest$YSR)

plot(manleaf_wide_grey_rest$dfratio ~ manleaf_wide_grey_rest$Elevation)
ggplot(manleaf_wide_grey_rest, aes(x = Elevation, y = dfratio)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2))

# polynomial looks like a slightly better fit, use this
```

Next, create a model.

-   gaussian as it's continuous data

-   random effect of tree within quadrat (Combo) within Site

```{r Model_building}

M13 <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M13), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13,re.form = NA), resid) # looks great
plotQQunif(M13)

# check collinearity on model without interactions
M0 <- glmmTMB(dfratio ~ Estuary + Elevation + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)
check_collinearity(M0)

# no elevation
M13.2 <- glmmTMB(dfratio ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M13.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13.2,re.form = NA), resid) # looks great
plotQQunif(M13.2)
```

Next, test the model.

-   Compare it against a null model lacking YSR using anova

```{r Model_testing}
M13 <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

M <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M13, M)

M13.2 <- glmmTMB(dfratio ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)
M <- glmmTMB(dfratio ~ Estuary + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M13.2, M)

joint_tests(M13)

summary(M13)

em <- emmeans(M13, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)))

em 

plot(em)
```

Finally, plot the results.

```{r Plot}

emmip(M13, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)))
# misleading plot - very slight decline in values but on this scale looks large
```

## 2n. LMA

First, prepare and explore the data.

```{r Prep/explore}
hist(manleaf_wide_grey_rest$LMA) # approx normal distribution

plot(manleaf_wide_grey_rest$LMA ~ manleaf_wide_grey_rest$YSR)

plot(manleaf_wide_grey_rest$LMA ~ manleaf_wide_grey_rest$Elevation)
ggplot(manleaf_wide_grey_rest, aes(x = Elevation, y = LMA, color = Estuary)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2))
ggplot(manleaf_wide_grey_rest, aes(x = Elevation, y = LMA, color = YSR)) +
  geom_point()

boxplot(manleaf_wide_grey_rest$LMA ~ manleaf_wide_grey_rest$Estuary)
boxplot(manleaf_wide_grey_rest$LMA ~ manleaf_wide_grey_rest$Tree_sapling)
```

Next, create a model.

```{r Model_building}
M14 <- glmmTMB(LMA ~ Estuary + poly(Elevation,2) + Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest) # error

resid <- residuals(simulateResiduals(M14), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M14,re.form = NA), resid) 
plotQQunif(M14) 


# check collinearity on model without interactions
M0 <- glmmTMB(LMA ~ Estuary + Elevation + Tree_sapling + YSR, family = "gaussian", data = manleaf_wide_grey_rest)
check_collinearity(M0)

# try without elevation
M14.2 <- glmmTMB(LMA ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M14.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M14.2,re.form = NA), resid) 
plotQQunif(M14.2)
```

Next, test the model.

```{r Model_testing}
M14 <- glmmTMB(LMA ~ Estuary * poly(Elevation,2) + Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)
M <- glmmTMB(LMA ~ Estuary * poly(Elevation,2) + Tree_sapling + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M14, M)

M14.2 <- glmmTMB(LMA ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)
M <- glmmTMB(LMA ~ Estuary + Tree_sapling + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M14.2,M)

joint_tests(M14)

summary(M14)

emmeans(M14, ~YSR, at = list(YSR = c(5,9,12,16,30,33)))
```

Finally, plot the results.

```{r Plot}
emmip(M14, ~YSR, at = list(YSR = c(5,9,12,16,30,33))) +
  geom_boxplot(data = manleaf_wide_grey_rest, aes(x = YSR, y = LMA, group = YSR, color = Estuary))

# the boxplots do not align with the trend. Try plotting without elevation to see if that could be influencing the results

M14.1 <- glmmTMB(LMA ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)
emmip(M14.1, ~YSR, at = list(YSR = c(5,9,12,16,30,33))) +
  geom_boxplot(data = manleaf_wide_grey_rest, aes(x = YSR, y = LMA, group = YSR))

# less steep slope but still a trend. try removing other variables to see their impact

M14.2 <- glmmTMB(LMA ~ Tree_sapling + YSR + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey_rest)
emmip(M14.2, ~YSR, at = list(YSR = c(5,9,12,16,30,33))) +
  geom_boxplot(data = manleaf_wide_grey_rest, aes(x = YSR, y = LMA, group = YSR))

```

## 2o. Leaf area

First, prepare and explore the data.

-   These data exist for all 6 sites

```{r Prep/explore}
hist(manleaf_wide_grey_rest$Area) # right skewed
hist(log(manleaf_wide_grey_rest$Area)) # approx normal, slightly left skewed
hist(sqrt(manleaf_wide_grey_rest$Area)) # still right skewed

plot(manleaf_wide_grey_rest$Area ~ manleaf_wide_grey_rest$YSR) # not obviously non-linear

plot(manleaf_wide_grey_rest$Area ~ manleaf_wide_grey_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   If non-transformed data don't meet assumptions, try log transformation
-   Can't include YSR:Estuary interaction because there is only one restored site in the Maroochy

```{r Model_building}

M <- glmmTMB(Area ~ Estuary * Elevation + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M,re.form = NA), resid) 
plotQQunif(M)

# assumptions plots look decent, however this comes with a lot of warnings

M15 <- glmmTMB(log(Area) ~ Estuary * Elevation + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M15), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M15,re.form = NA), resid) 
plotQQunif(M15)

# assumptions plots look great, and this doesn't come with warnings

anova(M,M15)

# it can't compare models because the top one has a model convergence problem. Given the bottom one looks better and doesn't have this issue, use it.

# check collinearity on model without interactions
M0 <- glmmTMB(log(Area) ~ Estuary + Elevation + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)
check_collinearity(M0)

# without elevation
M15.1 <- glmmTMB(log(Area) ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

resid <- residuals(simulateResiduals(M15.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M15.1,re.form = NA), resid) 
plotQQunif(M15.1)
```

Next, test the model.

-   the warning listed should be ok, except for the fact that coefficients are not calculated..

```{r Model_testing}

M15 <- glmmTMB(log(Area) ~ Estuary * Elevation + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)
M <- glmmTMB(log(Area) ~ Estuary * Elevation + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M15,M)

M15.1 <- glmmTMB(log(Area) ~ Estuary + Tree_sapling + YSR + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)
M <- glmmTMB(log(Area) ~ Estuary + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey_rest)

anova(M15.1,M)

joint_tests(M15)

summary(M15)

emmeans(M15, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M15, ~ YSR | Elevation, at = list(YSR = c(6:33)), type = "response", CIs = TRUE)

emmip(M15, ~ YSR | Elevation, at = list(YSR = c(6:33), Elevation = c(-0.5,0,0.5,1)), type = "response", CIs = TRUE)

emmip(M15.1, ~ YSR, at = list(YSR = c(6:33)), type = "response", CIs = TRUE)

```

## 2p. Leaf herbivory

First, prepare and explore the data.

-   transform herbivory percentages to proportions, and offset 0s slightly as beta distributions don't take 0s

```{r Prep/explore}
manleaf_wide_grey_rest <- manleaf_wide_grey_rest %>% 
  mutate(Herb_prop = case_when(
    `Herb_%` == 0 ~ 0.00001,
    .default = `Herb_%`/100
  ))

manleaf_wide_grey_rest_t <- manleaf_wide_grey_rest_t %>% 
  mutate(Herb_prop = case_when(
    `Herb_%` == 0 ~ 0.00001,
    .default = `Herb_%`/100
  ))

hist(manleaf_wide_grey_rest$Herb_prop) # highly right skewed

plot(manleaf_wide_grey_rest$Herb_prop ~ manleaf_wide_grey_rest$YSR) # not obviously non-linear

plot(manleaf_wide_grey_rest$Herb_prop ~ manleaf_wide_grey_rest$Elevation) # not obviously non-linear
```

Next, create a model.

-   Use a beta distribution as it's proportion data

-   **QQ PLOT LOOKS WEIRD**

-   There are no sapling data, so therefore don't need to include the Tree_sapling term

```{r Model_building}
M16 <- glmmTMB(Herb_prop ~ Estuary * Elevation + YSR + (1|Site/Combo/Tree), family = "beta_family", data = manleaf_wide_grey_rest_t) 

resid <- residuals(simulateResiduals(M16), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M16,re.form = NA), resid) 
plotQQunif(M16)

M16.2 <- glmmTMB(Herb_prop ~ Estuary * Elevation + YSR + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 

resid <- residuals(simulateResiduals(M16.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M16.2,re.form = NA), resid) 
plotQQunif(M16.2)

anova(M16,M16.2)

# tweedie distribution is better than beta - qq plot still looks weird but it's less weird than the beta model and the residuals plot is good at least

# check collinearity on model without interactions
M0 <- glmmTMB(Herb_prop ~ Estuary + Elevation + YSR + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t)
check_collinearity(M0)

# without elevation
M16.3 <- glmmTMB(Herb_prop ~ Estuary + YSR + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 

resid <- residuals(simulateResiduals(M16.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M16.3,re.form = NA), resid) 
plotQQunif(M16.3)
```

Next, test the model.

```{r Model_testing}
M16.2 <- glmmTMB(Herb_prop ~ Estuary * Elevation + YSR + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 
M <- glmmTMB(Herb_prop ~ Estuary * Elevation + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 

anova(M16.2,M)

M16.3 <- glmmTMB(Herb_prop ~ Estuary + YSR + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 
M <- glmmTMB(Herb_prop ~ Estuary + (1|Site/Combo/Tree), family = "tweedie", data = manleaf_wide_grey_rest_t) 

anova(M16.3,M)

joint_tests(M16.2)

summary(M16.2)

emmeans(M16.2, ~ YSR, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M16.2, ~ YSR | Elevation, at = list(YSR = c(6:33), Elevation = c(-0.5,0,0.5,1)), type = "response", CIs = TRUE)

emmip(M16.3, ~ YSR, at = list(YSR = c(6:33)), type = "response", CIs = TRUE)

# restoring sites YSR
m_herb_rest <- ggplot(manleaf_wide_grey_rest, aes(x=YSR, y=`Herb_%`, fill=Estuary, group = YSR)) +
    geom_boxplot(width = 2) +
  geom_jitter(height = 0, alpha = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Herbivory (%)") +
  xlim(0,35) +
  ylim(0,60)
m_herb_rest

# natural sites
m_herb_nat <- ggplot(manleaf_wide_grey_nat, aes(x=Site, y=`Herb_%`, fill=Estuary, group = Site)) +
    geom_boxplot(width = 0.4) +
  geom_jitter(width = 0.1, height = 0, alpha = 0.1) +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.text = element_text(size = 20),
          legend.title = element_text(size = 24),
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("") +
  ylim(0,60)
m_herb_nat

# plot natural and restored together
ggarrange(m_herb_rest,m_herb_nat,ncol =2,nrow=1,widths = c(1.2,1))

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Mangrove_herbivory.jpg", width = 4000, height = 3000, units = "px")
```

# 3. Restoration status models

Before we create any of these models, let's inspect the data space we're working with:

-   relationship between rest_status and Elevation
    -   Not a great overlap - natural sites mostly have elevations 0.4-0.6m whereas restored sites mostly have elevations 0.2-0.5m - therefore don't include an interaction
-   relationship between Elevation and Estuary
    -   These are quite overlapping, so can include an interaction if we think it's relevant. The effect of elevation could depend on estuary so I think leave interaction in where the model runs.

```{r Predictor_association}

plot(mantree_comm$Elevation ~ mantree_comm$rest_status) 

boxplot(mantree_comm$Elevation ~ mantree_comm$rest_status)  

boxplot(mantree_comm$Elevation ~ mantree_comm$Estuary)   
```

Also test for differences between elevation of natural vs restored mangrove sites.

```{r Elevation model}
M17.5 <- glmmTMB(Elevation ~ Estuary + rest_status + (1|Site), data = mantree_comm)

resid <- residuals(simulateResiduals(M17.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M17.5,re.form = NA), resid) 
plotQQunif(M17.5)
# all look good

M0 <- glmmTMB(Elevation ~ Estuary + (1|Site), data = mantree_comm)

anova(M17.5,M0)

em <- emmeans(M17.5, ~ rest_status, at = list(rest_status = c(0,1)))

em

plot(em)

joint_tests(M17.5)
```

Also, investigate the occurrence of each species at natural and restoration sites.

-   Red mangroves only exist at natural sites in the Maroochy, so we can't include them - create a dataframe that only has the other three species. River and Orange mangroves are only in the Maroochy, but there are 2 restored and 2 natural sites of each, so we can analyse these data, with the limitation that they're based on a limited number of sites and only one estuary. This affects the following traits:

    -   number of stems

    -   DBH

    -   height

    -   reproduction

    -   leaf traits

```{r Species}
mantree %>% group_by(rest_status, Site) %>% count(Species)

mantree_nored <- mantree %>% subset(Species != "Red")
manleafandherb_nored <- manleafandherb %>% subset(Species != "Red")
```

## 3a. Number of trees

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(mantree_comm$total_trees)

plot(mantree_comm$total_trees ~ mantree_comm$rest_status)
plot(mantree_comm$total_trees ~ mantree_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: it's count data so use poisson or negative binomial

-   Include the interaction between Estuary and restoration status, as the effect of restoration status may vary between estuaries

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Include an offset for Quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M18 <- glmmTMB(Trees ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", data = mantree_comm)

resid <- residuals(simulateResiduals(M18), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M18,re.form = NA), resid) 
plotQQunif(M18)

# don't look good, try negative binomial

M18 <- glmmTMB(Trees ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M18), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M18,re.form = NA), resid) 
plotQQunif(M18)

# these residuals look fine, use this model

# check collinearity on a model without interactions
M0 <- glmmTMB(Trees ~ Estuary + Elevation + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
check_collinearity(M0)

# try without elevation

M18.1 <- glmmTMB(Trees ~ Estuary*rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M18.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M18.1,re.form = NA), resid) 
plotQQunif(M18.1)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and without the interaction with Estuary to test the importance of rest_status

```{r Model_testing}
M18 <- glmmTMB(Trees ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

M <- glmmTMB(Trees ~ Estuary * Elevation + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

M0 <- glmmTMB(Trees ~ Estuary * Elevation + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

anova(M18,M,M0) 

M18.1 <- glmmTMB(Trees ~ Estuary * rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
M <- glmmTMB(Trees ~ Estuary + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
M0 <- glmmTMB(Trees ~ Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

anova(M18.1,M,M0) 

joint_tests(M18)

summary(M18)

emmeans(M18, ~ rest_status | Estuary, type = "response")  
```

Finally, plot the results.

```{r Plot}

emmip(M18, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Number of trees per 10m2", offset = log(100))

emmip(M18.1, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Number of trees per 10m2", offset = log(100))
```

## 3bi. Number of saplings

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(mantree_comm$total_saplings)

plot(mantree_comm$total_saplings ~ mantree_comm$rest_status)
ggplot(mantree_comm, aes(y = total_saplings, x = as.factor(rest_status), group = as.factor(rest_status))) +
  geom_boxplot()

plot(mantree_comm$total_saplings ~ mantree_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: it's count data so poisson or negative binomial

-   include the interaction Estuary : rest_status

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Include an offset for Quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M19 <- glmmTMB(Saplings ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "poisson", data = mantree_comm)

resid <- residuals(simulateResiduals(M19), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19,re.form = NA), resid) 
plotQQunif(M19)

# doesn't look great (has a trend), try negative binomial

M19 <- glmmTMB(Saplings ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M19), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19,re.form = NA), resid) 
plotQQunif(M19)

# still not amazing but looks better! use this one

# check collinearity on a model without interactions
M0 <- glmmTMB(Saplings ~ Elevation + Estuary + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
check_collinearity(M0)

# without elevation
M19.1 <- glmmTMB(Saplings ~ Estuary * rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M19.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.1,re.form = NA), resid) 
plotQQunif(M19.1)
```

M19 \<- glmmTMB(Saplings \~ Elevation \* Estuary + rest_status + Estuary:rest_status + (1\|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

resid \<- residuals(simulateResiduals(M19), quantileFunction = qnorm, outlierValues = c(-7,7)) scatter.smooth(predict(M19,re.form = NA), resid) plotQQunif(M19)

Next, test the model:

-   use anova to test the model against a null model without rest_status or its interaction with Estuary
-   The CI for saplings at each restoration status are non-overlapping

```{r Model_testing}
M19 <- glmmTMB(Saplings ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

M <- glmmTMB(Saplings ~ Elevation * Estuary + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

M0 <- glmmTMB(Saplings ~ Elevation * Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

anova(M19,M,M0)  

M19.1 <- glmmTMB(Saplings ~ Estuary * rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
M <- glmmTMB(Saplings ~ Estuary + rest_status + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)
M0 <- glmmTMB(Saplings ~ Estuary + (1|Site) + offset(log(Quadrat_size_m2)), family = "nbinom2", data = mantree_comm)

anova(M19.1,M,M0)  

joint_tests(M19)  

summary(M19)  

emmeans(M19, ~ rest_status, type = "response", offset = log(100))  
```

Finally, plot the results.

```{r Plot}

emmip(M19, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of saplings per 10m2", offset = log(100))

emmip(M19.1, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of saplings per 10m2", offset = log(100))
```

## 

## 3bii. Number of small seedlings

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manq_comm$`Seedlings_<30cm_1x1`) # very right skewed (count data)

plot(manq_comm$`Seedlings_<30cm_1x1` ~ manq_comm$rest_status)
ggplot(manq_comm, aes(y = `Seedlings_<30cm_1x1`, x = as.factor(rest_status), group = as.factor(rest_status))) +
  geom_boxplot()

plot(manq_comm$`Seedlings_<30cm_1x1` ~ manq_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: it's count data so poisson or negative binomial

-   include the interaction Estuary : rest_status

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M19.2 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "poisson", data = manq_comm)

resid <- residuals(simulateResiduals(M19.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.2,re.form = NA), resid) 
plotQQunif(M19.2)

# residuals plot looks good but qq plot looks weird, try negative binomial

M19.3 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "nbinom2", data = manq_comm)

resid <- residuals(simulateResiduals(M19.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.3,re.form = NA), resid) 
plotQQunif(M19.3)

# looks better! use this one

# check collinearity on a model without interactions
M0 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation + Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)
check_collinearity(M0)

# no elevation
M19.31 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * rest_status + (1|Site), family = "nbinom2", data = manq_comm)

resid <- residuals(simulateResiduals(M19.31), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.31,re.form = NA), resid) 
plotQQunif(M19.31)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status or its interaction with Estuary
-   The CI for saplings at each restoration status are non-overlapping

```{r Model_testing}
M19.3 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "nbinom2", data = manq_comm)

M <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation * Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)

M0 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Elevation * Estuary + (1|Site), family = "nbinom2", data = manq_comm)

anova(M19.3,M,M0) 

M19.31 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary * rest_status + (1|Site), family = "nbinom2", data = manq_comm)
M <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)
M0 <- glmmTMB(`Seedlings_<30cm_1x1` ~ Estuary + (1|Site), family = "nbinom2", data = manq_comm)

anova(M19.31,M,M0) 

joint_tests(M19.3)  

summary(M19.3)  

emmeans(M19.3, ~ rest_status, type = "response")  
```

Finally, plot the results.

```{r Plot}
emmip(M19.3, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of small seedlings per m2")

emmip(M19.31, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of small seedlings per m2")
```

## 

## 3biii. Number of medium seedlings

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manq_comm$`Seedlings_30-100cm_1x1`) # very right skewed (count data)

plot(manq_comm$`Seedlings_30-100cm_1x1` ~ manq_comm$rest_status)
ggplot(manq_comm, aes(y = `Seedlings_30-100cm_1x1`, x = as.factor(rest_status), group = as.factor(rest_status))) +
  geom_boxplot()

plot(manq_comm$`Seedlings_30-100cm_1x1` ~ manq_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: it's count data so poisson or negative binomial

-   include the interaction Estuary : rest_status

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M19.4 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "poisson", data = manq_comm)

resid <- residuals(simulateResiduals(M19.4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.4,re.form = NA), resid) 
plotQQunif(M19.4)

# residuals plot looks good but qq plot looks weird, try negative binomial

M19.5 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "nbinom2", data = manq_comm)

resid <- residuals(simulateResiduals(M19.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.5,re.form = NA), resid) 
plotQQunif(M19.5)

# looks better! use this one

# check collinearity on a model without interactions
M0 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation + Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)
check_collinearity(M0)

# without elevation
M19.51 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary * rest_status + (1|Site), family = "nbinom2", data = manq_comm)

resid <- residuals(simulateResiduals(M19.51), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M19.51,re.form = NA), resid) 
plotQQunif(M19.51)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status or its interaction with Estuary
-   The CI for saplings at each restoration status are non-overlapping

```{r Model_testing}
M19.5 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation * Estuary + rest_status + Estuary:rest_status + (1|Site), family = "nbinom2", data = manq_comm)

M <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation * Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)

M0 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Elevation * Estuary + (1|Site), family = "nbinom2", data = manq_comm)

anova(M19.5,M,M0)  

M19.51 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + rest_status + Estuary:rest_status + (1|Site), family = "nbinom2", data = manq_comm)
M <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + rest_status + (1|Site), family = "nbinom2", data = manq_comm)
M0 <- glmmTMB(`Seedlings_30-100cm_1x1` ~ Estuary + (1|Site), family = "nbinom2", data = manq_comm)

anova(M19.51,M,M0) 

joint_tests(M19.5)  

summary(M19.5)  

emmeans(M19.5, ~ rest_status, type = "response") 
```

Finally, plot the results.

```{r Plot}
emmip(M19.5, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of medium seedlings per m2")

emmip(M19.51, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of medium seedlings per m2")
```

## 

## 3c. Number of hollows

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}

hist(mantree_comm$total_hollows) # zero inflated right skewed

plot(mantree_comm$total_hollows ~ mantree_comm$rest_status)
plot(mantree_comm$total_hollows ~ mantree_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: zero inflated count data so poisson, negative binomial or a zero-inflated version of one of these

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Include an offset for Quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M20.1 <- glmmTMB(Hollows ~ Estuary * Elevation + rest_status + Estuary:rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "poisson", data = mantree_comm)

resid <- residuals(simulateResiduals(M20.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M20.1,re.form = NA), resid) 
plotQQunif(M20.1)

# actually looks ok (at least residuals graph)

M20.2 <- glmmTMB(Hollows ~ Estuary * Elevation + rest_status + Estuary:rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M20.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M20.2,re.form = NA), resid) 
plotQQunif(M20.2)

# looks slightly better

# these both look fine so don't need to investigate zero-inflated models. 

anova(M20.1,M20.2) # use the negative binomial model

# check collinearity on a model without interactions
M0 <- glmmTMB(Hollows ~ Estuary + Elevation + rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)
check_collinearity(M0)

# without elevation
M20.3 <- glmmTMB(Hollows ~ Estuary * rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

resid <- residuals(simulateResiduals(M20.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M20.3,re.form = NA), resid) 
plotQQunif(M20.3)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and without the interaction with Estuary

```{r Model_testing}
M20.2 <- glmmTMB(Hollows ~ Estuary * Elevation + rest_status + Estuary:rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

M <- glmmTMB(Hollows ~ Estuary * Elevation + rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

M0 <- glmmTMB(Hollows ~ Estuary * Elevation + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

anova(M0,M,M20.2)  

M20.3 <- glmmTMB(Hollows ~ Estuary * rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)
M <- glmmTMB(Hollows ~ Estuary + rest_status + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)
M0 <- glmmTMB(Hollows ~ Estuary + offset(log(Quadrat_size_m2)) + (1|Site), family = "nbinom2", data = mantree_comm)

anova(M0,M,M20.3) 

joint_tests(M20.2)  

summary(M20.2)  

emmeans(M20.2, ~ rest_status | Estuary, type = "response", offset = log(100))  
emmeans(M20.2, ~ rest_status, type = "response", offset = log(100)) 
```

Finally, plot the results.

```{r Plot}

emmip(M20.2, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of hollows per 10m2", offset = log(100))

emmip(M20.2, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of hollows per 10m2", offset = log(100))

emmip(M20.3, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of hollows per 10m2", offset = log(100))
```

## 

## 3d. Canopy cover

First, prepare and explore the data:

-   Make canopy cover into a proportion variable, suitable for a beta distribution

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
mantree_comm <- mantree_comm %>% mutate(Cover_prop = `Canopy_cover_%`/100)

hist(mantree_comm$Cover_prop)

plot(mantree_comm$Cover_prop ~ mantree_comm$rest_status)

plot(mantree_comm$Cover_prop ~ mantree_comm$Elevation) # not obviously non-linear
```

Next, create a model.

-   Distribution type: it's proportion data so use a beta distribution

-   Include Elevation and Estuary as additional fixed predictor variables and Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M21 <- glmmTMB(Cover_prop ~ Estuary + Elevation + rest_status + Estuary:rest_status + (1|Site), family = "beta_family", data = mantree_comm)

resid <- residuals(simulateResiduals(M21), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M21,re.form = NA), resid) 
plotQQunif(M21)

# looks fine

# check collinearity on a model without interactions
M0 <- glmmTMB(Cover_prop ~ Estuary + Elevation + rest_status + (1|Site), family = "beta_family", data = mantree_comm)
check_collinearity(M0)

# without elevation
M21.1 <- glmmTMB(Cover_prop ~ Estuary * rest_status + (1|Site), family = "beta_family", data = mantree_comm)

resid <- residuals(simulateResiduals(M21.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M21.1,re.form = NA), resid) 
plotQQunif(M21.1)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and without its interaction with Estuary

```{r Model_testing}
M21 <- glmmTMB(Cover_prop ~ Estuary + Elevation + rest_status + Estuary:rest_status + (1|Site), family = "beta_family", data = mantree_comm)

M <- glmmTMB(Cover_prop ~ Estuary + Elevation + rest_status + (1|Site), family = "beta_family", data = mantree_comm)

M0 <- glmmTMB(Cover_prop ~ Estuary + Elevation + (1|Site), family = "beta_family", data = mantree_comm)

anova(M21, M, M0) 

M21.1 <- glmmTMB(Cover_prop ~ Estuary * rest_status + (1|Site), family = "beta_family", data = mantree_comm)
M <- glmmTMB(Cover_prop ~ Estuary + rest_status + (1|Site), family = "beta_family", data = mantree_comm)
M0 <- glmmTMB(Cover_prop ~ Estuary + (1|Site), family = "beta_family", data = mantree_comm)

anova(M21.1, M, M0) 

joint_tests(M21)  

summary(M21)  

emmeans(M21, ~ rest_status | Estuary, type = "response")  
```

Finally, plot the results.

```{r Plot}

emmip(M21, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Canopy cover (proportion)")

emmip(M21.1, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Canopy cover (proportion)")
```

## 

## 3e. Number of stems

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(mantree_nored$Stems) # highly right skewed (count data)

plot(mantree_nored$Stems ~ mantree_nored$rest_status)
plot(mantree_nored$Stems ~ mantree_nored$Elevation) # not obviously non-linear

ggplot(mantree_nored, aes(x = Site, y = Stems, color = Estuary, fill = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)
```

Next, create a model.

-   Distribution type: poisson or negative binomial as it's count data

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Include an offset for Quadrat size

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M21.5 <- glmmTMB(Stems ~ Estuary * Elevation + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "poisson", data = mantree_nored)

resid <- residuals(simulateResiduals(M21.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M21.5,re.form = NA), resid) 
plotQQunif(M21.5)

# residuals plot ok but a bit weird, qq plot not great

M21.6 <- glmmTMB(Stems ~ Estuary * Elevation + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

resid <- residuals(simulateResiduals(M21.6), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M21.6,re.form = NA), resid) 
plotQQunif(M21.6)

# residuals plot ok but a bit weird, qq plot not great

anova(M21.5,M21.6) #M21.6 is better, diagnostics plots seem good enough, use this

# check collinearity on a model without interactions
M0 <- glmmTMB(Stems ~ Estuary + Elevation + Species + rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)
check_collinearity(M0)

# without elevation
M21.7 <- glmmTMB(Stems ~ Estuary + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

resid <- residuals(simulateResiduals(M21.7), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M21.7,re.form = NA), resid) 
plotQQunif(M21.7)
```

Next, test the model:

-   use anova to test the model against a null model without restoration status or its interactions with estuary or site

```{r Model_testing}
M21.6 <- glmmTMB(Stems ~ Estuary * Elevation + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

M1 <- glmmTMB(Stems ~ Estuary * Elevation + Species * rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

M <- glmmTMB(Stems ~ Estuary * Elevation + Species + rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

M0 <- glmmTMB(Stems ~ Estuary * Elevation + Species + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

anova(M21.6,M1,M,M0) 

M21.7 <- glmmTMB(Stems ~ Estuary + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)
M1 <- glmmTMB(Stems ~ Estuary + Species * rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)
M <- glmmTMB(Stems ~ Estuary + Species + rest_status + (1|Site/Combo), family = "nbinom2", data = mantree_nored)
M0 <- glmmTMB(Stems ~ Estuary + Species + (1|Site/Combo), family = "nbinom2", data = mantree_nored)

anova(M21.7,M1,M,M0) 

joint_tests(M21.6)  

summary(M21.6)  

emmeans(M21.6, ~ rest_status, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmeans(M21.6, ~ rest_status | Species, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmeans(M21.6, ~ rest_status | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmeans(M21.6, ~ rest_status | Species | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M21.6, ~ rest_status, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmip(M21.6, ~ rest_status | Species, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmip(M21.6, ~ rest_status | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
emmip(M21.6, ~ rest_status | Species | Estuary, at = list(YSR = c(5,9,12,16,30,33)), type = "response")

emmip(M21.7, ~ rest_status, at = list(YSR = c(5,9,12,16,30,33)), type = "response")
```

## 

## 3f. Tree DBH

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}

hist(mantree_nored$DBH_cm) # highly right skewed
hist(sqrt(mantree_nored$DBH_cm)) # still right skewed
hist(log(mantree_nored$DBH_cm)) # approx normal

plot(mantree_nored$DBH_cm ~ mantree_nored$rest_status)
plot(mantree_nored$DBH_cm ~ mantree_nored$Elevation) # not obviously non-linear

ggplot(mantree_nored, aes(x = Site, y = DBH_cm, color = Estuary, fill = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)
```

Next, create a model.

-   Distribution type: it's continous data so use a gaussian distribution, and try log transformed data if assumptions are not met without a transformation

-   This variable is measured by species so need to include species interacting with restoration status

-   Include Elevation and Estuary as additional fixed predictor variables and Quadrat (Combo) within Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M22 <- glmmTMB(DBH_cm ~ Estuary + Elevation + Species * rest_status + Estuary: rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M22), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M22,re.form = NA), resid) 
plotQQunif(M22)

# ok but a bit weird

M22 <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species * rest_status + Estuary: rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M22), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M22,re.form = NA), resid) 
plotQQunif(M22)

# log is better

# check collinearity on a model without interactions
M0 <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
check_collinearity(M0)

# without elevation

M22.1 <- glmmTMB(log(DBH_cm) ~ Estuary + Species * rest_status + Estuary: rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M22.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M22.1,re.form = NA), resid) 
plotQQunif(M22.1)
```

Next, test the model:

-   use anova to test the model against a null model without restoration status and without its interactions with estuary and site

```{r Model_testing}
M22 <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species * rest_status + Estuary:rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M1 <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species * rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M0 <- glmmTMB(log(DBH_cm) ~ Estuary + Elevation + Species + (1|Site/Combo), family = "gaussian", data = mantree_nored)

anova(M22,M1,M,M0)  

M22.1 <- glmmTMB(log(DBH_cm) ~ Estuary + Species * rest_status + Estuary: rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M1 <- glmmTMB(log(DBH_cm) ~ Estuary + Species * rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M <- glmmTMB(log(DBH_cm) ~ Estuary + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M0 <- glmmTMB(log(DBH_cm) ~ Estuary + Species + (1|Site/Combo), family = "gaussian", data = mantree_nored)

anova(M22.1,M1,M,M0) 

joint_tests(M22)  

summary(M22)  

emmeans(M22, ~ rest_status, type = "response")
emmeans(M22, ~ rest_status | Species, type = "response")  
emmeans(M22, ~ rest_status | Estuary, type = "response")  
```

Finally, plot the results.

```{r Plot}
emmip(M22, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22, ~ rest_status | Species | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)") 

emmip(M22.1, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22.1, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22.1, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)")
emmip(M22.1, ~ rest_status | Species | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Diameter (cm)") 

ggplot(mantree_nored, aes(x = as.factor(rest_status), y = DBH_cm)) +
  geom_boxplot() +
  facet_wrap(~Estuary + Species) +
  theme_bw() +
  scale_y_log10() +
  xlab("Restoration status") +
  ylab("Diameter at breast height (cm)") + 
  scale_x_discrete(labels = c("Natural", "Restored"))

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Mangrove_DBH_nat_vs_rest.jpg", width = 2000, height = 1500, units = "px")
```

## 

## 3g. Tree height

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}

hist(mantree_nored$Height_m) # slightly right skewed
hist(sqrt(mantree_nored$Height_m)) # approx normal
hist(log(mantree_nored$Height_m)) # slightly left skewed

plot(mantree_nored$Height_m ~ mantree_nored$rest_status)
plot(mantree_nored$Height_m ~ mantree_nored$Elevation) # not obviously non-linear

ggplot(mantree_nored, aes(x = rest_status, y = Height_m, group = rest_status)) +
  geom_boxplot() 

ggplot(mantree_nored, aes(x = Site, y = Height_m, group = Site, fill = rest_status, color = Estuary)) +
  geom_boxplot() +
  facet_wrap(~Species)
```

Next, create a model.

-   Distribution type: continuous so use a gaussian distribution, if it doesn't meet assumptions try the square root transformation

-   It's measured by species so include species \* rest_status interaction

-   Include Elevation and Estuary as additional fixed predictor variables and Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M23.1 <- glmmTMB(Height_m ~ Estuary + Elevation + Species * rest_status + Estuary : rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M23.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M23.1,re.form = NA), resid) 
plotQQunif(M23.1)

# looks pretty good, can try sqrt transformation to see if it looks better, but this is good enough

M23.2 <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species * rest_status + Estuary : rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M23.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M23.2,re.form = NA), resid) 
plotQQunif(M23.2)

anova(M23.1,M23.2) # sqrt transformed version has significantly lower AIC so use that

# check collinearity on a model without interactions
M0 <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
check_collinearity(M0)

# without elevation
M23.3 <- glmmTMB(sqrt(Height_m) ~ Estuary + Species * rest_status + Estuary : rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

resid <- residuals(simulateResiduals(M23.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M23.3,re.form = NA), resid) 
plotQQunif(M23.3)
```

Next, test the model:

-   use anova to test the model against a null model without YSR to test the importance of YSR

```{r Model_testing}
M23.2 <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species + rest_status + Species:rest_status + Estuary : rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M1 <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species + rest_status + Species:rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)

M0 <- glmmTMB(sqrt(Height_m) ~ Estuary + Elevation + Species + (1|Site/Combo), family = "gaussian", data = mantree_nored)

anova(M23.2,M1,M,M0)   

M23.3 <- glmmTMB(sqrt(Height_m) ~ Estuary + Species * rest_status + Estuary : rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M1 <- glmmTMB(sqrt(Height_m) ~ Estuary + Species * rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M <- glmmTMB(sqrt(Height_m) ~ Estuary + Species + rest_status + (1|Site/Combo), family = "gaussian", data = mantree_nored)
M0 <- glmmTMB(sqrt(Height_m) ~ Estuary + Species + (1|Site/Combo), family = "gaussian", data = mantree_nored)

anova(M23.3,M1,M,M0)   

joint_tests(M23.2)  

summary(M23.2)  

emmeans(M23.2, ~ rest_status | Species, type = "response")  
emmeans(M23.2, ~ rest_status | Estuary, type = "response") 
```

Finally, plot the results.

```{r Plot}

emmip(M23.2, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height (m)")

emmip(M23.2, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height (m)")

emmip(M23.3, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height (m)")

emmip(M23.3, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Tree height (m)")
```

## 

## 3i. Number of pneumatophores

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manq_comm$Pneu_0.5x0.5) # approx normal

plot(manq_comm$Pneu_0.5x0.5 ~ manq_comm$rest_status)
plot(manq_comm$Pneu_0.5x0.5 ~ manq_comm$Elevation) # not obviously non-linear

ggplot() +
  geom_boxplot(data = manq_comm, aes(x = as.factor(Site), y = Pneu_0.5x0.5, group = Site, color = rest_status))
```

Next, create a model.

-   Distribution type: count data so use poisson or negative binomial, although it's approximately normally distributed so a gaussian distribution could also be used

-   Include Elevation and Estuary as additional fixed predictor variables and quadrat (Combo) nested within Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M24.1 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + Elevation + rest_status + Estuary:rest_status + (1|Site/Combo), family = "poisson", data = manq_comm)

resid <- residuals(simulateResiduals(M24.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M24.1,re.form = NA), resid) 
plotQQunif(M24.1)

# looks a bit weird, try negative binoimal and normal distributions too

M24.2 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + Elevation + rest_status + Estuary:rest_status + (1|Site/Combo), family = "nbinom2", data = manq_comm)

resid <- residuals(simulateResiduals(M24.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M24.2,re.form = NA), resid) 
plotQQunif(M24.2)


M24.3 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + Elevation + rest_status + Estuary:rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)

resid <- residuals(simulateResiduals(M24.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M24.3,re.form = NA), resid) 
plotQQunif(M24.3)

anova(M24.1,M24.2,M24.3)

# normal looks best and has the lowest AIC value

# check collinearity on a model without interactions
M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + Elevation + rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)
check_collinearity(M0)

# without elevation

M24.5 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)

resid <- residuals(simulateResiduals(M24.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M24.5,re.form = NA), resid) 
plotQQunif(M24.5)
```

Next, test the model:

-   use anova to test the model against a null model without restoration status and its interaction with estuary

```{r Model_testing}
M24.4 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)

M <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)

M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * Elevation + (1|Site/Combo), family = "gaussian", data = manq_comm)

anova(M0,M,M24.4)

M24.5 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary * rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)
M <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + rest_status + (1|Site/Combo), family = "gaussian", data = manq_comm)
M0 <- glmmTMB(Pneu_0.5x0.5 ~ Estuary + (1|Site/Combo), family = "gaussian", data = manq_comm)

anova(M0,M,M24.5)

joint_tests(M24.4)  

summary(M24.4)  

emmeans(M24.4, ~ rest_status | Estuary, type = "response")  
```

Finally, plot the results.

```{r Plot}
emmip(M24.4, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Number of pneumatophores per 0.25m2")

emmip(M24.5, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Number of pneumatophores per 0.25m2")
```

## 

## 3j. Pneumatophore height

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manq$Pneu_ht_mm) # right skewed
hist(sqrt(manq$Pneu_ht_mm)) # approx normal
hist(log(manq$Pneu_ht_mm)) # left skewed

plot(manq$Pneu_ht_mm ~ manq$rest_status)
plot(manq$Pneu_ht_mm ~ manq$Elevation) 

ggplot(manq, aes(x = Elevation, y = Pneu_ht_mm)) +
  geom_point() +
  geom_smooth() # potentially non linear, include as polynomial variable

ggplot(manq, aes(x = rest_status, y = Pneu_ht_mm, group = rest_status)) +
  geom_boxplot() 

ggplot(manq, aes(x = Site, y = Pneu_ht_mm, group = Site, fill = rest_status, color = Estuary)) +
  geom_boxplot() 
```

Next, create a model.

-   Distribution type: continuous data as use gaussian distribution, but try transformed data if raw data don't meet assumptions

-   Include Elevation and Estuary and the interaction between rest_status and Estuary as additional fixed predictor variables and Subquadrat nested in quadrat (Combo) nested in Site as a random effect

    -   model doesn't work with the Estuary:Elevation interaction

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M25.1 <- glmmTMB(Pneu_ht_mm ~ Estuary + poly(Elevation,2) + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M25.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M25.1,re.form = NA), resid) 
plotQQunif(M25.1)

# looks pretty good, try sqrt transformed data too

M25.2 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(Elevation,2) + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M25.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M25.2,re.form = NA), resid) 
plotQQunif(M25.2)

anova(M25.1,M25.2)

# sqrt transformed model looks better and has lower AIC, so use that

# check collinearity on a model without interactions
M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + Elevation + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
check_collinearity(M0)

# without elevation
M25.3 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M25.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M25.3,re.form = NA), resid) 
plotQQunif(M25.3)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and its interaction with Estuary

```{r Model_testing}
M25.2 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(Elevation,2) + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

M <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(Elevation,2) + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + poly(Elevation,2) + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

anova(M0,M,M25.2)  

M25.3 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary * rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
M <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
M0 <- glmmTMB(sqrt(Pneu_ht_mm) ~ Estuary + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

anova(M0,M,M25.3) 

joint_tests(M25.2)  

summary(M25.2)  

emmeans(M25.2, ~ rest_status, type = "response")
emmeans(M25.2, ~ rest_status | Estuary, type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M25.2, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore height (mm)")

emmip(M25.2, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore height (mm)")

emmip(M25.3, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore height (mm)")

emmip(M25.3, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore height (mm)")
```

## 

## 3k. Pneumatophore diameter

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manq$Pneu_dia_mm) # slightly right skewed
hist(sqrt(manq$Pneu_dia_mm)) # approx normal?
hist(log(manq$Pneu_dia_mm)) # approx normal but a bit weird

plot(manq$Pneu_dia_mm ~ manq$rest_status)
plot(manq$Pneu_dia_mm ~ manq$Elevation)

ggplot(manq, aes(x = Elevation, y = Pneu_dia_mm)) +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2)) +
  geom_smooth(method = "lm") # not obviously non-linear

ggplot(manq, aes(x = Site, y = Pneu_dia_mm, color = Estuary, fill = rest_status)) +
  geom_boxplot()
```

Next, create a model.

-   Distribution type: continuous data so use gaussian distribution, and try using transformed data if assumptions aren't great without it

-   Include Elevation \* Estuary and Estuary:rest_status as additional fixed predictor variables and Subquadrat nested within quadrat (Combo) nested within Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M26.1 <- glmmTMB(Pneu_dia_mm ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M26.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M26.1,re.form = NA), resid) 
plotQQunif(M26.1)

# ok but see if it improves with transformation

M26.2 <- glmmTMB(sqrt(Pneu_dia_mm) ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M26.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M26.2,re.form = NA), resid) 
plotQQunif(M26.2)

M26.3 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M26.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M26.3,re.form = NA), resid) 
plotQQunif(M26.3)

anova(M26.1,M26.2,M26.3)

# log transformed model is best, use that

# check collinearity on a model without interactions
M0 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary + Elevation + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
check_collinearity(M0)

# without elevation

M26.4 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary * rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

resid <- residuals(simulateResiduals(M26.4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M26.4,re.form = NA), resid) 
plotQQunif(M26.4)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and its interaction with Estuary

```{r Model_testing}
M26.3 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary * Elevation + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

M <- glmmTMB(log(Pneu_dia_mm) ~ Estuary * Elevation + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

M0 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary * Elevation + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

anova(M0,M,M26.3) 

M26.4 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary + rest_status + Estuary:rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
M <- glmmTMB(log(Pneu_dia_mm) ~ Estuary + rest_status + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)
M0 <- glmmTMB(log(Pneu_dia_mm) ~ Estuary + (1|Site/Combo/Subquadrat), family = "gaussian", data = manq)

anova(M0,M,M26.4) 

joint_tests(M26.3)  

summary(M26.3)  

emmeans(M26.3, ~ rest_status, type = "response")
emmeans(M26.3, ~ rest_status | Estuary, type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M26.3, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore diameter")

emmip(M26.4, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Pneumatophore diameter")
```

## 

## ?3m. Leaf dry:fresh ratio

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manleafandherb$dfratio) # approx normal

ggplot(manleafandherb, aes(x = dfratio)) +
  geom_histogram() +
  facet_wrap(~Species)

plot(manleafandherb$dfratio ~ manleafandherb$rest_status)

ggplot(manleafandherb, aes(x = rest_status, y = dfratio, group = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)

plot(manleafandherb$dfratio ~ manleafandherb$Elevation)

ggplot(manleafandherb, aes(x = Elevation, y = dfratio)) +
  geom_point() +
  facet_wrap(~Species)

# insufficient data from any species other than grey mangroves, therefore only use grey mangrove data

ggplot(manleaf_wide_grey, aes(x = Elevation, y = dfratio)) +
  geom_point() +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2)) +
  geom_smooth(method = "lm") # quadratic model looks like a better fit

ggplot(manleaf_wide_grey, aes(x = Site, y = dfratio, color = Estuary, fill = rest_status)) +
  geom_boxplot()
```

Next, create a model.

-   Distribution type: continuous data so use gaussian distribution

-   Include Elevation and Estuary as additional fixed predictor variables and Tree nested within Quadrat (combo) nested within Site as a random effect

    -   can't include Estuary:rest_status interaction because there is only one Maroochy site with restored data for leaf weights

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M28 <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)

resid <- residuals(simulateResiduals(M28), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M28,re.form = NA), resid) 
plotQQunif(M28)

# assumptions look great

# check collinearity on a model without interactions
M0 <- glmmTMB(dfratio ~ Estuary + Elevation + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)
check_collinearity(M0)

# without elevation
M28.1 <- glmmTMB(dfratio ~ Estuary + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)

resid <- residuals(simulateResiduals(M28.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M28.1,re.form = NA), resid) 
plotQQunif(M28.1)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status

```{r Model_testing}
M28 <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)

M0 <- glmmTMB(dfratio ~ Estuary + poly(Elevation,2) + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)

anova(M0,M28)  

M28.1 <- glmmTMB(dfratio ~ Estuary + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)
M0 <- glmmTMB(dfratio ~ Estuary + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleaf_wide_grey)

anova(M0,M28.1)

joint_tests(M28)  

summary(M28)  

emmeans(M28, ~ rest_status, type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M28, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Dry:fresh leaf weight ratio")

emmip(M28.1, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Dry:fresh leaf weight ratio")
```

## 

## 3n. LMA

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}
hist(manleaf_wide_grey$LMA) # approx normal

plot(manleaf_wide_grey$LMA ~ manleaf_wide_grey$rest_status)

plot(manleaf_wide_grey$LMA ~ manleaf_wide_grey$Elevation)

ggplot(manleaf_wide_grey, aes(x = Elevation, y = LMA, color = Estuary)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2)) # include as a polynomial

ggplot(manleaf_wide_grey, aes(x = Site, y = LMA, color = Estuary, fill = rest_status)) +
  geom_boxplot()
```

Next, create a model.

-   Distribution type: continuous data so use a gaussian distribution

-   Include Elevation and Estuary as additional fixed predictor variables and Tree nested within Quadrat (Combo) nested within Site as a random effect

    -   can't include elevation \* estuary interaction as this model had a model convergence problem

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

-   It comes up with NA/NaN warnings related to Site being a random factor, but these are fine

```{r Model_building}
M29 <- glmmTMB(LMA ~ Estuary + poly(Elevation,2) + Tree_sapling + rest_status + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)

resid <- residuals(simulateResiduals(M29), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M29,re.form = NA), resid) 
plotQQunif(M29)

# check collinearity on a model without interactions
M0 <- glmmTMB(LMA ~ Estuary + Elevation + Tree_sapling + rest_status, family = "gaussian", data = manleaf_wide_grey)
check_collinearity(M0)

# without elevation

M29.1 <- glmmTMB(LMA ~ Estuary + Tree_sapling + rest_status + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)

resid <- residuals(simulateResiduals(M29.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M29.1,re.form = NA), resid) 
plotQQunif(M29.1)
```

Next, test the model:

-   use anova to test the model against a null model without YSR to test the importance of YSR

```{r Model_testing}
M29 <- glmmTMB(LMA ~ Estuary + poly(Elevation,2) + Tree_sapling + rest_status + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)

M0 <- glmmTMB(LMA ~ Estuary + poly(Elevation,2) + Tree_sapling + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)

anova(M0,M29)   

M29.1 <- glmmTMB(LMA ~ Estuary + Tree_sapling + rest_status + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)
M0 <- glmmTMB(LMA ~ Estuary + Tree_sapling + (1|Site/Combo/Tree_ID), family = "gaussian", data = manleaf_wide_grey)

anova(M0,M29.1)

joint_tests(M29)  

summary(M29)  

emmeans(M29, ~ rest_status, type = "response")

# can't interpret the coefficients (NAs), so would need to fix this issue if we wanted to use these
```

Finally, plot the results.

```{r Plot}

emmip(M29, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf mass per area")

emmip(M29.1, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf mass per area")
```

## 

## 3o. Leaf area

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

```{r Prep/explore}

hist(manleafandherb$Area) # right skewed
hist(sqrt(manleafandherb$Area)) # still right skewed
hist(log(manleafandherb$Area)) # approx normal

ggplot(manleafandherb, aes(x = Area)) +
  geom_histogram() +
  facet_wrap(~Species)

ggplot(manleafandherb, aes(x = rest_status, y = Area, group = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)

# no restored data for red mangroves, therefore only use grey, orange and river mangrove data

plot(manleafandherb_nored$Area ~ manleafandherb_nored$Elevation)

ggplot(manleafandherb_nored, aes(x = Elevation, y = Area)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Species) # look like different trends, so include a species interaction, but just keep as a linear (not polynomial) term

ggplot(manleafandherb_nored, aes(x = Site, y = Area, color = Estuary, fill = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)
```

Next, create a model.

-   Distribution type: continuous data so use a gaussian distribution, try transformed data if raw data don't meet assumptions

-   Include Elevation \* Estuary as additional fixed predictor variables and Tree nested within quadrat (Combo) nested within Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M30.1 <- glmmTMB(Area ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M30.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M30.1,re.form = NA), resid) 
plotQQunif(M30.1)

M30.2 <- glmmTMB(log(Area) ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M30.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M30.2,re.form = NA), resid) 
plotQQunif(M30.2)

anova(M30.1,M30.2)

# log transformed model is better

M30.3 <- glmmTMB(log(Area) ~ Estuary + Tree_sapling + Species * rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M30.3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M30.3,re.form = NA), resid) 
plotQQunif(M30.3)


# check collinearity on a model without interactions
M0 <- glmmTMB(log(Area) ~ Estuary + Species+Elevation + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
check_collinearity(M0)
```

Next, test the model:

-   use anova to test the model against a null model without rest_status and its interaction with species

```{r Model_testing}
M30.2 <- glmmTMB(log(Area) ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)

M1 <- glmmTMB(log(Area) ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)

M <- glmmTMB(log(Area) ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)

M0 <- glmmTMB(log(Area) ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)

anova(M0,M,M1,M30.2)    

M30.3 <- glmmTMB(log(Area) ~ Estuary + Tree_sapling + Species * rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
M1 <- glmmTMB(log(Area) ~ Estuary + Species + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
M <- glmmTMB(log(Area) ~ Estuary + Species + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)
M0 <- glmmTMB(log(Area) ~ Estuary + Species + Tree_sapling + (1|Site/Combo/Tree), family = "gaussian", data = manleafandherb_nored)

anova(M0,M,M1,M30.3)


joint_tests(M30.2)  

summary(M30.2)  

emmeans(M30.2, ~ rest_status, type = "response")
emmeans(M30.2, ~ rest_status | Species, type = "response")
```

Finally, plot the results.

```{r Plot}
emmip(M30.2, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf area (mm^2)") +
  theme_bw()

emmip(M30.3, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf area (mm^2)") +
  theme_bw()
```

## 3p. Leaf herbivory

First, prepare and explore the data:

-   Use a histogram to visualise the distribution of the response variable

-   Plot relationships between the response and each quantitative predictor variable to decide whether we need to include any polynomial terms in the model

-   Note, red mangroves were only surveyed at natural sites, so we can't test for an effect of restoration status, so it might be pointless to include them - use a dataset without them

```{r Prep/explore}
manleafandherb_nored <- manleafandherb_nored %>% 
  mutate(Herb_prop = case_when(
    `Herb_%` == 0 ~ 0.00001,
    .default = `Herb_%`/100
  ))

hist(manleafandherb_nored$`Herb_%`) # right skewed
hist(sqrt(manleafandherb_nored$`Herb_%`)) # still right skewed
hist(log(manleafandherb_nored$`Herb_%`)) # still right skewed

ggplot(manleafandherb_nored, aes(x = `Herb_%`)) +
  geom_histogram() +
  facet_wrap(~Species)

ggplot(manleafandherb_nored, aes(x = rest_status, y = `Herb_%`, group = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species)

plot(manleafandherb_nored$`Herb_%` ~ manleafandherb_nored$Elevation)

ggplot(manleafandherb_nored, aes(x = Elevation, y = `Herb_%`)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Species) # look like different trends, so include a species interaction, but just keep as a linear (not polynomial) term

ggplot(manleafandherb_nored, aes(x = Site, y = `Herb_%`, color = Estuary, fill = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species) +
  ylim(0,20)
```

Next, create a model.

-   Distribution type: beta_family or can try tweedie (proportion data, zero inflated)

-   Include Elevation \* Estuary as additional fixed predictor variables and Site as a random effect

-   Check assumptions using resid and scatter.smooth, plotQQunif and check_collinearity with a model without interactions

```{r Model_building}
M31.1 <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M31.1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M31.1,re.form = NA), resid) 
plotQQunif(M31.1)

M31.2 <- glmmTMB(`Herb_%` ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "tweedie", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M31.2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M31.2,re.form = NA), resid) 
plotQQunif(M31.2)

anova(M31.1,M31.2)

# beta model looks better but still weird

M31.4 <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M31.4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M31.4,re.form = NA), resid) 
plotQQunif(M31.4)

# check collinearity on a model without interactions
M0 <- glmmTMB(Herb_prop ~ Estuary + Species+Elevation + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
check_collinearity(M0)

# without elevation

M31.5 <- glmmTMB(Herb_prop ~ Estuary + Tree_sapling + Species * rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
  
resid <- residuals(simulateResiduals(M31.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M31.5,re.form = NA), resid) 
plotQQunif(M31.5)
```

Next, test the model:

-   use anova to test the model against a null model without YSR to test the importance of YSR

```{r Model_testing}
M31.4 <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M1 <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M0 <- glmmTMB(Herb_prop ~ Estuary + Species*Elevation + Estuary:Elevation + Tree_sapling + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)

anova(M1, M0,M,M31.4)

M31.5 <- glmmTMB(Herb_prop ~ Estuary + Species + Tree_sapling + rest_status + Species:rest_status + Estuary:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M1 <- glmmTMB(Herb_prop ~ Estuary + Species + Tree_sapling + rest_status + Species:rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M <- glmmTMB(Herb_prop ~ Estuary + Species + Tree_sapling + rest_status + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)
M0 <- glmmTMB(Herb_prop ~ Estuary + Species + Tree_sapling + (1|Site/Combo/Tree), family = "beta_family", data = manleafandherb_nored)

anova(M1, M0,M,M31.5)

joint_tests(M31.4)  

summary(M31.4)  

emmeans(M31.4, ~ rest_status | Species, type = "response")
emmeans(M31.4, ~ rest_status | Estuary, type = "response")
```

Finally, plot the results.

```{r Plot}

emmip(M31.4, ~ rest_status | Species, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf herbivory (proportion)")

emmip(M31.5, ~ rest_status | Estuary, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Restoration status", ylab = "Leaf herbivory (proportion)")
```

## 

## 
