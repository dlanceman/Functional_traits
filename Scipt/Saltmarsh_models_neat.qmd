---
title: "Saltmarsh models neat"
author: "Dana Lanceman"
format: html
editor: visual
---

## Saltmarsh functional traits modelling

This code is for analysis of saltmarsh functional traits analysis, analysing for associations between functional traits and time since restoration and between restoring and natural sites.

# 1. Set up

First, **load packages**.

```{r Packages, echo = FALSE}
#install.packages("readxl")
#install.packages("tidyverse")
#install.packages("lme4")
#install.packages("MuMIn")
#install.packages("car")
#install.packages("performance")
#install.packages("glmmTMB")
#install.packages("bbmle")
#install.packages("GLMMadaptive")
#install.packages("ggeffects")
#install.packages("emmeans")
#install.packages("robustlmm")
#install.packages("mvabund")
#install.packages("plyr")
#install.packages("ecostats")
#install.packages("viridis")
#install.packages("betareg")
#install.packages("ggpubr")
#install.packages("countreg", repos="http://R-Forge.R-project.org", type = "binary")
#install.packages("statmod")
#install.packages("lmerTest")
#install.packages("sjPlot")
#install.packages("DHARMa")
#install.packages("MCMCglmm")
#install.packages("ggbreak")
#install.packages("multcomp")
#install.packages("ggfortify")

library(plyr)
library(readxl)
library(tidyverse)
library(lme4)
library(MuMIn)
library(car)
library(performance)
library(bbmle)
library(GLMMadaptive)
library(ggeffects)
library(emmeans)
library(robustlmm)
library(mvabund)
require(statmod)
library(ecostats)
library(viridis)
library(betareg)
library(ggpubr)
library(countreg)
library(lmerTest)
library(sjPlot)
library(DHARMa)
library(MCMCglmm)
library(ggbreak) 
require(tweedie)
library(glmmTMB)
library(multcomp)
library(ggfortify)
```

### Load data

-   using setwd() to set the working directory where the data are stored

-   "salt" is the overall saltmarsh dataset

    -   creating a "Quadrat_area" column to use as an offset

    -   creating a "total_stems" column for total stem count per 1m2 for each species to standardise stem counts for plots. Round makes it an integer.

    -   reassigning Buds and Flowers as numeric variables

    -   standardising Seeds wording

    -   creating a "rest_status" column for restoration status where 1 = restored and 0 = natural

    -   creating a "YSR" column for years since restoration

-   "salt_comm_comp" is the dataset for saltmarsh community composition, laid out in an appropriate wide format for community composition analysis

```{r Data, echo = FALSE}
setwd("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits")

salt <- read_excel("Data/Functional_traits_combined_data.xlsx", sheet = "Saltmarsh") %>% 
  arrange(Date, Time) %>% 
  mutate(Quadrat_area = Quad_length_cm^2, 
    total_stems = round(Stems * 10000/Quad_length_cm^2), 
         Buds = case_when( 
           Buds == "Yes" ~ 1,
           Buds == "No" ~ 0,
           Buds == "Unknown" ~ NA,
           Buds == "NA" ~ NA
         ),
         Flowers = case_when(  
           Flowers == "Yes" ~ 1,
           Flowers == "No" ~ 0,
           Flowers == "Unknown" ~ NA,
           Flowers == "NA" ~ NA
         ),
        Seeds = case_when( 
          Seeds == "Yes" ~ "Yes",
          Seeds == "Seeds" ~ "Yes",
          Seeds == "No" ~ "No",
          Seeds == "Lots" ~ "Lots",
          Seeds == "Some" ~ "Some",
          Seeds == "some" ~ "Some",
          Seeds == "Few" ~ "Few",
          Seeds == "Very few" ~ "Very few",
          Seeds == "NA" ~ NA,
          Seeds == "Unknown" ~ NA
          ),
         rest_status = case_when(
           Site == "AE" ~ as.numeric("1"),
           Site == "HS" ~ as.numeric("1"),
           Site == "TA" ~ as.numeric("1"),
           Site == "TB" ~ as.numeric("1"),
           Site == "CC" ~ as.numeric("1"),
           Site == "CF" ~ as.numeric("1"),
           Site == "DLW" ~ as.numeric("1"),
           .default = as.numeric("0"), 
         ),
         rest_year = case_when(
           Site == "AE" ~ as.numeric("2017"),
           Site == "HS" ~ as.numeric("2011"),
           Site == "TA" ~ as.numeric("2007"),
           Site == "TB" ~ as.numeric("2012"),
           Site == "CC" ~ as.numeric("1990"),
           Site == "CF" ~ as.numeric("1993"),
           Site == "DLW" ~ as.numeric("2014")
         ), # add a column for restoration years
         YSR = case_when(
           Site == "AE" ~ as.numeric("6"),
           Site == "HS" ~ as.numeric("12"),
           Site == "TA" ~ as.numeric("16"),
           Site == "TB" ~ as.numeric("11"),
           Site == "CC" ~ as.numeric("33"),
           Site == "CF" ~ as.numeric("30"),
           Site == "DLW" ~ as.numeric("9") 
         ))  

salt_comm_comp <- read_excel("Data/salt_comm_comp.xlsx", sheet = "alldata")
salt_comm_comp$YSR <- as.numeric(salt_comm_comp$YSR)
```

### Manipulate data

-   Create a "DomSpecies" column to summarise which species is dominant (greatest % cover) in each quadrat, including unvegetated.

    -   Multiple species are initially listed if there is a tie in % covers, and then these tied dominant species are manually edited to list the "bulkier" species

        -   i.e. Juncus \> Triglochin, Sarcocornia \> GSG, Juncus \> Sporobolus

    -   The "DomSpeciesSuperSimp" column further simplifies this with only three options for dominant species - Sporobolus, Sarcocornia or Other

-   Create a "sp_prop" column for proportion cover of each species (species cover/overall cover)

-   Reassign Quadrat as an explictly nested variable within Site

```{r Manipulations}
salt <- salt %>%
  group_by(Combo) %>% 
  mutate(
    MaxSpeciesCover = max(`Sp_cover_%`),
    DomSpecies = ifelse(100 - `Total_cover_%` > MaxSpeciesCover, "unvegetated", 
                        paste(unique(Species[`Sp_cover_%` == MaxSpeciesCover]), collapse = ", "))) %>% 
  ungroup() %>%
  dplyr::select(-MaxSpeciesCover) # Remove MaxSpeciesCover colummn

salt <- salt %>% mutate(
  DomSpecies = case_when(
    DomSpecies == "Juncus_kraussii, Sporobolus" ~ "Juncus_kraussii",
    DomSpecies == "Juncus_kraussii, Triglochin" ~ "Juncus_kraussii",
    DomSpecies == "GSG, Sarcocornia" ~ "Sarcocornia",
    .default = DomSpecies
  ),
  DomSpeciesSuperSimp = case_when(
    DomSpecies == "Sporobolus" ~ "Sporobolus",
    DomSpecies == "Sarcocornia" ~ "Sarcocornia",
    .default = "Other"
  )
)

salt <- salt %>% mutate(sp_prop = `Sp_cover_%`/`Total_cover_%`)

salt$Quadrat <- as.character(salt$Quadrat)
salt$Quadrat.f <- factor(interaction(salt$Site, salt$Quadrat, sep = ":"))
salt$Quadrat.f <- as.character(salt$Quadrat.f)
```

### Outliers

Next, let's check for outliers that are ecologically unrealistic and would have resulted from errors in the data.

Set up a function for visualising outliers:

```{r Outliers_function}
cleveland_plot <- function(vector,axislab){
  par(mfrow= c(1,2), mar = c(5,4,2,1)) # set some parameters for the plot
  boxplot(vector,  ylab = axislab)
  dotchart(vector, xlab = axislab,
         ylab = "Order of the data") 
}
```

Run this subset on all data for community-level variables, and on specific species individually for species- and stem-level variables so we can see if any measured observations from a species seem unlikely for that particular species.

```{r Outliers_allspecies}
cleveland_plot(salt$`Total_cover_%`, "Total cover (%)") # left skewed, has outliers but values should be realistic
cleveland_plot(salt$Burrows_0.5x0.5, "Number of burrows") # right skewed (and zero inflated), has outliers but values are realistic

```

For sporobolus.

```{r Outliers_sporobolus}
spor <- salt %>%
  filter(Species == "Sporobolus")
cleveland_plot(spor$`Sp_cover_%`, "Species cover (%)") # somewhat left skewed but decent. No outliers
cleveland_plot(spor$Stem_ht_mm, "Stem height (mm)") # there are only a few values with height >600. When investigating- this is realistic for each large height value. Overall the distribution is fairly evenly spread.
cleveland_plot(spor$Stem_dia_mm, "Stem diameter (mm)") # right skewed. There are some very large values that need investigating - plant net doesn't state the regular stem diameter so don't exclude. They are little overestimates, and the 0.1mm measurements are likely too low, but should be OK and no reason to remove, so retain
cleveland_plot(spor$total_stems, "Stem density (number of stems)") # right skewed
```

For sarcocornia.

```{r Outliers_sarcocornia}
sarc <- salt %>%
  filter(Species == "Sarcocornia")
cleveland_plot(sarc$`Sp_cover_%`, "Species cover (%)") # evenly spread, no outliers
cleveland_plot(sarc$Stem_ht_mm, "Stem height (mm)") # evenly distributed. One relatively large value but it is realistic. Two relatively small values but realistic.
cleveland_plot(sarc$Stem_dia_mm, "Stem diameter (mm)") # slightly right skewed but very acceptable distribution. Three larger values but realistic
cleveland_plot(sarc$total_stems, "Stem density (number of stems)") # right skewed, some relatively high values but realistic
```

For triglochin.

```{r Outliers_triglochin}
trig <- salt %>%
  filter(Species == "Triglochin")
cleveland_plot(trig$`Sp_cover_%`, "Species cover (%)") # very right skewed. Potential outlier high extreme value - checked photo and this is accurate.
cleveland_plot(trig$Stem_ht_mm, "Stem height (mm)") # fairly evenly distributed except some very high potential outliers. There's no evidence for stems as high as 860mm or 556mm in photos and according to plantnet this species only grows to ~30cm, so 860 and 556 are likely data errors. Other high measurements are likely OK.
cleveland_plot(trig$Stem_dia_mm, "Stem diameter (mm)") # there are some extreme outliers that need investigating. According to plantnet, leaf diameters (what we're calling stems) are usually 1-3mm. 7 out of 8 extreme values of 4 or more are from the same quadrat - potentially a consistent error with measuring there. These extreme values should be removed. The distribution is inflated by values of 1.
cleveland_plot(trig$total_stems, "Stem density (number of stems)") # one extreme value but realistic. somewhat right skewed (mostly because of this value)
```

For pneumatophores.

```{r Outliers_pneumatophores}
pneu <- salt %>%
  filter(Species == "Pneumatophores")
cleveland_plot(pneu$Stem_ht_mm, "Stem height (mm)") # evenly distributed, no outliers
cleveland_plot(pneu$Stem_dia_mm, "Stem diameter (mm)") # evenly distributed, one potential low outlier. This value is unrealistic and should be removed.
cleveland_plot(pneu$total_stems, "Stem density (number of stems)") # right skewed. One potential high outlier, but it's realistic 
```

A couple other species had potential data issues flagged in the notes - check if these seem like outliers.

```{r Outliers_other}
junc.k <- salt %>% 
  filter(Species == "Juncus_kraussii")

aster <- salt %>% 
  filter(Species == "Aster")

# Juncus - need to investigate consistency of stem measurements
cleveland_plot(junc.k$Stem_ht_mm, "Stem height (mm)") # looks great
cleveland_plot(junc.k$Stem_dia_mm, "Stem diameter (mm)") # 2 of last (top) three look a bit large, but these weren't the data points I made a potential note about and they are close to plant net's guidelines for width (1.8-4.5mm), so retain. Slight right skew.

# Aster - need to investigate stem height (potentially measured to the flower before 4:08pm 18/4/23)
cleveland_plot(aster$Stem_ht_mm, "Stem height (mm)") # balanced distribution. There are no very high measurements after around the first 1/3 of data points. However, there are only 12 data points before 4:08pm 18/4/23 so there are large data points after this. We don't know how much to offset potential flower measurements so should retain with care.
```

Remove ecologically unrealistic outliers based on the above.

```{r Outliers}
salt[443,20] <- NA # remove triglochin measurement with unrealistic stem diameter >4mm
salt[c(738:744), 20] <- NA # remove triglochin measurements with unrealistic stem diameter >4mm
salt[802,19] <- NA # remove triglochin measurement with unrealistic stem height 556mm
salt[1271,19] <- NA # remove triglochin measurement with unrealistic stem height 860mm
salt[112,20] <- NA # remove pneumatophore measurement with unrealistic diameter 1mm
salt[c(862,917),20] <- NA # remove sporobolus measurements with unrealistic diameters > 4mm
```

### Prepare and subset dataframes

Create a "salt_comm" dataframe for community-level variables.

-   Need to delete duplicates in this dataset, since there are many rows for each community-level variable given that there are subreplicates of other variables within each community-level measurement.

-   Also remove rows that are irrelevant for community composition

-   Turn total cover into a proportion between 0 and 1 instead of between 0 and 100

    -   include a tiny offset since it doesn't like values of exactly 1 - must be below 1

```{r Community}
salt_comm <- salt %>% distinct(Combo, .keep_all = TRUE) 
salt_comm <- salt_comm[,-c(11:20,22,26,27,33)] 
salt_comm <- salt_comm %>% mutate(total_cover_prop = `Total_cover_%`/100)
```

Subset datasets:

-   salt_H for just Hunter estuary data

-   salt_H_rest for just Hunter estuary restored data

-   salt_H_nat for just Hunter estuary natural data

-   salt_comm_rest for just restored community-level data

-   salt_comm_nat for just natural community-level data

-   salt_comm_rest_H for just restored community-level data in Hunter estuary

-   salt_comm_nat_H for just natural community-level data in Hunter estuary

-   salt_comm_H for just Hunter estuary community-level data

-   salt_comm_comp_H for just Hunter estuary community composition data

-   salt_comm_comp_H_res for just Hunter estuary restored community composition data

-   salt_comm_comp_H_nat for just Hunter estuary natural community composition data

```{r Subset}
salt_H <- salt %>% subset(Estuary == "Hunter")

salt_H_rest <- salt_H %>% subset(rest_status == 1)

salt_H_nat <- salt_H %>% subset(rest_status == 0)

salt_comm_rest <- salt_comm %>% subset(salt_comm$rest_status == 1)
salt_comm_nat <- salt_comm %>% subset(salt_comm$rest_status == 0)
salt_comm_rest_H <- salt_comm_rest %>% subset(salt_comm_rest$Estuary == "Hunter")
salt_comm_nat_H <- salt_comm_nat %>% subset(salt_comm_nat$Estuary == "Hunter")
salt_comm_H <- salt_comm %>% subset(salt_comm$Estuary == "Hunter")

salt_comm_comp_H <- salt_comm_comp %>% subset(Estuary == "Hunter")
salt_comm_comp_H_res <- salt_comm_comp_H %>% subset(rest_status == "1")
salt_comm_comp_H_nat <- salt_comm_comp_H %>% subset(rest_status == "0")
```

### Correlation checks

Before running models, we need to make sure none of our dependent variables are strongly correlated. If so, we cannot include all variables in analysis.

Our dependent variables of interest are:

-   Community composition (multivariate) (can't really test for relationships here as it's a matrix)

-   Total cover (univariate)

-   Burrows

-   Stem density

-   Stem diameter

-   Stem height

-   Reproduction (presence/absence) (can't really test for relationships here as they're binary variables?)

Check for correlations using a correlation matrix of correlation coefficients and by creating correlation plots.

Exclude variables if their correlation coefficient is very large (e.g. \>0.7).

```{r Correlations}
cor(salt[,c(9,10,19,20,27)], use = "pairwise.complete.obs") 

salt_numeric <- salt[,c(9,10,19,20,27)]
plot(salt_numeric)

plot(log(salt_numeric$Burrows_0.5x0.5), log(salt_numeric$Stem_ht_mm))
```

# 2. Years Since Restoration Models

Before we create any of these models, let's inspect the data space we're working with:

-   relationship between YSR and Elevation (numeric predictors)
    -   model this relationship and test the model

```{r Predictor_association}
plot(salt_comm_rest_H$Elevation ~ salt_comm_rest_H$YSR) # could be non-linear

cor(salt_comm_rest_H$Elevation, salt_comm_rest_H$YSR)

hist(salt_comm_rest_H$Elevation) # approx normal distribution

M <- glmmTMB(Elevation ~ DomSpeciesSuperSimp + poly(YSR,2) + (1|Site), family = "gaussian", data = salt_comm_rest_H)

# check assumptions
resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M,re.form = NA), resid) 
plotQQunif(M)

M0 <- glmmTMB(Elevation ~ DomSpeciesSuperSimp + YSR + (1|Site), family = "gaussian", data = salt_comm_rest_H)
M00 <- glmmTMB(Elevation ~ DomSpeciesSuperSimp + (1|Site), family = "gaussian", data = salt_comm_rest_H)

anova(M,M0,M00)

emmip(M, ~ YSR, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Elevation (m)")

# boxplots

S_Elev_rest <- ggplot(salt_comm_rest, aes(x=YSR, y=Elevation, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter(height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 18), # was 32
          axis.title = element_text(size = 22)) + # was 36
  xlab("Years since restoration") +
  ylab("Elevation (m)") +
  xlim(0,35)  +
  ylim(-0.5,1)
S_Elev_rest

S_Elev_nat <- ggplot(salt_comm_nat, aes(x=Site, y=Elevation, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
  guides(fill = guide_legend(position = "inside")) +
    theme(legend.position.inside = c(0.4,0.2),
          axis.text = element_text(size = 18), # was 32
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 22)) + # was 36
  xlab("Site") +
  ylab("")  +
  ylim(-0.5,1)
S_Elev_nat

# plot natural and restored together
ggarrange(S_Elev_rest,S_Elev_nat,ncol =2,nrow=1,widths = c(2,1.3))
# print at 1500 x 800 for paper, 2400 x 800 for preso

#ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Saltmarsh_elevation_preso.jpg", width = 6000, height = 2000, units = "px")
```

Given that elevations are lower with lower YSRs and higher with higher YSRs, we don't have a complete dataspace so can't model across a complete dataspace (i.e. missing data for low elevation and high YSR and low YSR and high elevation). Therefore, probably safest not to include an interaction between Elevation and YSR as the interaction would only be able to interpreted in small sections of the data.

## 2a. Community composition

First, let's prep the dataset by:

-   checking which columns only have zeroes and removing these

-   checking which species have at least 5 occurrences (less is too few occurrences for analysis) and subsetting for only these species

    -   species with at least 5 values are Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites.

    -   also remove Pneumatophores - they are not a saltmarsh species so are not that relevant for understanding community composition.

-   converting the dataset into long format, which is suitable for glmmTMB

    -   also create two alternative proportional cover columns with slight offsets to meet distribution requirements
        -   for beta distribution, can't have zeroes or ones, so offset these accordingly
        -   for zero-inflated beta distribution, can't have ones but can have zeroes, so offset ones only

-   recoding Species as a factor variable (for post hoc tests)

```{r Prep}
salt_comm_comp_H_res[,1:25] %>% colSums() # the last four columns are all zeroes
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:21,26:31)]

colSums(salt_comm_comp_H_res != 0) 
salt_comm_comp_H_res <- salt_comm_comp_H_res[,c(1:3,8,10,12,22:27)] 

comm_comp_long <- salt_comm_comp_H_res %>% 
  pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Bolboschoenus, Aster, Phragmites), names_to = "Species", values_to = "Percent_cover") %>% 
  unite("Combo",2:3,remove = FALSE) %>% 
  mutate(cover_prop = Percent_cover/100,
         cover_prop_no01 = case_when(
            cover_prop == 0 ~ 0.0001,
            cover_prop == 1 ~ 0.9999,
    .default = Percent_cover/100),
        cover_prop_no1 = case_when(
          cover_prop == 1 ~ 0.9999,
          .default = cover_prop)
         )

comm_comp_long$Species <- as.factor(comm_comp_long$Species)
```

Now, explore the data:

-   relationships between predictor variables and the dependent variable (to check if there seems to be a linear or non-linear relationship)

-   distribution of dependent variable with and without transformations

```{r Explore}
hist(comm_comp_long$Percent_cover)

ggplot(data = comm_comp_long, aes(x = YSR, y = Percent_cover)) +
  geom_point() +
  facet_wrap(~Species) #no evidence of non-linearity
ggplot(data = comm_comp_long, aes(x = Elevation, y = Percent_cover)) +
  geom_point() +
  facet_wrap(~Species) # no evidence of nonlinearity

# distribution of data
ggplot(data = comm_comp_long, aes(x = Percent_cover)) +
  geom_histogram() +
  facet_wrap(~Species) # highly zero inflated and right skewed
ggplot(data = comm_comp_long, aes(x = log(Percent_cover + 0.00001))) +
  geom_histogram() +
  facet_wrap(~Species) # log not helpful
ggplot(data = comm_comp_long, aes(x = sqrt(cover_prop))) +
  geom_histogram() +
  facet_wrap(~Species) # maybe slightly better
```

Now, create a model:

-   As we're modelling community composition, we want to model how each species' percent cover varies with YSR after controlling for elevation, so model the interaction between Species and (Elevation + YSR)

-   Include a random effect of site

-   All species' covers within a quadrat (Combo) are dependent on one another, so need to add a reduced rank correlation structure for this

-   Use a beta distribution, as the data are proportion data and do not appear normally distributed

-   Use zero-inflation if residuals don't look good without it, as the data are highly zero-inflated

Check the assumptions of the model using resid and scatter.smooth and plotQQunif.

```{r Model_building}
M <- glmmTMB(cover_prop_no01 ~ Species:(Elevation + YSR) + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = beta_family(link = "logit"))

# check assumptions
resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M,re.form = NA), resid) # scaled residuals plot - not good.
plotQQunif(M) # not good


# therefore try zero-inflated model
M1 <- glmmTMB(cover_prop_no1 ~ Species:(Elevation + YSR) + (1|Site/Combo) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = beta_family(link = "logit"), ziformula = ~1)

# check assumptions
resid <- residuals(simulateResiduals(M1), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M1,re.form = NA), resid)   # great
plotQQunif(M1)   # great

# check collinearity on a model without interaction terms
M0 <- glmmTMB(cover_prop_no1 ~ Species + Elevation + YSR + (1|Site) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = beta_family(link = "logit"), ziformula = ~1)
check_collinearity(M0) # all low

# null model without the term of interest (Species:YSR) to test whether that term explains variation in the model
M0 <- glmmTMB(cover_prop_no1 ~ Species:Elevation + (1|Site/Combo) + rr(Species+0|Combo, d = 1), data = comm_comp_long, family = beta_family(link = "logit"), ziformula = ~1)


```

Generate model results:

-   anova to test whether community composition changes with YSR (log likelihood p value and compare AICs)

-   summary for parameter estimates - differences between each groups

-   emtrends for the linear rate of change for each species and confidence intervals

```{r Model_testing}

anova(M1, M0)

summary(M1) # get parameter estimates

em <- emmeans(M1, ~ YSR, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

em

plot(em)

em2 <- emtrends(M1, var = "YSR", specs = ~Species)

em2

plot(em2)
```

Plot

-   emmip for predicted values

-   ggplot for raw data

-   Create a PCA plot including all natural and restored data to visualise patterns

```{r Plot}
p <- emmip(M1, ~ YSR | Species, at = list(YSR = c(6,10,15,20,25,30,33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Predicted proportion cover") +
  geom_jitter(aes(x = YSR, y = cover_prop), data = comm_comp_long) +
  theme_bw()
p

# make data longer
salt_comm_comp_H_res_long <- salt_comm_comp_H_res %>% pivot_longer(cols = c(Sarcocornia, Sporobolus, Triglochin, Aster, Bolboschoenus, Phragmites), names_to = "Species", values_to = "Percent_cover")

ggplot(data = salt_comm_comp_H_res_long, aes(x = as.factor(YSR), y = Percent_cover, fill = Species)) +
  geom_boxplot() +
  facet_wrap(~Species) +
  scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 1, option = "A") +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Species percent cover") +
  theme(strip.text = element_text(size = 24))
# print at 1500 x 1200


salt_comm_comp <- salt_comm_comp %>% 
  mutate(rest_status = case_when(
    rest_status == 1 ~ "Restored",
    rest_status == 0 ~ "Natural"
  ))
spdata <- salt_comm_comp[,c(1,2,3,8,10,12)]
pca_res <- prcomp(spdata, scale. = TRUE)
autoplot(pca_res, data = salt_comm_comp, color = "YSR", size = 2,
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 3, loadings.label.color = 'black') +
  theme_classic() +
  scale_color_viridis(begin = 0.1, end = 0.8, option = "D")

ggsave("C:/Users/z5204897/OneDrive - UNSW/Desktop/PhD/Data_analysis/Project/Functional_traits/Output/Saltmarsh_comm_comp.jpg", width = 2000, height = 1500, units = "px")

```

## 2b. Total cover

We expect to create a model along these lines:

-   Total cover \~ YSR + DomSpecies + Elevation

-   Site is a random factor

-   beta distribution (proportional data with 2 categories - cover and non cover)

First, explore the data:

-   distribution of 'total_cover' - as is and with an inverse log transformation

-   type of relationship between each predictor and total cover

-   data space between predictors - YSR & dominant species; YSR & Elevation

-   explore the relationship with elevation within each site, compared to the overall relationship between sites

Also prepare data for a distribution that doesn't take values of 1 by creating a new total_cover_prop_no1 variable that has a slight offset to remove 1s from the dataset.

```{r Explore/prep}
hist(salt_comm_rest_H$total_cover_prop) # highly left skewed
hist(log(1- salt_comm_rest_H$total_cover_prop)) # closer to normal

plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$YSR) # possibly non-linear
plot(salt_comm_rest_H$total_cover_prop ~ salt_comm_rest_H$Elevation) # possibly non-linear

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = total_cover_prop, group = DomSpeciesSuperSimp)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp)

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = Elevation, group = DomSpeciesSuperSimp)) +
  geom_point() +
  facet_wrap(~DomSpeciesSuperSimp)

salt_comm_rest_H$total_cover_prop_no1 <- salt_comm_rest_H$total_cover_prop - 0.0001
```

Next, create a model.

-   use a beta distribution because the dependent variable is proportion data and the raw distribution is highly left skewed. The proportion data need to be offset slightly from 1 to fit beta family requirements of 0 \< y \< 1.

-   both YSR and elevation looked like they might have a non-linear relationship with total_cover when we plotted them earlier so include them as polynomial variables

-   include an interaction between DomSpeciesSuperSimp and YSR because it looks like trends differ between dominant species, but keep in mind there are limited data at high YSRs for Other and Sarcocornia when interpreting the results

-   there are insufficient data across the matrix to model interactions between elevation and YSR

-   check assumptions using resid and scatter.smooth

-   check covariance between predictors using check_collinearity on a model without polynomial terms (Mn)

-   test model using anova and comparing it to a model without the polynomial YSR (M) and a model with no YSR term at all (M0)

-   calculate parameter estimates using summary and emmeans

```{r Model}
M2 <- glmmTMB(total_cover_prop_no1 ~ poly(Elevation,2) + DomSpeciesSuperSimp * poly(YSR,2) + (1|Site), data = salt_comm_rest_H, family = "beta_family")

M1 <- glmmTMB(total_cover_prop_no1 ~ poly(Elevation,2) + DomSpeciesSuperSimp + poly(YSR,2) + (1|Site), data = salt_comm_rest_H, family = "beta_family")

M <- glmmTMB(total_cover_prop_no1 ~ poly(Elevation,2) + DomSpeciesSuperSimp + YSR + (1|Site), data = salt_comm_rest_H, family = "beta_family")

M0 <- glmmTMB(total_cover_prop_no1 ~ poly(Elevation,2) + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H, family = "beta_family")

resid <- residuals(simulateResiduals(M2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M2,re.form = NA), resid) # looks great
plotQQunif(M2) # great

Mn <- glmmTMB(total_cover_prop_no1 ~ Elevation + DomSpeciesSuperSimp + YSR + (1|Site), data = salt_comm_rest_H, family = "beta_family")
check_collinearity(Mn) # all low

anova(M2,M1, M0, M)
summary(M2)
emmeans(M2, pairwise~DomSpeciesSuperSimp)

joint_tests(M2)

em <- emmeans(M2, ~ YSR, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

em

plot(em)

em1 <- emmeans(M2, ~ YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

em1

plot(em1)

em2 <- emmeans(M2, ~ Elevation, at = list(Elevation = c(-0.2,0,0.2,0.4,0.6,0.8)), type = "response")

em2

plot(em2)
```

Now, create some plots.

-   boxplot of total cover at different YSRs

-   boxplot of total cover at different natural sites

-   combine these

-   predicted results

-   **not sure geom_smooth works for emmip - it's making the same line but not sure we can trust the confidence intervals. Want some way of making smoothed CIs though!**

```{r Plot}
S_Cov_rest <- ggplot(salt_comm_rest_H, aes(x=YSR, y=total_cover_prop*100, group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter(height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 32),
          axis.title = element_text(size = 36)) +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (%)") +
  xlim(0,35) + 
  ylim(0,100) 
S_Cov_rest

S_Cov_nat <- ggplot(salt_comm_nat_H, aes(x=Site, y=`Total_cover_%`, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 32),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 36)) +
  xlab("Site") +
  ylab("")  +
  ylim(0,100)
S_Cov_nat

# plot natural and restored together
ggarrange(S_Cov_rest,S_Cov_nat,ncol =2,nrow=1,widths = c(3,1))
# print at 1500 x 800 for paper, 2400 x 800 for preso

em1 <- emmip(M2, ~ YSR, at = list(YSR = c(6,10,15,20,25,30,33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Predicted proportion cover") +
  geom_jitter(aes(x = YSR, y = total_cover_prop_no1), data = salt_comm_rest_H) +
  theme_bw()

em1

em2 <- emmip(M2, ~ Elevation, at = list(Elevation = c(-0.2,0,0.2,0.4,0.6,0.8)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Elevation", ylab = "Predicted proportion cover") +
  geom_jitter(aes(x = Elevation, y = total_cover_prop_no1), data = salt_comm_rest_H) +
  theme_bw()

em2

ggarrange(em1, em2, ncol = 1, nrow = 2)

emmip(M2, ~ YSR | Elevation, at = list(YSR = c(6,10,15,20,25,30,33), Elevation = c(-0.2,0,0.2,0.4,0.6,0.8)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Predicted proportion cover") 

emmip(M2, ~ YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,10,15,20,25,30,33)), type = "response", engine = "ggplot", xlab = "Years since restoration", ylab = "Predicted proportion cover") +
  geom_point(aes(x = YSR, y = total_cover_prop_no1), data = salt_comm_rest_H) +
  geom_smooth(color = 'black') +
  theme_bw()

# fit a model not including elevation - for plotting
M2.1 <- glmmTMB(total_cover_prop_no1 ~ DomSpeciesSuperSimp + poly(YSR,2) + DomSpeciesSuperSimp:YSR + (1|Site), data = salt_comm_rest_H, family = "beta_family")

emmip(M2.1, ~ YSR | DomSpeciesSuperSimp, at = list(YSR = c(6,10,15,20,25,30,33)), type = "response", engine = "ggplot", xlab = "Years since restoration", ylab = "Predicted proportion cover") +
  geom_point(aes(x = YSR, y = total_cover_prop_no1), data = salt_comm_rest_H) +
  geom_smooth(color = 'black') +
  theme_bw()

em <- emmeans(M2, ~ YSR|DomSpeciesSuperSimp* Elevation, at = list(YSR = c(6,11,12,16,30,33),Elevation = 0.32 ), type= "response")

ggplot(data = salt_comm_rest_H, aes(x = YSR, y = total_cover_prop * 100, group = DomSpeciesSuperSimp, color = DomSpeciesSuperSimp)) +
  geom_jitter() +
  facet_wrap(~DomSpeciesSuperSimp)+
  geom_point(data = data.frame(em), aes(y = response * 100), group = NA, colour = "black", shape = 7, size = 3)+
  geom_line(data = data.frame(em), aes(y = response * 100), group = 1, colour = "black", linewidth = 1) +
  scale_y_continuous(trans = "log1p", limits = c(5,102)) +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (%)") + 
  scale_color_viridis(discrete = TRUE, begin = 0.3, end = 0.8, option = "A")

# natural data
S_Cov_nat2 <- ggplot(salt_comm_nat, aes(x=Site, y=`Total_cover_%`, fill=DomSpeciesSuperSimp, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.3, end = 0.8, option = "A") +
    theme_bw() +
    #guides(fill = guide_legend(position = "inside")) +
    theme(#legend.position.inside = c(0.8,0.2),
          legend.position = "none",
          #axis.text = element_text(size = 32),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          #axis.title = element_text(size = 36)
          ) +
  xlab("Natural site") +
  ylab("")  +
  #labs(fill = "Dominant Species") +
  scale_y_continuous(trans = "log1p", limits = c(5,102)) +
  facet_wrap(~DomSpeciesSuperSimp)
S_Cov_nat2

ggarrange(S_Cov_rest2, S_Cov_nat2, ncol =2,nrow=1,widths = c(2,1)) 
```

Accounting for elevation relationships:

-   The current model shows decreasing trends with YSR when controlling for elevation, because it models that at any given elevation, total cover decreases with increasing elevation, and with time since restoration, elevation increases.

-   However, there is an interaction between the random effect of Site and elevation that we need to account for, as relationships between elevation and total cover differ within and between sites

-   Plot relationships between elevation and total cover at each site, and across sites.

```{r Within_between_model}

# Elevation relationships
ggplot(salt_comm_rest_H , aes( Elevation,total_cover_prop))+geom_jitter()+facet_wrap(~Site)

#Here we calculate the mean elevation per site, and also, the deviation within a site from the site mean.  
salt_comm_rest_H  = salt_comm_rest_H  %>%
  group_by(Site) %>%
  summarise( site_mean_elev = mean(Elevation)) %>%
  right_join(salt_comm_rest_H ) %>%
  mutate( site_within_elev = Elevation - site_mean_elev)

ggplot(salt_comm_rest_H , aes( site_mean_elev,total_cover_prop))+geom_jitter()

#MODEL
M_WB <- glmmTMB(total_cover_prop_no1 ~ site_mean_elev + site_within_elev + DomSpeciesSuperSimp*YSR + (1|Site), data = salt_comm_rest_H, family = beta_family(link = "logit"))

# Also try with polynomial YSR term
M_WB2 <- glmmTMB(total_cover_prop_no1 ~ site_mean_elev + site_within_elev + DomSpeciesSuperSimp * poly(YSR,2) + (1|Site), data = salt_comm_rest_H, family = "beta_family")

anova(M_WB,M_WB2) # significant therefore use polynomial model 

# test whether it's better than non within-between model
anova(M2,M_WB2) # no difference, therefore stick with original model.

# model assumptions
resid <- residuals(simulateResiduals(M_WB2), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M_WB2,re.form = NA), resid) 
plotQQunif(M_WB2)
# all good

#MODEL LINES
em <- emmeans(M_WB2, ~ YSR|DomSpeciesSuperSimp* site_within_elev*site_mean_elev, at = list(YSR = c(6,11,12,16,30,33),site_within_elev = 0,site_mean_elev= 0.32 ), type= "response")

# Test model
M1 <- glmmTMB(total_cover_prop_no1 ~ site_mean_elev + site_within_elev + DomSpeciesSuperSimp + poly(YSR,2) + (1|Site), data = salt_comm_rest_H, family = "beta_family")
M <- glmmTMB(total_cover_prop_no1 ~ site_mean_elev + site_within_elev + DomSpeciesSuperSimp + YSR + (1|Site), data = salt_comm_rest_H, family = "beta_family")
M0 <- glmmTMB(total_cover_prop_no1 ~ site_mean_elev + site_within_elev + DomSpeciesSuperSimp + (1|Site), data = salt_comm_rest_H, family = "beta_family")
anova(M_WB2, M1, M, M0)

#PLOT
S_Cov_rest2 <- ggplot(data = salt_comm_rest_H, aes(x = YSR, y = total_cover_prop * 100, group = DomSpeciesSuperSimp, color = DomSpeciesSuperSimp)) +
  geom_jitter() +
  facet_wrap(~DomSpeciesSuperSimp)+
  geom_point(data = data.frame(em), aes(y = response * 100), group = NA, colour = "black", shape = 7, size = 3)+
  geom_line(data = data.frame(em), aes(y = response * 100), group = 1, colour = "black", linewidth = 1) +
  scale_y_continuous(trans = "log1p", limits = c(5,102)) +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Years since restoration") +
  ylab("Saltmarsh cover (%)") + 
  scale_color_viridis(discrete = TRUE, begin = 0.3, end = 0.8, option = "A")
S_Cov_rest2

# natural data
S_Cov_nat2 <- ggplot(salt_comm_nat, aes(x=Site, y=`Total_cover_%`, fill=DomSpeciesSuperSimp, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.3, end = 0.8, option = "A") +
    theme_bw() +
    #guides(fill = guide_legend(position = "inside")) +
    theme(#legend.position.inside = c(0.8,0.2),
          legend.position = "none",
          #axis.text = element_text(size = 32),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          #axis.title = element_text(size = 36)
          ) +
  xlab("Natural site") +
  ylab("")  +
  #labs(fill = "Dominant Species") +
  scale_y_continuous(trans = "log1p", limits = c(5,102)) +
  facet_wrap(~DomSpeciesSuperSimp)
S_Cov_nat2

ggarrange(S_Cov_rest2, S_Cov_nat2, ncol =2,nrow=1,widths = c(2,1)) 
```

## 2c. Burrows

Characteristics of the data:

-   zero-inflated count data (therefore use a poisson or negative binomial model or a zero-inflated version of either)

First, explore the data.

-   histogram of all data

-   histograms by site

-   \% of data that are zeroes

-   relationships between burrows and each numeric predictor

Also prepare data by creating a dataset without the NA data.

```{r Explore/prep}
hist(salt_comm_rest_H$Burrows_0.5x0.5) # right skewed / zero inflated
ggplot(data = salt_comm_rest_H, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)

100*sum(salt_comm_rest_H_burrows$Burrows_0.5x0.5 == 0, na.rm = TRUE)/nrow(salt_comm_rest_H_burrows)


plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$YSR) # potentially non-linear
plot(salt_comm_rest_H$Burrows_0.5x0.5 ~ salt_comm_rest_H$Elevation) # potentially non-linear

# remove NA data
salt_comm_rest_H_burrows <- salt_comm_rest_H %>% subset(!is.na(Burrows_0.5x0.5))
```

Next, create a model.

-   Negative binomial model for count data

-   Elevation and YSR as polynomial factors

-   No interaction between predictors given the data matrix is limited

-   Site as a random factor

-   Given we showed above that the data are 67% zeroes, we may need to use a zero-inflated model. We can create a model with and without zero-inflation and see if zero-inflation improves the model and explains more variation.

    -   if there is no significant difference between the models using an ANOVA, just use the non-zero-inflated model.

-   Test assumptions using resid and scatter.smooth

-   Test model using anova, comparing the chosen model to a model without polynomial YSR (M) and without YSR altogether (M0)

-   Generate estimates for model paramaters using summary

```{r Model}
M3 <- glmmTMB(Burrows_0.5x0.5 ~ poly(Elevation,2) + DomSpeciesSuperSimp + poly(YSR,2) +  (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")

M4 <- glmmTMB(Burrows_0.5x0.5 ~ poly(Elevation,2) + DomSpeciesSuperSimp + poly(YSR,2) + (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2", ziformula =~1)

resid <- residuals(simulateResiduals(M3), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M3,re.form = NA), resid) # good
resid <- residuals(simulateResiduals(M4), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M4,re.form = NA), resid) # good

anova(M3,M4) # no evidence of difference, so use M3

# check collinearity on a model without polynomial terms
M0 <- glmmTMB(Burrows_0.5x0.5 ~ Elevation + DomSpeciesSuperSimp + YSR +  (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")
check_collinearity(M0) # all low

# compare to null models
M <- glmmTMB(Burrows_0.5x0.5 ~ poly(Elevation,2) + DomSpeciesSuperSimp + YSR +  (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")
M0 <- glmmTMB(Burrows_0.5x0.5 ~ poly(Elevation,2) + DomSpeciesSuperSimp +  (1|Site), data = salt_comm_rest_H_burrows, family = "nbinom2")

anova(M3, M, M0)

joint_tests(M3)

em <- emmeans(M3, ~ YSR, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

em

plot(em)

summary(M3)

```

Next, plot the data.

-   boxplots of raw data with restoring and natural sites

-   arrange restoring and natural plot together

-   export at 1500\*800 for paper, 2200\*800 for preso

-   emmip for predicted values

```{r Plot}
S_Bur_rest <- ggplot(salt_comm_rest, aes(x=YSR, y=(Burrows_0.5x0.5+0.01), group = YSR, fill = Estuary)) +
    geom_boxplot(width = 2) +
  geom_jitter(height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.title = element_text(size = 28)) +
  xlab("Years since restoration") +
  ylab("Number of burrows") +
  xlim(0,35)  + ylim(0,62)
S_Bur_rest

S_Bur_nat <- ggplot(salt_comm_nat, aes(x=Site, y=Burrows_0.5x0.5, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text = element_text(size = 24),
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          axis.title = element_text(size = 28)) +
  xlab("Site") +
  ylab("")  +
  #scale_y_log10() + 
  ylim(0,62)
S_Bur_nat

ggarrange(S_Bur_rest,S_Bur_nat,ncol =2,nrow=1,widths = c(3,1))

burrplot <- emmip(M3, ~ YSR, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of burrows") +
  geom_jitter(aes(x = YSR, y = Burrows_0.5x0.5), data = salt_comm_rest_H) +
  theme_bw()
burrplot

Bur_nat <- ggplot(salt_comm_nat, aes(x=Site, y=Burrows_0.5x0.5, fill=Estuary, group = Site)) +
    geom_boxplot(width=0.4) +
  geom_jitter(width = 0.1, height = 0)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(legend.position = "none",
          axis.text.y = element_blank(), # remove y axis labels when combining plot with restored
          ) +
  xlab("Site") +
  ylab("")  +
  ylim(0,120)
Bur_nat

ggarrange(burrplot,Bur_nat,ncol =2,nrow=1,widths = c(3,1))
```

## 2d. Stem density

First, prepare data.

-   create a stem density dataframe "stem_dens" with just stem density data

-   remove replicate rows that resulted from measuring multiple stems for each species per quadrat but only one stem density measurement using a "unique" column with every unique quadrat combo

-   subset for only Hunter estuary and restored data

-   subset for only Sporobolus, Sarcocornia and Triglochin (only species with consistent proportion cover across time since restoraiton to be ecologically relevant)

-   remove NA data

Note, this dataset has two variables for stems. Stems is the raw data, and should be used with a Quadrat_area offset for modelling, whereas total_stems has been multiplied out factoring in different Quadrat_areas, and should be used for plotting.

```{r Prep}
stem_dens <- salt[,c(5,6,7,11,13,14,24:34)]

stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

stem_dens_unique_H_res <- stem_dens_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

stem_dens_unique_H_res <- stem_dens_unique_H_res %>% 
  subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin"))

# remove NAs
stem_dens_unique_H_res <- stem_dens_unique_H_res %>% subset(!is.na(Stems))
```

Next, explore data:

-   Histograms of distribution

-   Relationships between dependent and predictor variables

Also prep data by recording Species as a factor (rather than character) variable.

```{r Explore/prep}
hist(stem_dens_unique_H_res$total_stems) # right skewed

plot(stem_dens_unique_H_res$total_stems ~ stem_dens_unique_H_res$YSR) # not sure if it's non-linear
ggplot(data = stem_dens_unique_H_res, aes(x = YSR, y = total_stems)) +
  geom_point() +
  geom_smooth() # potentially non-linear
ggplot(data = stem_dens_unique_H_res, aes(y = total_stems, x = YSR)) +
  geom_point() +
  facet_wrap(~Species) # however it's probably overfitting the model to include a polynomial factor per species

# without accounting for offset
ggplot(data = stem_dens_unique_H_res, aes(y = Stems, x = YSR)) +
  geom_point() +
  facet_wrap(~Species)

plot(stem_dens_unique_H_res$total_stems ~ stem_dens_unique_H_res$Elevation) # no evidence it's non linear

stem_dens_unique_H_res$Species <- as.factor(stem_dens_unique_H_res$Species)
```

Create a model:

-   The data are count data, so use either a poisson or negative binomial model.

-   We are interested in how stem densities change for each species considering all other factors, so create interactions with as many factors as possible (take factors outside of the brackets if the model doesn't run with them inside).

-   Stem densities of each species in a quadrat are correlated, so include a reduced rank correlation structure for this

-   Need to include an offset of Quadrat_area since not all stem densities were counted in the same area

-   Including site as a random factor

Check assumptions:

-   resid and scatter.smooth for mean-variance relationship

-   plotQQunif for transformed normal assumption

-   check_collinearity with a model without interactions and polynomial terms for collinearity

```{r Model_building}
M <- glmmTMB(Stems ~  Species*(DomSpeciesSuperSimp + Elevation  + YSR) +  offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "poisson", data = stem_dens_unique_H_res)

resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M, re.form = NA), resid) # has a trend
plotQQunif(M) # ok

M5 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation + YSR)+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

resid <- residuals(simulateResiduals(M5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M5, re.form = NA), resid) # has a trend.. however this is only driven by a few points so should be ok
scatter.smooth(predict(M5, re.form = NA), abs(resid)) # looks pretty fine
plotQQunif(M5) # pretty good

# check where to include DomSpecies (outside of bracket, inside or in interaction with YSR)
M5.1 <- glmmTMB(Stems ~ Species*(Elevation + DomSpeciesSuperSimp *  YSR)+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
M5.2 <- glmmTMB(Stems ~ DomSpeciesSuperSimp + Species*(Elevation +  YSR)+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
M5.3 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation + YSR)+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

anova(M5.1,M5.2,M5.3) # use in brackets but not in interaction

# check whether to include YSR as a polynomial
M5.1 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation + YSR)+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
M5.2 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation + poly(YSR,2))+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

anova(M5.1,M5.2) # significant difference therefore use polynomial one

M0 <- glmmTMB(Stems ~ DomSpeciesSuperSimp + Species + Elevation + YSR + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

check_collinearity(M0) # all low

```

Generate model results:

-   anova for model testing - compare with a model that lacks the Species \* poly(YSR,2) interaction (M) and a model without the linear Species \* YSR term (M0)

-   Don't compare with a model that lacks YSR terms altogether because stem density was measured differently for each species so overall stem density is not a relevant metric

-   summary for estimates of differences between groups

-   emtrends for the linear rate of change for each species and confidence intervals **(can I include an offset here?)**

-   ref_grid to understand the mean values of each variable, including the offset, included in the model

```{r Model_testing}
M5 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation + poly(YSR,2))+ offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
M <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp + Elevation + YSR) + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
M0 <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp + Elevation)  + YSR + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)
Mx <- glmmTMB(Stems ~ Species*(DomSpeciesSuperSimp +  Elevation) + poly(YSR,2) + offset(log(Quadrat_area)) + rr(Species+0|Combo, d = 2) + (1|Site), family = "nbinom2", data = stem_dens_unique_H_res)

anova(M5, M, M0)
anova(M5,Mx)
summary(M5)

joint_tests(M5)

emmeans(M5, ~ YSR | Species, at = list(YSR = c(6,11,12,16,30,33)), type = "response", offset = log(10000))

em <- emtrends(M5, var = "YSR", specs = ~Species)

em

plot(em)

ref_grid(M5)
```

Now, plot the results.

-   **Need to make sure plot is for total stems not stems without offset**

```{r Plot}
emmip(M5, ~ YSR | Species, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Number of stems", offset = log(10000)) +
  geom_jitter(aes(x = YSR, y = total_stems), data = stem_dens_unique_H_res) +
  theme_bw()

ggplot(data = stem_dens_unique_H_res, aes(y = total_stems, x = YSR, group = YSR)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~Species, scales = "free")
```

## 2e. Stem diameter

Prepare data:

-   Create a stems dataset (we'll use this for diameter and height) with the three ecologically relevant species

-   Then remove stem diameter NA data

```{r Prep}
salt_H_rest_stems <- salt_H_rest %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin"))

salt_H_rest_stems_dia <- salt_H_rest_stems %>% subset(!is.na(Stem_dia_mm))
```

Explore

```{r Explore}
# explore distribution
hist(salt_H_rest_stems_dia$Stem_dia_mm) # highly right skewed
hist(log(salt_H_rest_stems_dia$Stem_dia_mm)) # better
hist(sqrt(salt_H_rest_stems_dia$Stem_dia_mm)) # better but worse than log

# explore relationship between dependent and predictor variables
plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$YSR) # not clearly non-linear
ggplot(data = salt_H_rest_stems_dia, aes(y = Stem_dia_mm, x = YSR)) +
  geom_point() +
  facet_wrap(~Species) # no evidence of non-linear species relationships

plot(salt_H_rest_stems_dia$Stem_dia_mm ~ salt_H_rest_stems_dia$Elevation) # not clearly non-linear

```

Next, create a model:

-   We are interested in how stem diameters change for each species considering all other factors, so create interactions with as many factors as possible (take factors outside of the brackets if the model doesn't run with them inside).

-   Stem diameters of each species in a quadrat might be correlated, so include a reduced rank correlation structure for this

-   Including quadrat (Combo) as a random factor

-   Try a model with raw data and a model with square root transformed data

    -   the former only runs with Elevation in the brackets while the latter only runs when it's outside the bracket, so that's why they differ slightly

Check assumptions

-   plot for mean-variance relationship

-   plotQQunit for normality

-   check_collinearity for predictor collinearity on model without interactions

```{r Model_building}
M <- glmmTMB(Stem_dia_mm ~ Species*(DomSpeciesSuperSimp + Elevation + sp_prop + YSR) + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M, re.form = NA), residuals(M)) # ok but clumped
plotQQunif(M) # ok but not great

M6 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species*(DomSpeciesSuperSimp + Elevation + sp_prop + YSR) + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

plot(predict(M6, re.form = NA), residuals(M6)) # looks ok
plotQQunif(M6) # not great but better than M - but these models are robust to deviations from normality for this sample size so it's totally fine.

M0 <- glmmTMB(sqrt(Stem_dia_mm) ~ DomSpeciesSuperSimp + Species + Elevation + sp_prop + YSR + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

check_collinearity(M0) # all low

anova(M6, M) # no significant difference, but M6 has a lower AIC so use that
```

Test model:

-   joint_tests for model testing

-   summary for estimates of differences between groups

-   emmeans for parameter estimates

```{r Model_testing}
M <- glmmTMB(sqrt(Stem_dia_mm) ~ Species*(DomSpeciesSuperSimp + Elevation + sp_prop) + YSR + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

M0 <- glmmTMB(sqrt(Stem_dia_mm) ~ Species*(DomSpeciesSuperSimp + Elevation + sp_prop)  + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_dia)

anova(M0, M, M6)

summary(M6)

em <- emtrends(M6, var = "YSR", specs = ~Species)

em

plot(em)

emmeans(M, ~ YSR, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

emmeans(M6, ~ YSR | Species, at = list(YSR = c(6,11,12,16,30,33)), type = "response")
```

Plot:

-   emmip for predicted values

-   ggplot with boxplot and jitter for raw data

```{r Plot}
emmip(M6, ~ YSR | Species, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Stem diameter (mm)") +
  geom_jitter(aes(x = YSR, y = Stem_dia_mm), data = salt_H_rest_stems_dia) +
  theme_bw()

emmip(M6, ~ YSR, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Stem diameter (mm)") +
  geom_jitter(aes(x = YSR, y = Stem_dia_mm), data = salt_H_rest_stems_dia) +
  theme_bw()

ggplot(data = salt_H_rest_stems_dia, aes(y = Stem_dia_mm, x = YSR, group = YSR)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~Species, scales = "free")
```

## 2f. Stem height

Prep/explore

-   Remove NA data

-   explore histograms of raw and transformed data

-   explore relationship between dependent and predictor variables

```{r Prep/explore}
salt_H_rest_stems <- salt_H_rest %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin"))

salt_H_rest_stems_ht <- salt_H_rest_stems %>% subset(!is.na(Stem_ht_mm))

hist(salt_H_rest_stems_ht$Stem_ht_mm) # slghtly right skewed
hist(log(salt_H_rest_stems_ht$Stem_ht_mm)) # slightly left skewed
hist(sqrt(salt_H_rest_stems_ht$Stem_ht_mm)) # approx normal

plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$YSR) # not clearly non-linear
plot(salt_H_rest_stems_ht$Stem_ht_mm ~ salt_H_rest_stems_ht$Elevation) # not clearly non-linear

```

Now, build a model:

-   Use sqrt-transformed data as raw data are slightly right-skewed and the sqrt model has lower log likelihood

-   We are interested in how stem heights change for each species considering all other factors, so create interactions with as many factors as possible (take factors outside of the brackets if the model doesn't run with them inside).

-   Stem heights of each species in a quadrat might be correlated, so include a reduced rank correlation structure for this

-   Including quadrat (Combo) as a random factor

Check assumptions

-   plot for mean-variance relationship

-   plotQQunit for normality

-   check_collinearity for collinearity between predictors on a model without interactions

```{r Model_building}
M <- glmmTMB(Stem_ht_mm ~ DomSpeciesSuperSimp + Species*(Elevation + sp_prop + YSR) + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M, re.form = NA), residuals(M)) 
plotQQunif(M)

M7 <- glmmTMB(sqrt(Stem_ht_mm) ~ DomSpeciesSuperSimp + Species*(Elevation + sp_prop + YSR) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

plot(predict(M7, re.form = NA), residuals(M7)) 
plotQQunif(M7)

anova(M,M7)

M0 <- glmmTMB(sqrt(Stem_ht_mm) ~ DomSpeciesSuperSimp + Species + Elevation + sp_prop + YSR +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht) 

check_collinearity(M0) # all low
```

Generate model results:

-   anova for model testing - compare with model without Species:YSR term (M) and model without YSR altogether (M0)

-   summary for estimates of differences between groups

-   emtrends for parameter estimates

```{r Model_testing}
M <- glmmTMB(log(Stem_ht_mm) ~ DomSpeciesSuperSimp + Species*(Elevation + sp_prop) + YSR +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)
M0 <- glmmTMB(log(Stem_ht_mm) ~ DomSpeciesSuperSimp + Species*(Elevation + sp_prop) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_H_rest_stems_ht)

anova(M7, M, M0)
summary(M7)

em <- emtrends(M7, var = "YSR", specs = ~Species, type = "response")

em

plot(em)

emmeans(M7, ~ YSR | Species, at = list(YSR = c(6,11,12,16,30,33)), type = "response")

```

Plot:

-   emmip for predicted values

-   ggplot with boxplot and jitter for raw data

```{r Plot}
emmip(M7, ~ YSR | Species, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Stem height (mm)") +   
  geom_jitter(aes(x = YSR, y = Stem_ht_mm), data = salt_H_rest_stems_ht)   

ggplot(data = salt_H_rest_stems_ht, aes(y = Stem_ht_mm, x = YSR, group = YSR)) +   geom_boxplot() +   
  geom_jitter() +   
  facet_wrap(~Species, scales = "free")
```

## 

## 2g. Reproduction

First, prep data:

-   create a new dataframe with just reproduction data

-   recode seeds as a binary presence/absence variable - view unique values and recode these

-   remove replicates that originated from measuring multiple stems for each species per quadrat (but only one reproduction value)

    -   first create a column for every unique site/quadrat/species combination

-   subset for only restored and Hunter

-   count number of non-na values for each species (can only analyse species with at least 5 values) and subset for only these species

-   make data longer with one row for reproduction type and another for presence/absence

-   remove NAs

-   there are actually only enough data for three species (sporobolus, sarcocornia, triglochin) so subset for only these

-   there are actually only enough data for flowers and seeds so subset for just these

```{r Prep}
reprod <- salt[,c(5,6,7,11,16:18,24,25,28,30:34)]

reprod$Seeds %>% unique() # view unique values
reprod <- reprod %>% mutate(Seeds = case_when(
  Seeds == "No" ~ 0,
  Seeds == "Yes" ~ 1,
  Seeds == "Lots" ~ 1,
  Seeds == "Some" ~ 1,
  Seeds == "Few" ~ 1,
  Seeds == "Very few" ~ 1,
  Seeds == "NA" ~ NA
))

reprod$unique <- factor(interaction(reprod$Combo, reprod$Species, sep = ":"))
reprod_unique <- reprod %>% distinct(unique, .keep_all = TRUE) 

reprod_unique_H_res <- reprod_unique %>% subset(Estuary == "Hunter") %>% subset(rest_status == 1)

Reprod_count <-
  reprod_unique_H_res %>% 
  group_by(Species) %>% 
  summarise(count_non_na = sum(!is.na(Seeds))) 
print(Reprod_count, n = 21)

reprod_unique_H_res <- reprod_unique_H_res %>% subset(Species %in% c("Aster", "Bolboschoenus", "Phragmites", "Sarcocornia", "Sporobolus", "Triglochin"))

reprod_long <- reprod_unique_H_res %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

reprod_long <- reprod_long %>% subset(!is.na(Reproduction))

reprod.s <- reprod_long %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin"))

reprod.s_sf <- reprod.s %>% subset(reprod_type %in% c("Flowers", "Seeds"))

ggplot(reprod.s_sf, aes(x = Reproduction, fill = reprod_type)) +
  geom_histogram() +
  facet_wrap(~Site)

ggplot(reprod.s_sf, aes(x = Reproduction, fill = Species)) +
  geom_histogram() +
  facet_wrap(~Site)
```

Explore

-   the data are binary (presence/absence) so can't plot the same way as other data

-   plot the proportion of flowers and seeds of each of the three species

```{r Explore}
reprod_proportions <- reprod_long %>% 
  group_by(Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), 
            se = sd(Reproduction)/sqrt(n()), 
            YSR = mean(YSR)) %>% 
  ungroup()

reprod_proportions <- reprod_proportions %>% mutate(Site = factor(Site, levels = c("AE", "TB", "HS", "TA", "CF", "CC")))

reprod_proportions %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(reprod_type != "Buds") %>% 
  ggplot(aes(x = YSR, y = avg, group = reprod_type, color = reprod_type)) +
  geom_point(size = 4) +
  facet_wrap(~Species) +
  ylab("Proportion of quadrats with reproduction") +
  xlab("Years since restoration") +
  labs(color = "Reproduction type") +
  theme_bw() +
  theme(axis.title = element_text(size = 28), axis.text = element_text(size = 24), legend.title = element_blank(), legend.text = element_text(size = 24), strip.text = element_text(size = 24)) +
  scale_color_viridis(discrete = TRUE, begin = 0.4, end = 0.8, option = "A") 
# print at 1500 x 789
```

Create a model:

-   data are binary so use a binomial model

-   We are interested in how reproduction changes for each species considering all other factors, so create interactions with as many factors as possible (take factors outside of the brackets if the model doesn't run with them inside - Dominant Species and Elevation).

-   We are also interested if there's a trend in reproduction regardless of species so also include this as a separate term

-   Reproduction types of each species might be correlated, so include a random effect for this

    -   Would ideally include this random effect, but both of these factors don't have enough levels to be included as random factors, so the model doesn't run properly while they're included - therefore can't include this term

-   Including quadrat (Combo) as a random factor

-   **Justify contrasts = list(reprod_type = "contr.sum")**

Check model assumptions

-   mean-variance relationship using resid and scatter.smooth

-   normality using plotQQunit

-   collinearity of predictors using check_collinearity on a model without interactions (M0) (having issues with model convergence, but terms are showing low correlation and the same terms have been low correlation in other models, so it should be fine)

```{r Model_building}
M8 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*(reprod_type * YSR) + (1|Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

resid <- residuals(simulateResiduals(M8), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8,re.form = NA), resid) # looks great.

plotQQunif(M8) # amazing

M0 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Species + Elevation +   reprod_type + YSR  + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

check_collinearity(M0) # all low
```

Generate model results:

-   anova to test importance of YSR \* Species \* reprod_type, YSR \* Species and YSR by comparing with three null models (M1, M, M0)

-   summary for estimates of differences between groups

-   emtrends and emmeans for parameter estimates

```{r Model_testing}
M1 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*(reprod_type + YSR) + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

M <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*reprod_type + YSR + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

M0 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*reprod_type  + (1|Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod.s_sf)

anova(M8, M, M0, M1)

joint_tests(M8)

summary(M8)

em <- emtrends(M8, var = "YSR", specs = ~Species | reprod_type, type = "response")


em

plot(em)

emmeans(M8, ~ YSR | Species | reprod_type, at = list(YSR = c(6,11,12,16,30,33)), type = "response")
emmeans(M8, ~ YSR | Species, at = list(YSR = c(6,11,12,16,30,33)), type = "response")
```

Plot

-   first calculate raw average proportion of quadrats at each site with seeds or flowers for each species of interest

-   emmip for predicted values + add raw averages

-   boxplot and jitter for raw values (**needs work**)

```{r Plot}
reprod_proportions <- reprod_long %>% 
  group_by(Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), 
            se = sd(Reproduction)/sqrt(n()), 
            YSR = mean(YSR)) %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(reprod_type != "Buds") %>% 
  ungroup()

emmip(M8, ~ YSR | Species | reprod_type, at = list(YSR = c(6:33)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Reproduction likelihood") +   
  geom_point(data = reprod_proportions, aes(x = YSR, y = avg, group = reprod_type))   

# just sporobolus seeding
emmip(M8, ~ YSR , at = list(YSR = c(6:33), Species = "Sporobolus", reprod_type = "Seeds"), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Reproduction likelihood") +   
  geom_point(data = reprod_proportions %>% subset(Species == "Sporobolus") %>% subset(reprod_type == "Seeds"), aes(x = YSR, y = avg, group = reprod_type)) 
```

# 3. Natural vs restored models

Before we create any of these models, let's inspect the data space we're working with:

-   relationship between restoration status and Elevation

```{r Predictor_association}
plot(salt_comm$Elevation ~ salt_comm$rest_status)
```

From this, we can conclude:

-   natural sites have elevations \~0.4-0.8, however most data is between \~0.5-0.8

-   restoring sites have elevations \~0-0.8, however most data is between \~0-0.6

-   therefore we could potentially include interactions (but only interpret results in the overlapping region, 0.4-0.8m), however given there is not that much overlap in this region, it might be safer to leave out the interaction, especially as it's not our study question anyway

Also, test for differences in the elevations of natural and restored sites using a model.

```{r Elevation_model}
M8.5 <- glmmTMB(Elevation ~ DomSpeciesSuperSimp + rest_status + (1|Site), family = "gaussian", data = salt_comm)

# check assumptions
resid <- residuals(simulateResiduals(M8.5), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M8.5,re.form = NA), resid) 
plotQQunif(M8.5)

M0 <- glmmTMB(Elevation ~ DomSpeciesSuperSimp + (1|Site), family = "gaussian", data = salt_comm)

anova(M8.5,M0)

emmip(M8.5, ~ rest_status, type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Elevation (m)")
```

## 3a. Community composition

First, prepare data.

-   subset for only species with sufficient data across the dataset - these are the same species we identified in the YSR models above (Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites), as even if there may be more species we could include from natural sites, we need sufficient restored data to be able to contrast natural vs restored

-   convert community composition data to long format, suitable for glmmTMB

-   create a proportional cover column (Sp_cover_prop) and offset 1's slightly so data are suitable for models that can only have values 0 \<= x \< 1.

-   create a "Combo" column that is a combination of Site and Quadrat

Also explore the data by plotting:

-   histograms of raw data, log-transformed data and square-root-transformed data

    -   note, raw data are highly zero-inflated as we've included zeroes every time a species was absent

    -   log- or sqrt-transforms don't fix the distribution

-   view distribution of values by species for restored and natural data separately to explore if there are any species missing from either restored status

    -   pneumatophores looks like it's only zeroes in restored data, but observing the data, you can see there are also some very small proportions

    -   pneumatophores, aster, bolboschoenus and phragmites look like they're only zeroes for natural sites. Upon inspecting data, we can see aster, bolboschoenus and phragmites are all zeroes for natural sites, but there are some pneumatophores.

-   therefore, subset for only Sarcocornia, Sporobolus, Triglochin and Pneumatophores

-   plot relationships between species' cover and elevation to determine if this should be included as a linear or polynomial factor

    -   no evidence of a non-linear relationship, therefore include as a linear factor

```{r Prep/explore}
salt_comm_comp_long <- salt_comm_comp %>% 
  dplyr::select(Sarcocornia, Sporobolus, Triglochin, Pneumatophores, Bolboschoenus, Aster, Phragmites, Estuary, Site, Quadrat, Elevation, rest_status) %>%  
  pivot_longer(cols = c("Sarcocornia", "Sporobolus", "Triglochin", "Pneumatophores", "Bolboschoenus", "Aster", "Phragmites"), names_to = "Species", values_to = "Sp_cover") %>% 
  mutate(Sp_cover_prop = 
           case_when(Sp_cover == 0 ~ 0, # keep zeroes as zeroes
                     .default = Sp_cover/100 - 0.00001), 
         Combo = paste0(Site, Quadrat)) 

hist(salt_comm_comp_long$Sp_cover_prop) 
hist(log(salt_comm_comp_long$Sp_cover_prop)) 
hist(sqrt(salt_comm_comp_long$Sp_cover_prop))

salt_comm_comp_long %>% subset(rest_status == 1) %>% 
  ggplot(aes(x = Sp_cover_prop, group = Species)) +
  geom_histogram() +
  facet_wrap(~Species) 

salt_comm_comp_long %>% subset(rest_status == 0) %>% 
  ggplot(aes(x = Sp_cover_prop, group = Species)) +
  geom_histogram() +
  facet_wrap(~Species) 

salt_comm_comp_long_less <- salt_comm_comp_long %>% subset(Species %in% c("Sarcocornia", "Sporobolus", "Triglochin", "Pneumatophores"))

ggplot(data = salt_comm_comp_long_less, aes(x = Elevation, y = Sp_cover_prop)) +
  geom_point() +
  facet_wrap(~Species) 

ggplot(data = salt_comm_comp_long_less, aes(x = rest_status, y = Sp_cover_prop, group = rest_status)) +
  geom_boxplot() +
  facet_wrap(~Species, scales = "free") 
```

Next, create a model:

-   use a beta distribution because it's proportional data

-   include quadrat (Combo) nested within Site as a random factor

-   include Estuary as a fixed factor as even though we don't care about the identity of the estuaries, there are only 2 levels

-   included a reduced rank correlation structure because species covers within the same quadrat are not independent so we need to account for this

-   as we're modelling community composition, we want to model how each species' percent cover varies with YSR after controlling for elevation, so model the interaction between Species and (Elevation + rest_status)

-   use a zero-inflated model structure if the number of zeroes can't be accounted for without it

    -   in the non-zero inflated model, need to add a tiny offset so there are no zeroes in the data

    -   as residuals don't look good in the non-zero-inflated model, but look acceptable in the zero-inflated model, use that

Test assumptions using resid and scatter.smooth and plotQQunif.

```{r Model_create}
M <- glmmTMB((Sp_cover_prop + 0.000001) ~ Estuary + Species:(Elevation + rest_status) + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M, re.form = NA), resid) 
scatter.smooth(predict(M, re.form = NA), abs(resid))
plotQQunif(M)

M9 <- glmmTMB(Sp_cover_prop ~ Estuary + Species:(Elevation + rest_status) + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

resid <- residuals(simulateResiduals(M9), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M9, re.form = NA), resid) 
scatter.smooth(predict(M9, re.form = NA), abs(resid))
plotQQunif(M9)
```

Generate model results:

-   anova, compared against a null model (M0) without the variable of interest (Species:rest_status) to test whether community composition is changing with restoration status

-   emmeans for parameter estimates - mean of each group

-   summary for parameter estimates - differences between each groups

```{r Model_test}
M0 <- glmmTMB(Sp_cover_prop ~ Estuary + Species:Elevation + (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = beta_family(link = "logit"), ziformula = ~ 1, data = salt_comm_comp_long_less)

anova(M9, M0)

summary(M9) # get parameter estimates

em <- emtrends(M9, var = "rest_status", specs = ~Species)

plot(em)

joint_tests(M9)
emmeans(M9, pairwise~rest_status|Species, type = "response") 
summary(M9) 
```

Next, plot the results:

-   emtrends for confidence intervals for slopes of elevation for each species (plot these using plot)

-   ggplot to make boxplots for natural vs restored cover by species (print at 1200 x 800)

```{r Plot}
k <- emtrends(M9, var = "rest_status", ~Species, type = "response")
k
plot(k) 

#emmip(M9, ~ Elevation | Species, at = list(Elevation = c(-0.5,-0.4,-0.3,-0.2,-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Elevation", ylab = "Predicted proportion cover") +
  #geom_jitter(data = salt_comm_comp_long_less, aes(x = Elevation, y = Sp_cover_prop))

ggplot(data = salt_comm_comp_long_less, aes(x = Species, y = Sp_cover + 0.0001, fill = as.factor(rest_status))) +
  geom_boxplot() +
  scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A",
                     name="",
                     breaks=c("0", "1"),
                     labels=c("Natural", "Restoring")) +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          legend.text = element_text(size = 20)) +
  xlab("Species") +
  ylab("Species percent cover") 

ggplot(data = salt_comm_comp_long_less, aes(x = Elevation, y = Sp_cover + 0.0001, fill = Species)) +
  geom_smooth(method = "lm") +
  geom_jitter() +
  ylab("Species cover (%)") +
  theme_bw() +
  facet_wrap(~Species, scales = "free")
```

## 3b. Total cover

First, prepare and explore the data.

-   create an additional proportional cover variable that is slightly offset to account for the fact that beta models can't include values equal to 1

-   use histograms to explore the distribution of raw and transformed data

    -   it's left skewed, so transform with log(1-x)

-   plot relationships between variables

    -   the relationship between total cover and elevation is not obviously non-linear, so include as a linear factor

```{r Prep/Explore}
salt_comm$total_cover_prop_offset <- salt_comm$total_cover_prop - 0.0001

hist(salt_comm$total_cover_prop) 

plot(salt_comm$total_cover_prop ~ salt_comm$rest_status)
plot(salt_comm$total_cover_prop ~ salt_comm$Elevation)

ggplot(salt_comm, aes(y = total_cover_prop, x = rest_status, group = rest_status)) +
  geom_boxplot()
```

Next, create a model:

-   Use a beta distribution as it's proportion data

-   Include Site as a random factor

-   Include Elevation, DomSpeciesSuperSimp and Estuary as covariates

```{r Model_create}
M10 <- glmmTMB(total_cover_prop_offset ~ Elevation +  DomSpeciesSuperSimp + Estuary + rest_status + (1|Site), family = "beta_family", data = salt_comm)

resid <- residuals(simulateResiduals(M10), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M10,re.form = NA), resid)
scatter.smooth(predict(M10,re.form = NA), abs(resid))
check_collinearity(M10) 
plotQQunif(M10)

# residuals graphs are ok
```

Next, test the model.

-   test model by comparing the model with a null model (M0) that doesn't contain rest_status

-   calculate parameter estimates using summary and emmeans

```{r Model_test}
M0 <- glmmTMB(total_cover_prop_offset ~ Elevation +  DomSpeciesSuperSimp + Estuary + (1|Site), family = "beta_family", data = salt_comm)

anova(M10, M0)

joint_tests(M10)
summary(M10)
emmeans(M10, pairwise ~ rest_status, type = "response")
emmeans(M10, pairwise ~ Estuary, type = "response")
emmeans(M10, pairwise ~ DomSpeciesSuperSimp, type = "response")
```

Finally, plot the data.

-   ggplot to plot natural vs restoring boxplots in the Hunter and Maroochy estuaries

```{r Plot}
ggplot(salt_comm, aes(x=Estuary, y=total_cover_prop*100, fill = as.factor(rest_status))) +
    geom_boxplot() +
  geom_jitter(size = 3)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A",
                      name="",
                      breaks=c("0", "1"),
                      labels=c("Natural", "Restoring")) +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          legend.text = element_text(size = 20)) +
  xlab("Estuary") +
  ylab("Saltmarsh cover (%)") 

ggplot(salt_comm, aes(x=rest_status, y=total_cover_prop*100, fill = as.factor(rest_status))) +
    geom_boxplot() +
  geom_jitter(size = 3)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A",
                      name="",
                      breaks=c("0", "1"),
                      labels=c("Natural", "Restoring")) +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          legend.text = element_text(size = 20)) +
  xlab("Restoration status") +
  ylab("Saltmarsh cover (%)") +
  facet_wrap(~DomSpeciesSuperSimp)
```

## 3c. Burrows

First, prepare and explore the data:

-   histogram faceted by site

-   histogram of raw and transformed data

    -   raw is right skewed, so try log (best) and sqrt transforms

-   plot relationships between variables

    -   no evidence of a non-linear relationship between burrows and elevation

-   remove NA data

```{r Prep/explore}
ggplot(data = salt_comm, aes(x = Burrows_0.5x0.5)) +
  geom_histogram() +
  facet_wrap(~Site)

hist(salt_comm$Burrows_0.5x0.5)
hist(log(salt_comm$Burrows_0.5x0.5)) 
hist(sqrt(salt_comm$Burrows_0.5x0.5)) 

plot(salt_comm$Burrows_0.5x0.5 ~ salt_comm$rest_status) 
plot(salt_comm$Burrows_0.5x0.5 ~ salt_comm$Elevation)

salt_comm_burrows <- salt_comm %>% subset(!is.na(Burrows_0.5x0.5))
```

Next, create a model:

-   include Dominant Species as a covariate

-   include Site as a random factor

-   poisson distribution because it's count data

-   try both a non-zero-inflated and a zero-inflated model

    -   the zero-inflated model has slightly better looking assumptions graphs and a significantly lower AIC value, so use that (M11)

```{r Model_create}
M <- glmmTMB(Burrows_0.5x0.5 ~ DomSpeciesSuperSimp + Elevation + Estuary + rest_status + (1|Site), data = salt_comm_burrows, family = "poisson")

resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M, re.form = NA), resid)
check_collinearity(M) # low collinearity
plotQQunif(M)

M11 <- glmmTMB(Burrows_0.5x0.5 ~ DomSpeciesSuperSimp + Elevation + Estuary + rest_status + (1|Site), data = salt_comm_burrows, family = "poisson", ziformula =~1)

resid <- residuals(simulateResiduals(M11), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M11, re.form = NA), resid)
check_collinearity(M11) # low collinearity
plotQQunif(M11)

anova(M, M11)
```

Next, test the model.

-   test model using anova to compare the model with a null model (M0) that doesn't have a rest_status term

-   calculate parameter estimates using summary and emmeans

```{r Model_test}
M0 <- glmmTMB(Burrows_0.5x0.5 ~ DomSpeciesSuperSimp + Elevation + Estuary + (1|Site), data = salt_comm_burrows, family = "poisson", ziformula =~1)

anova(M11, M0)

joint_tests(M11)
summary(M11)
emmeans(M11, pairwise ~ rest_status, type = "response")
emmeans(M11, pairwise ~ DomSpeciesSuperSimp, type = "response")
```

Finally, plot the data.

```{r Plot}
ggplot(salt_comm, aes(x=as.factor(rest_status), y=total_cover_prop*100, fill = as.factor(DomSpeciesSuperSimp))) +
    geom_boxplot() +
  geom_jitter(size = 3)  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A",
                      name="",
                      labels=c("Sporobolus", "Sarcocornia", "Other")) +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          legend.text = element_text(size = 20)) +
  xlab("rest_status") +
  ylab("Number of burrows per 0.25m^2") 
```

## 3d. Stem density

First, prepare and explore the data:

-   Because there are multiple stem height/diameter measurements per species per quadrat but only one stem density measurement, we need to first create a dataset with one stem density row per species/quadrat ("stem_dens_unique")

-   Subset for only ecologically relevant species with enough data and remove NAs

-   Explore the data (both while accounting for quadrat size - total stems - and without accounting - Stems) using histograms of raw and transformed data

-   Plot relationship between elevation and stem density

```{r Prep/explore}
stem_dens <- salt[,c(5,6,7,11,13,14,24:34)]
stem_dens$unique <- factor(interaction(stem_dens$Combo, stem_dens$Species, sep = ":"))
stem_dens_unique <- stem_dens %>% distinct(unique, .keep_all = TRUE) 

stem_dens_unique_less <- stem_dens_unique %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(!is.na(Stems)) 

hist(stem_dens_unique_less$total_stems) # highly right skewed
hist(log(stem_dens_unique_less$total_stems)) # weird but better
hist(sqrt(stem_dens_unique_less$total_stems)) # still right skewed

hist(stem_dens_unique_less$Stems) #  right skewed
hist(log(stem_dens_unique_less$Stems)) # left skewed
hist(sqrt(stem_dens_unique_less$Stems)) # pretty good

plot(stem_dens_unique_less$Stems ~ stem_dens_unique_less$Elevation) # not non-linear
```

Next, create a model:

-   The data are count data, so first try poisson or negative binomial models. If these don't meet assumptions, the square-root transform above seems to make the data approximate a normal distribution, so try a gaussian model with sqrt(Stems) as the dependent variable.

-   We expect stem density changes with Species, and that elevation and restoration status may impact each species differently. So include these terms in interaction with Species.

-   Also include additional fixed predictors Estuary and Dominant Species

-   Include quadrat (Combo) within Site as a random factor

-   As stem densities of each species within a quadrat are not independent, include a reduced rank correlation structure to account for this

-   As stems were counted in quadrats of different size, need to include an offset for quadrat area

-   Check collinearity using an equivalent model without interactions. The interaction-less model has warnings so test it without Dominant Species.

```{r Model_create}
M <- glmmTMB(Stems ~ Estuary + DomSpeciesSuperSimp + Species*(Elevation + rest_status) + (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "poisson", data = stem_dens_unique_less)

resid <- residuals(simulateResiduals(M), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M, re.form = NA), resid)
plotQQunif(M)

M0 <- glmmTMB(Stems ~ Estuary + DomSpeciesSuperSimp + Species*(Elevation + rest_status) + (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "nbinom2", data = stem_dens_unique_less)

resid <- residuals(simulateResiduals(M0), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M0, re.form = NA), resid)
plotQQunif(M0)

M12 <- glmmTMB(sqrt(Stems) ~ Estuary + DomSpeciesSuperSimp + Species * (Elevation +  rest_status) +  (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)

resid <- residuals(simulateResiduals(M12), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M12, re.form = NA), resid)
plotQQunif(M12)
# looks a lot better than the other two options

Mx <- glmmTMB(sqrt(Stems) ~ Estuary + Species + Elevation +  rest_status +  (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less) # this has an error but doesn't really matter as it's just for collinearity testing
check_collinearity(Mx) # all low
```

Next, test the model.

-   test model by comparing it to null models without the Species\*rest_status interaction (M) and without rest_status altogether (M0) using anova

-   calculate parameter estimates using summary and emmeans

```{r Model_test}
M <- glmmTMB(sqrt(Stems) ~ Estuary + DomSpeciesSuperSimp + Species * Elevation +  rest_status +  (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)

M0 <- glmmTMB(sqrt(Stems) ~ Estuary + DomSpeciesSuperSimp + Species * Elevation +   (1|Site/Combo) + rr(Species+0|Combo, d = 1) + offset(log(Quadrat_area)), family = "gaussian", data = stem_dens_unique_less)

anova(M12,M,M0)


joint_tests(M12)
emmeans(M12, pairwise~rest_status, type = "response")
emmeans(M12, pairwise~rest_status|Species, type = "response")
emmeans(M12, pairwise~Elevation|Species, type = "response")
summary(M12)
```

Finally, plot the data:

-   emtrends to look at direction of trend with elevation for each species

-   ggplot to compare stem densities for each species between natural and restoring sites (don't include, no difference) and to inspect elevation trends for each species

```{r Plot}
k <- emtrends(M12, var = "Elevation", ~Species)
plot(k)

ggplot(stem_dens_unique_less, aes(x=as.factor(rest_status), y=total_stems + 0.0001, fill = as.factor(rest_status))) +
    geom_boxplot() +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_bw() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          strip.text = element_text(size = 28),
          legend.position = "none")+
  xlab("Restoration status")  + 
  ylab("Number of stems per m2") +
  facet_wrap(~Species) +
  scale_y_continuous(trans = "log10") + 
  scale_x_discrete(labels = c('Natural','Restoring'))
# print at 1200 x 800

ggplot(stem_dens_unique_less, aes(x=Elevation, y=total_stems + 0.0001)) +
    geom_smooth(method = lm) +
  geom_jitter()  +
    theme_bw() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          strip.text = element_text(size = 28))+
  xlab("Elevation")  + 
  ylab("Number of stems per m2") +
  facet_wrap(~Species)
```

## 3e. Stem diameter

First, prepare and explore the data:

-   subset for only Sporobolus, Sarcocornia, Pneumatophores and Triglochin as these are the only species that exist in both natural and restored sites

-   remove NA data

-   explore using histograms of raw and transformed data

-   plot relationship between elevation and stem diameter

    -   given the linear relationship is similar to the gam plotted, stick with linear

```{r Prep/explore}
salt_less <- salt %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(!is.na(Stem_dia_mm)) 

hist(salt_less$Stem_dia_mm) # highly right skewed
hist(log(salt_less$Stem_dia_mm)) # weird but more similar to normal
hist(sqrt(salt_less$Stem_dia_mm)) # worse than log

ggplot(salt_less, aes(x = Elevation, y = Stem_dia_mm)) +
  geom_smooth() +
  geom_smooth(method = lm) +
  geom_point()
```

Next, create a model:

-   log-transform the dependent variable as that meant it approximated normal

-   as we expect each species to have different responses, include interactions between Species and Elevation, species proportion and restoration status

-   also include Dominant Species and Estuary as additional predictors

-   include quadrat (Combo) nested within site as a random factor

-   include a reduced rank correlation matrix to account for measurements in the same quadrat not being independent

-   gaussian distribution **(alternative is Gamma with log-link, but residuals look almost identical)**

```{r Model_create}
M13 <- glmmTMB(log(Stem_dia_mm) ~ DomSpeciesSuperSimp + Estuary + Species*(Elevation + sp_prop + rest_status) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

resid <- residuals(simulateResiduals(M13), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M13, re.form = NA), resid) 
plotQQunif(M13) 
scatter.smooth(predict(M13, re.form = NA), abs(resid))
```

Next, test the model:

-   test model using joint_tests

-   calculate parameter estimates using summary and emmeans

```{r Model_test}
M <- glmmTMB(log(Stem_dia_mm) ~ DomSpeciesSuperSimp + Estuary + Species*(Elevation + sp_prop)  + rest_status +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

M0 <- glmmTMB(log(Stem_dia_mm) ~ DomSpeciesSuperSimp + Estuary + Species*(Elevation + sp_prop) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

anova(M13,M,M0)

joint_tests(M13)
emmeans(M13, pairwise ~ rest_status | Species, type = "response")
emmeans(M13, ~ rest_status, type = "response")
summary(M13)
```

Finally, plot the data.

```{r Plot}
ggplot(salt_less, aes(x=as.factor(rest_status), y=Stem_dia_mm, fill = as.factor(rest_status))) +
    geom_boxplot() +
  geom_jitter()  +
    scale_fill_viridis(discrete = TRUE, begin = 0.5, end = 0.8, option = "A") +
    theme_classic() +
    theme(axis.text = element_text(size = 24),
          axis.title = element_text(size = 28),
          strip.text = element_text(size = 28),
          legend.position = "none")+
  xlab("Restoration status")  + 
  ylab("Stem diameter (mm)") +
  facet_wrap(~Species) +
  scale_x_discrete(labels = c('Natural','Restoring'))
# print at 1200 x 800
```

## 3f. Stem height

First, prepare and explore the data:

-   subset for only species with enough data and remove NAs

-   explore data using histograms of raw and transformed data

-   plot relationship between stem height and the continuous predictor elevation

```{r Prep/explore}
salt_less <- salt %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% subset(!is.na(Stem_ht_mm))

hist(salt_less$Stem_ht_mm) # somewhat right skewed
hist(log(salt_less$Stem_ht_mm)) # somewhat left skewed
hist(sqrt(salt_less$Stem_ht_mm)) # normal!

plot(salt_less$Stem_ht_mm ~ salt_less$Elevation) # could be non-linear
ggplot(salt_less, aes(x = Elevation, y = Stem_ht_mm)) +
  geom_point() +
  facet_wrap(~Species)
```

Next, create a model:

-   Use square-root transformed stem height, as it makes a beautiful normal distribution and when you try to run the below model with non-transformed data, it comes up with model convergence issues.

-   as we expect each species to have different responses, include interactions between Species and Elevation, species proportion and restoration status

-   also include Dominant Species, Estuary and Species (without interactions) as additional predictors

-   include quadrat (Combo) nested within site as a random factor

-   include a reduced rank correlation matrix to account for measurements in the same quadrat not being independent

-   gaussian distribution

```{r Model_create}
M14 <- glmmTMB(sqrt(Stem_ht_mm) ~ Estuary + DomSpeciesSuperSimp + Species*(Elevation + sp_prop + rest_status) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

resid <- residuals(simulateResiduals(M14), quantileFunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(predict(M14, re.form = NA), resid) # fine but some outliers
plotQQunif(M14)

M0 <- glmmTMB(sqrt(Stem_ht_mm) ~ Estuary + Species + Elevation + sp_prop + rest_status +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

check_collinearity(M0)
```

Next, test the model.

-   anova comparing the model to a null model without the Species\*rest_status interaction and without rest_status entirely to test whether rest_status impacts the model

```{r Model_test}
M <- glmmTMB(sqrt(Stem_ht_mm) ~ Estuary + DomSpeciesSuperSimp + Species + Species*(Elevation + sp_prop) + rest_status +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

M0 <- glmmTMB(sqrt(Stem_ht_mm) ~ Estuary + DomSpeciesSuperSimp + Species + Species*(Elevation + sp_prop) +  (1|Site/Combo) + rr(Species+0|Combo, d = 2), family = "gaussian", data = salt_less)

anova(M14, M, M0)


joint_tests(M14)

emmeans(M14, ~ rest_status, type = "response")
emmeans(M14, ~ rest_status | Species, type = "response")
```

Finally, plot the data.

```{r Plot}
```

## 3g. Reproduction

First, prepare the data.

-   as done in the reproduction section above (but so this section can be run independently): create a reproduction dataframe with relevant columns, recode the Seeds variable into a binary factor, create a unique column for each unique species per quadrat, and only take one of each unique combination as a new dataframe "reprod_unique"

-   subset for only species with enough data in both natural and restored sites

-   convert to long format with one row for reproduction type and another for presence/absence

-   subset for only flowers and seeds because there are not enough bud data and remove NAs

-   also similarly make a dataset for unique sporobolus but retain the qualitative values here and recode as an ordinal categorical variable with no \< very few \< few \< some \< lots

```{r Prepare}
reprod <- salt[,c(5,6,7,11,16:18,24,25,28,30:34)]

reprod$Seeds %>% unique() # view unique values
reprod <- reprod %>% mutate(Seeds = case_when(
  Seeds == "No" ~ 0,
  Seeds == "Yes" ~ 1,
  Seeds == "Lots" ~ 1,
  Seeds == "Some" ~ 1,
  Seeds == "Few" ~ 1,
  Seeds == "Very few" ~ 1,
  Seeds == "NA" ~ NA
))

reprod$unique <- factor(interaction(reprod$Combo, reprod$Species, sep = ":"))
reprod_unique <- reprod %>% distinct(unique, .keep_all = TRUE) 

reprod_unique_less <- reprod_unique %>% subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin"))

reprod_all_long <- reprod_unique_less %>% pivot_longer(cols = c("Buds", "Flowers", "Seeds"), names_to = "reprod_type", values_to = "Reproduction")

reprod_all_long <- reprod_all_long %>% subset(!is.na(Reproduction)) %>% 
  subset(reprod_type %in% c("Flowers", "Seeds"))

reprod_spor <- salt[,c(5,6,7,11,18,24,25,28,30:34)] %>% 
  subset(Species == "Sporobolus") %>% 
  mutate(unique = factor(interaction(Combo, Species, sep = ":")))

reprod_spor_unique <- reprod_spor %>% 
  distinct(unique, .keep_all = TRUE) %>% 
  subset(!is.na(Seeds))

reprod_spor_unique$Seeds <- factor(reprod_spor_unique$Seeds, order = TRUE, levels = c("No", "Very few", "Few", "Some", "Lots"))
```

Next, explore the data.

-   explore proportion of reproduction of each type of each species at each site using a "reprod_all_proportions" dataframe

-   for sporobolus seeds dataframe (reprod_spor_unique), plot the count of each category of seeds in each site and each restoration status

-   histograms are not very meaningful as the data are only zeroes and ones, likewise a non-linear relationship with a continuous predictor is impossible

```{r Explore}
reprod_all_proportions <- reprod_all_long %>% 
  group_by(Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), se = sd(Reproduction)/sqrt(n()), rest_status = mean(rest_status)) %>% 
  ungroup()

reprod_all_proportions %>%  
  subset(rest_status == 0) %>% 
  ggplot(aes(x = Site, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species)

reprod_all_proportions %>%  
  subset(rest_status == 1) %>% 
  ggplot(aes(x = Site, y = avg, group = reprod_type, color = reprod_type, ymin = avg-se, ymax = avg+se)) +
  geom_point() +
  geom_errorbar() +
  facet_wrap(~Species)

ggplot(reprod_spor_unique, aes(y = Seeds, fill = as.factor(rest_status))) +
  geom_bar() +
  facet_wrap(~Site)

ggplot(reprod_spor_unique, aes(y = Seeds, fill = as.factor(rest_status))) +
  geom_bar() +
  facet_wrap(~rest_status)
```

Next, create a model:

-   it's binary data so use a binomial distribution

-   as we expect each species to have different responses, include interactions between Species and Elevation, species proportion and restoration status

-   also include Dominant Species as an additional predictor

    -   can't include Estuary as a fixed predictor as the model has errors with it included, likely because the Maroochy dataset is fairly limited for reproduction

-   include quadrat (Combo) nested within site as a random factor

```{r Model_create}
M15 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*(reprod_type * rest_status) + (1|Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_long)

resid <- residuals(simulateResiduals(M15), quantilefunction = qnorm, outlierValues = c(-7,7))
scatter.smooth(resid, predict(M15)) # there are quite a few large values but they are evenly spread so should be ok
plotQQunif(M15) 

```

Next, test the model.

-   use an anova to compare the model to null models without the Species\*rest_status\*reprod_type interaction, without the Species\*rest_status interaction and without rest_status entirely

```{r Model_test}
M1 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*(reprod_type + rest_status) + (1|Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_long)

M <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*reprod_type + rest_status + (1|Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_long)

M0 <- glmmTMB(Reproduction ~ DomSpeciesSuperSimp + Elevation + Species*reprod_type + (1|Site/Combo), contrasts = list(reprod_type = "contr.sum"), family = "binomial", data = reprod_all_long)

anova(M15,M1,M,M0)

joint_tests(M15)

summary(M15)

emmeans(M15, ~ rest_status | Species | reprod_type, type = "response")
```

Finally, plot the data.

```{r Plot}
reprod_proportions_nat <- reprod_all_long %>% 
  subset(rest_status == 0) %>% 
  group_by(rest_status, Site, Species, reprod_type) %>% 
  summarise(avg = mean(Reproduction), 
            se = sd(Reproduction)/sqrt(n())) %>% 
  subset(Species %in% c("Sporobolus", "Sarcocornia", "Triglochin")) %>% 
  subset(reprod_type != "Buds") %>% 
  ungroup()

nat_rep <- ggplot(reprod_proportions_nat %>% subset(Species == "Sporobolus") %>% subset(reprod_type == "Seeds"), aes(y = avg, x= rest_status, label = Site)) +
  geom_boxplot() +
  geom_point() +
  geom_text(hjust = 1.2) +
  theme(axis.text = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.x = element_blank()) +
  xlab("Natural sites") +
  ylim(0.1,1)
nat_rep

# from restored data - sporobolus seeding
rest_rep <- emmip(M8, ~ YSR , at = list(YSR = c(6:33), Species = "Sporobolus", reprod_type = "Seeds"), type = "response", CIs = TRUE, engine = "ggplot", xlab = "Years since restoration", ylab = "Reproduction likelihood") +   
  geom_point(data = reprod_proportions %>% subset(Species == "Sporobolus") %>% subset(reprod_type == "Seeds"), aes(x = YSR, y = avg, group = reprod_type))  +
  ylim(0.1,1)
rest_rep

ggarrange(rest_rep, nat_rep, nrow = 1, ncol = 2, widths = c(3,1))
```
